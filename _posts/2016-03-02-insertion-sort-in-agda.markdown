---
title      : "Insertion sort in Agda"
date       : 2016-03-01 12:00:00
categories : [agda]
tags       : [agda]
---

I wrote this code a long time ago, and verifiying the correctness of
some sorting algorithm is pretty much *the* standard "Hello World! I
can Agda!" blog post---well, that and implementing the
λ-calculus---but I really wanted an excuse to test my Jekyll/Agda
integration.

Now, the version of insertion sort that I will write in this blog post
will be *correct by construction*. By this I mean that I will
implemented insertion sort as a function from lists to ordered lists,
where the type of ordered lists only contains ordered lists.
There are some concerns about whether this style of programming is the
right way to go. If you read a lot of Coq code, you will notice that
Coq programmers often implement functions without *any*
guarantees---e.g. they would implement insertion sort as a function from
lists to lists---and then prove the function's properties separately.
Personally, I have found that this style can lead to very clumsy code,
but there are good arguments to be made for its naive efficiency, both
in terms of time and space---if you don't need some property, you
don't have to compute its proof!

I'm getting carried away... Well, one last announcement in the public
interest. This post is written in literate Agda, and I've gone through
the effort of using the Agda hilighter. This means that all functions
and module names have links to their definitions---be it within the
post, or in the Agda standard library!

Obligatory "this is literate code, here are my imports."

<pre class="Agda"><a name="1629" class="Keyword">open</a><a name="1633"> </a><a name="1634" class="Keyword">import</a><a name="1640"> </a><a name="1641" href="https://agda.github.io/agda-stdlib/Level.html#1" class="Module" target="_blank">Level</a><a name="1646">            </a><a name="1658" class="Keyword">using</a><a name="1663"> </a><a name="1664" class="Symbol">(</a><a name="1665">_⊔_</a><a name="1668" class="Symbol">)</a><a name="1669">
</a><a name="1670" class="Keyword">open</a><a name="1674"> </a><a name="1675" class="Keyword">import</a><a name="1681"> </a><a name="1682" href="https://agda.github.io/agda-stdlib/Data.Vec.html#1" class="Module" target="_blank">Data.Vec</a><a name="1690">         </a><a name="1699" class="Keyword">using</a><a name="1704"> </a><a name="1705" class="Symbol">(</a><a name="1706">Vec</a><a name="1709" class="Symbol">;</a><a name="1710"> []</a><a name="1713" class="Symbol">;</a><a name="1714"> _∷_</a><a name="1718" class="Symbol">)</a><a name="1719">
</a><a name="1720" class="Keyword">open</a><a name="1724"> </a><a name="1725" class="Keyword">import</a><a name="1731"> </a><a name="1732" href="https://agda.github.io/agda-stdlib/Data.Nat.html#1" class="Module" target="_blank">Data.Nat</a><a name="1740">         </a><a name="1749" class="Keyword">using</a><a name="1754"> </a><a name="1755" class="Symbol">(</a><a name="1756">ℕ</a><a name="1757" class="Symbol">;</a><a name="1758"> zero</a><a name="1763" class="Symbol">;</a><a name="1764"> suc</a><a name="1768" class="Symbol">)</a><a name="1769">
</a><a name="1770" class="Keyword">open</a><a name="1774"> </a><a name="1775" class="Keyword">import</a><a name="1781"> </a><a name="1782" href="https://agda.github.io/agda-stdlib/Data.Sum.html#1" class="Module" target="_blank">Data.Sum</a><a name="1790">         </a><a name="1799" class="Keyword">using</a><a name="1804"> </a><a name="1805" class="Symbol">(</a><a name="1806">_⊎_</a><a name="1809" class="Symbol">;</a><a name="1810"> inj₁</a><a name="1815" class="Symbol">;</a><a name="1816"> inj₂</a><a name="1821" class="Symbol">)</a><a name="1822">
</a><a name="1823" class="Keyword">open</a><a name="1827"> </a><a name="1828" class="Keyword">import</a><a name="1834"> </a><a name="1835" href="https://agda.github.io/agda-stdlib/Data.Product.html#1" class="Module" target="_blank">Data.Product</a><a name="1847">     </a><a name="1852" class="Keyword">using</a><a name="1857"> </a><a name="1858" class="Symbol">(</a><a name="1859">∃</a><a name="1860" class="Symbol">;</a><a name="1861"> _,_</a><a name="1865" class="Symbol">;</a><a name="1866"> proj₁</a><a name="1872" class="Symbol">;</a><a name="1873"> proj₂</a><a name="1879" class="Symbol">)</a><a name="1880">
</a><a name="1881" class="Keyword">open</a><a name="1885"> </a><a name="1886" class="Keyword">import</a><a name="1892"> </a><a name="1893" href="https://agda.github.io/agda-stdlib/Data.Empty.html#1" class="Module" target="_blank">Data.Empty</a><a name="1903">       </a><a name="1910" class="Keyword">using</a><a name="1915"> </a><a name="1916" class="Symbol">(</a><a name="1917">⊥-elim</a><a name="1923" class="Symbol">)</a><a name="1924">
</a><a name="1925" class="Keyword">open</a><a name="1929"> </a><a name="1930" class="Keyword">import</a><a name="1936"> </a><a name="1937" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#1" class="Module" target="_blank">Relation.Nullary</a><a name="1953"> </a><a name="1954" class="Keyword">using</a><a name="1959"> </a><a name="1960" class="Symbol">(</a><a name="1961">¬_</a><a name="1963" class="Symbol">;</a><a name="1964"> Dec</a><a name="1968" class="Symbol">;</a><a name="1969"> yes</a><a name="1973" class="Symbol">;</a><a name="1974"> no</a><a name="1977" class="Symbol">)</a><a name="1978">
</a><a name="1979" class="Keyword">open</a><a name="1983"> </a><a name="1984" class="Keyword">import</a><a name="1990"> </a><a name="1991" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#1" class="Module" target="_blank">Relation.Binary</a><a name="2006">
</a><a name="2007" class="Keyword">open</a><a name="2011"> </a><a name="2012" class="Keyword">import</a><a name="2018"> </a><a name="2019" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality</a></pre>

So the first question is "What do we want to sort?" The boring answer
would be "lists of integers", but let's be a little bit more
general. We can sort anything that forms a *decidable, total
order*. Basically, this means three things:

  - we have some type A;
  - for any x and y of type A, we have a *type* of orderings between
    them, which we write as `x ≤ y`;
  - we can actually get that ordering using `x ≤? y` or `total x y`.

Below, we define our module to work for any decidable total order, and
we unpack that order. If you have a look at `≤?` and `total`, you'll
notice that they do slightly different things. For some x and y, `x ≤?
y` will tell you whether or not `x ≤ y`, whereas `total` will tell you
whether it is `x ≤ y` or `y ≤ x`.

<pre class="Agda"><a name="2837" class="Keyword">module</a><a name="2843"> </a><a name="2844" href="#1" class="Module">2016-03-02-insertion-sort-in-agda</a><a name="2877"> </a><a name="2878" class="Symbol">{</a><a name="2879" href="#2879" class="Bound">c</a><a name="2880"> </a><a name="2881" href="#2881" class="Bound">ℓ₁</a><a name="2883"> </a><a name="2884" href="#2884" class="Bound">ℓ₂</a><a name="2886" class="Symbol">}</a><a name="2887"> </a><a name="2888" class="Symbol">(</a><a name="2889" href="#2889" class="Bound">Ord</a><a name="2892"> </a><a name="2893" class="Symbol">:</a><a name="2894"> </a><a name="2895" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#9224" class="Record" target="_blank">DecTotalOrder</a><a name="2908"> </a><a name="2909" href="#2879" class="Bound">c</a><a name="2910"> </a><a name="2911" href="#2881" class="Bound">ℓ₁</a><a name="2913"> </a><a name="2914" href="#2884" class="Bound">ℓ₂</a><a name="2916" class="Symbol">)</a><a name="2917"> </a><a name="2918" class="Keyword">where</a><a name="2923">

  </a><a name="2927" class="Keyword">open</a><a name="2931"> </a><a name="2932" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#9224" class="Module" target="_blank">DecTotalOrder</a><a name="2945"> </a><a name="2946" class="Symbol">{{...}}</a><a name="2953"> </a><a name="2954" class="Keyword">using</a><a name="2959"> </a><a name="2960" class="Symbol">(</a><a name="2961">_≤_</a><a name="2964" class="Symbol">;</a><a name="2965"> _≤?_</a><a name="2970" class="Symbol">;</a><a name="2971"> total</a><a name="2977" class="Symbol">)</a><a name="2978"> </a><a name="2979" class="Keyword">renaming</a><a name="2987"> </a><a name="2988" class="Symbol">(</a><a name="2989">trans </a><a name="2995" class="Symbol">to</a><a name="2997"> ≤-trans</a><a name="3005" class="Symbol">)</a><a name="3006">
  </a><a name="3009" href="#3009" class="Function">A</a><a name="3010"> </a><a name="3011" class="Symbol">=</a><a name="3012"> </a><a name="3013" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#9308" class="Field" target="_blank">DecTotalOrder.Carrier</a><a name="3034"> </a><a name="3035" href="#2889" class="Bound">Ord</a></pre>

The type A is already ordered, but it would be incredibly convenient
if it were also *bounded*---meaning that it has a value which is
smaller than everything else, and a value which is bigger than
everything else. Below, we define a wrapper for A which is bounded at
the top by ⊤ and at the bottom by ⊥:

<pre class="Agda">  <a name="3371" class="Keyword">data</a><a name="3375"> </a><a name="3376" href="#3376" class="Datatype">Â</a><a name="3378"> </a><a name="3379" class="Symbol">:</a><a name="3380"> </a><a name="3381" class="PrimitiveType">Set</a><a name="3384"> </a><a name="3385" href="#2879" class="Bound">c</a><a name="3386"> </a><a name="3387" class="Keyword">where</a><a name="3392">
    </a><a name="3397" href="#3397" class="InductiveConstructor">⊤</a><a name="3398"> </a><a name="3399" class="Symbol">:</a><a name="3400"> </a><a name="3401" href="#3376" class="Datatype">Â</a><a name="3403">
    </a><a name="3408" href="#3408" class="InductiveConstructor">⊥</a><a name="3409"> </a><a name="3410" class="Symbol">:</a><a name="3411"> </a><a name="3412" href="#3376" class="Datatype">Â</a><a name="3414">
    </a><a name="3419" href="#3419" class="InductiveConstructor Operator">⟦_⟧</a><a name="3422"> </a><a name="3423" class="Symbol">:</a><a name="3424"> </a><a name="3425" href="#3009" class="Function">A</a><a name="3426"> </a><a name="3427" class="Symbol">→</a><a name="3428"> </a><a name="3429" href="#3376" class="Datatype">Â</a></pre>

We still need to encode the fact that ⊥ and ⊤ are in fact smaller and
bigger than all other values. Below, we defined the order ≲ on bounded
Â... where we simply state these facts as ⊥≲ and ≲⊤:

<pre class="Agda">  <a name="3655" class="Keyword">infix</a><a name="3660"> </a><a name="3661" class="Number">4</a><a name="3662"> _≲_

  </a><a name="3670" class="Keyword">data</a><a name="3674"> </a><a name="3675" href="#3675" class="Datatype Operator">_≲_</a><a name="3678"> </a><a name="3679" class="Symbol">:</a><a name="3680"> </a><a name="3681" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#740" class="Function" target="_blank">Rel</a><a name="3684"> </a><a name="3685" href="#3376" class="Datatype">Â</a><a name="3687"> </a><a name="3688" class="Symbol">(</a><a name="3689" href="#2879" class="Bound">c</a><a name="3690"> </a><a name="3691" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#626" class="Primitive Operator" target="_blank">⊔</a><a name="3692"> </a><a name="3693" href="#2884" class="Bound">ℓ₂</a><a name="3695" class="Symbol">)</a><a name="3696"> </a><a name="3697" class="Keyword">where</a><a name="3702">
    </a><a name="3707" href="#3707" class="InductiveConstructor">⊥≲</a><a name="3709"> </a><a name="3710" class="Symbol">:</a><a name="3711"> </a><a name="3712" class="Symbol">∀</a><a name="3713"> </a><a name="3714" class="Symbol">{</a><a name="3715" href="#3715" class="Bound">x</a><a name="3716" class="Symbol">}</a><a name="3717"> </a><a name="3718" class="Symbol">→</a><a name="3719"> </a><a name="3720" href="#3408" class="InductiveConstructor">⊥</a><a name="3721"> </a><a name="3722" href="#3675" class="Datatype Operator">≲</a><a name="3723"> </a><a name="3724" href="#3715" class="Bound">x</a><a name="3725">
    </a><a name="3730" href="#3730" class="InductiveConstructor">≲⊤</a><a name="3732"> </a><a name="3733" class="Symbol">:</a><a name="3734"> </a><a name="3735" class="Symbol">∀</a><a name="3736"> </a><a name="3737" class="Symbol">{</a><a name="3738" href="#3738" class="Bound">x</a><a name="3739" class="Symbol">}</a><a name="3740"> </a><a name="3741" class="Symbol">→</a><a name="3742"> </a><a name="3743" href="#3738" class="Bound">x</a><a name="3744"> </a><a name="3745" href="#3675" class="Datatype Operator">≲</a><a name="3746"> </a><a name="3747" href="#3397" class="InductiveConstructor">⊤</a><a name="3748">
    </a><a name="3753" href="#3753" class="InductiveConstructor">≤-lift</a><a name="3759"> </a><a name="3760" class="Symbol">:</a><a name="3761"> </a><a name="3762" class="Symbol">∀</a><a name="3763"> </a><a name="3764" class="Symbol">{</a><a name="3765" href="#3765" class="Bound">x</a><a name="3766"> </a><a name="3767" href="#3767" class="Bound">y</a><a name="3768" class="Symbol">}</a><a name="3769"> </a><a name="3770" class="Symbol">→</a><a name="3771"> </a><a name="3772" href="#3765" class="Bound">x</a><a name="3773"> </a><a name="3774" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#9373" class="Field Operator" target="_blank">≤</a><a name="3775"> </a><a name="3776" href="#3767" class="Bound">y</a><a name="3777"> </a><a name="3778" class="Symbol">→</a><a name="3779"> </a><a name="3780" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="3781"> </a><a name="3782" href="#3765" class="Bound">x</a><a name="3783"> </a><a name="3784" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="3785"> </a><a name="3786" href="#3675" class="Datatype Operator">≲</a><a name="3787"> </a><a name="3788" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="3789"> </a><a name="3790" href="#3767" class="Bound">y</a><a name="3791"> </a><a name="3792" href="#3419" class="InductiveConstructor Operator">⟧</a></pre>

Note that with the last constructor, we can lift the order of any two
values in A into ≲. However, if we only have a proof of ≰, then the
lifting is slightly more involved. Therefore, we define a function
which does this for us:

<pre class="Agda">  <a name="4051" href="#4051" class="Function">≰-lift</a><a name="4057"> </a><a name="4058" class="Symbol">:</a><a name="4059"> </a><a name="4060" class="Symbol">∀</a><a name="4061"> </a><a name="4062" class="Symbol">{</a><a name="4063" href="#4063" class="Bound">x</a><a name="4064"> </a><a name="4065" href="#4065" class="Bound">y</a><a name="4066" class="Symbol">}</a><a name="4067"> </a><a name="4068" class="Symbol">→</a><a name="4069"> </a><a name="4070" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#414" class="Function Operator" target="_blank">¬</a><a name="4071"> </a><a name="4072" class="Symbol">(</a><a name="4073" href="#4065" class="Bound">y</a><a name="4074"> </a><a name="4075" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#9373" class="Field Operator" target="_blank">≤</a><a name="4076"> </a><a name="4077" href="#4063" class="Bound">x</a><a name="4078" class="Symbol">)</a><a name="4079"> </a><a name="4080" class="Symbol">→</a><a name="4081"> </a><a name="4082" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4083"> </a><a name="4084" href="#4063" class="Bound">x</a><a name="4085"> </a><a name="4086" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4087"> </a><a name="4088" href="#3675" class="Datatype Operator">≲</a><a name="4089"> </a><a name="4090" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4091"> </a><a name="4092" href="#4065" class="Bound">y</a><a name="4093"> </a><a name="4094" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4095">
  </a><a name="4098" href="#4051" class="Function">≰-lift</a><a name="4104"> </a><a name="4105" class="Symbol">{</a><a name="4106" href="#4106" class="Bound">x</a><a name="4107" class="Symbol">}</a><a name="4108"> </a><a name="4109" class="Symbol">{</a><a name="4110" href="#4110" class="Bound">y</a><a name="4111" class="Symbol">}</a><a name="4112"> </a><a name="4113" href="#4113" class="Bound">y≰x</a><a name="4116"> </a><a name="4117" class="Keyword">with</a><a name="4121"> </a><a name="4122" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#8067" class="Function" target="_blank">total</a><a name="4127"> </a><a name="4128" href="#4106" class="Bound">x</a><a name="4129"> </a><a name="4130" href="#4110" class="Bound">y</a><a name="4131">
  </a><a name="4134" href="#4051" class="Function">≰-lift</a><a name="4140"> </a><a name="4141" href="#4141" class="Bound">y≰x</a><a name="4144"> </a><a name="4145" class="Symbol">|</a><a name="4146"> </a><a name="4147" href="https://agda.github.io/agda-stdlib/Data.Sum.html#489" class="InductiveConstructor" target="_blank">inj₁</a><a name="4151"> </a><a name="4152" href="#4152" class="Bound">x≤y</a><a name="4155"> </a><a name="4156" class="Symbol">=</a><a name="4157"> </a><a name="4158" href="#3753" class="InductiveConstructor">≤-lift</a><a name="4164"> </a><a name="4165" href="#4152" class="Bound">x≤y</a><a name="4168">
  </a><a name="4171" href="#4051" class="Function">≰-lift</a><a name="4177"> </a><a name="4178" href="#4178" class="Bound">y≰x</a><a name="4181"> </a><a name="4182" class="Symbol">|</a><a name="4183"> </a><a name="4184" href="https://agda.github.io/agda-stdlib/Data.Sum.html#514" class="InductiveConstructor" target="_blank">inj₂</a><a name="4188"> </a><a name="4189" href="#4189" class="Bound">y≤x</a><a name="4192"> </a><a name="4193" class="Symbol">=</a><a name="4194"> </a><a name="4195" href="https://agda.github.io/agda-stdlib/Data.Empty.html#326" class="Function" target="_blank">⊥-elim</a><a name="4201"> </a><a name="4202" class="Symbol">(</a><a name="4203" href="#4178" class="Bound">y≰x</a><a name="4206"> </a><a name="4207" href="#4189" class="Bound">y≤x</a><a name="4210" class="Symbol">)</a></pre>

Another thing we can do with two values of type Â is compute their
*minimum*. This is one example where we deviate from *correctness by
construction*: we define minimum function ⊓, and only then prove its
correctness:

<pre class="Agda">  <a name="4459" class="Keyword">infix</a><a name="4464"> </a><a name="4465" class="Number">5</a><a name="4466"> _⊓_

  </a><a name="4474" href="#4474" class="Function Operator">_⊓_</a><a name="4477"> </a><a name="4478" class="Symbol">:</a><a name="4479"> </a><a name="4480" href="#3376" class="Datatype">Â</a><a name="4482"> </a><a name="4483" class="Symbol">→</a><a name="4484"> </a><a name="4485" href="#3376" class="Datatype">Â</a><a name="4487"> </a><a name="4488" class="Symbol">→</a><a name="4489"> </a><a name="4490" href="#3376" class="Datatype">Â</a><a name="4492">
  </a><a name="4495" href="#3397" class="InductiveConstructor">⊤</a><a name="4496"> </a><a name="4497" href="#4474" class="Function Operator">⊓</a><a name="4498"> </a><a name="4499" href="#4499" class="Bound">y</a><a name="4500"> </a><a name="4501" class="Symbol">=</a><a name="4502"> </a><a name="4503" href="#4499" class="Bound">y</a><a name="4504">
  </a><a name="4507" href="#3408" class="InductiveConstructor">⊥</a><a name="4508"> </a><a name="4509" href="#4474" class="Function Operator">⊓</a><a name="4510"> </a><a name="4511" class="Symbol">_</a><a name="4512"> </a><a name="4513" class="Symbol">=</a><a name="4514"> </a><a name="4515" href="#3408" class="InductiveConstructor">⊥</a><a name="4516">
  </a><a name="4519" href="#4519" class="Bound">x</a><a name="4520"> </a><a name="4521" href="#4474" class="Function Operator">⊓</a><a name="4522"> </a><a name="4523" href="#3397" class="InductiveConstructor">⊤</a><a name="4524"> </a><a name="4525" class="Symbol">=</a><a name="4526"> </a><a name="4527" href="#4519" class="Bound">x</a><a name="4528">
  </a><a name="4531" class="Symbol">_</a><a name="4532"> </a><a name="4533" href="#4474" class="Function Operator">⊓</a><a name="4534"> </a><a name="4535" href="#3408" class="InductiveConstructor">⊥</a><a name="4536"> </a><a name="4537" class="Symbol">=</a><a name="4538"> </a><a name="4539" href="#3408" class="InductiveConstructor">⊥</a><a name="4540">
  </a><a name="4543" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4544"> </a><a name="4545" href="#4545" class="Bound">x</a><a name="4546"> </a><a name="4547" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4548"> </a><a name="4549" href="#4474" class="Function Operator">⊓</a><a name="4550"> </a><a name="4551" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4552"> </a><a name="4553" href="#4553" class="Bound">y</a><a name="4554"> </a><a name="4555" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4556"> </a><a name="4557" class="Keyword">with</a><a name="4561"> </a><a name="4562" href="#4545" class="Bound">x</a><a name="4563"> </a><a name="4564" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#8876" class="Function Operator" target="_blank">≤?</a><a name="4566"> </a><a name="4567" href="#4553" class="Bound">y</a><a name="4568">
  </a><a name="4571" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4572"> </a><a name="4573" href="#4573" class="Bound">x</a><a name="4574"> </a><a name="4575" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4576"> </a><a name="4577" href="#4474" class="Function Operator">⊓</a><a name="4578"> </a><a name="4579" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4580"> </a><a name="4581" href="#4581" class="Bound">y</a><a name="4582"> </a><a name="4583" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4584"> </a><a name="4585" class="Symbol">|</a><a name="4586"> </a><a name="4587" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#520" class="InductiveConstructor" target="_blank">yes</a><a name="4590"> </a><a name="4591" href="#4591" class="Bound">x≤y</a><a name="4594"> </a><a name="4595" class="Symbol">=</a><a name="4596"> </a><a name="4597" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4598"> </a><a name="4599" href="#4573" class="Bound">x</a><a name="4600"> </a><a name="4601" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4602">
  </a><a name="4605" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4606"> </a><a name="4607" href="#4607" class="Bound">x</a><a name="4608"> </a><a name="4609" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4610"> </a><a name="4611" href="#4474" class="Function Operator">⊓</a><a name="4612"> </a><a name="4613" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4614"> </a><a name="4615" href="#4615" class="Bound">y</a><a name="4616"> </a><a name="4617" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4618"> </a><a name="4619" class="Symbol">|</a><a name="4620"> </a><a name="4621" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#547" class="InductiveConstructor" target="_blank">no</a><a name="4623">  </a><a name="4625" href="#4625" class="Bound">x&gt;y</a><a name="4628"> </a><a name="4629" class="Symbol">=</a><a name="4630"> </a><a name="4631" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4632"> </a><a name="4633" href="#4615" class="Bound">y</a><a name="4634"> </a><a name="4635" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4636">

  </a><a name="4640" href="#4640" class="Function">⊓-conserves-≲</a><a name="4653"> </a><a name="4654" class="Symbol">:</a><a name="4655"> </a><a name="4656" class="Symbol">∀</a><a name="4657"> </a><a name="4658" class="Symbol">{</a><a name="4659" href="#4659" class="Bound">x</a><a name="4660"> </a><a name="4661" href="#4661" class="Bound">y</a><a name="4662"> </a><a name="4663" href="#4663" class="Bound">z</a><a name="4664" class="Symbol">}</a><a name="4665"> </a><a name="4666" class="Symbol">→</a><a name="4667"> </a><a name="4668" href="#4659" class="Bound">x</a><a name="4669"> </a><a name="4670" href="#3675" class="Datatype Operator">≲</a><a name="4671"> </a><a name="4672" href="#4661" class="Bound">y</a><a name="4673"> </a><a name="4674" class="Symbol">→</a><a name="4675"> </a><a name="4676" href="#4659" class="Bound">x</a><a name="4677"> </a><a name="4678" href="#3675" class="Datatype Operator">≲</a><a name="4679"> </a><a name="4680" href="#4663" class="Bound">z</a><a name="4681"> </a><a name="4682" class="Symbol">→</a><a name="4683"> </a><a name="4684" href="#4659" class="Bound">x</a><a name="4685"> </a><a name="4686" href="#3675" class="Datatype Operator">≲</a><a name="4687"> </a><a name="4688" href="#4661" class="Bound">y</a><a name="4689"> </a><a name="4690" href="#4474" class="Function Operator">⊓</a><a name="4691"> </a><a name="4692" href="#4663" class="Bound">z</a><a name="4693">
  </a><a name="4696" href="#4640" class="Function">⊓-conserves-≲</a><a name="4709"> </a><a name="4710" class="Symbol">{</a><a name="4711" href="#4711" class="Bound">x</a><a name="4712" class="Symbol">}</a><a name="4713"> </a><a name="4714" class="Symbol">{</a><a name="4715" href="#3397" class="InductiveConstructor">⊤</a><a name="4716" class="Symbol">}</a><a name="4717"> </a><a name="4718" class="Symbol">{_}</a><a name="4721"> </a><a name="4722" class="Symbol">_</a><a name="4723"> </a><a name="4724" href="#4724" class="Bound">q</a><a name="4725"> </a><a name="4726" class="Symbol">=</a><a name="4727"> </a><a name="4728" href="#4724" class="Bound">q</a><a name="4729">
  </a><a name="4732" href="#4640" class="Function">⊓-conserves-≲</a><a name="4745"> </a><a name="4746" class="Symbol">{</a><a name="4747" href="#4747" class="Bound">x</a><a name="4748" class="Symbol">}</a><a name="4749"> </a><a name="4750" class="Symbol">{</a><a name="4751" href="#3408" class="InductiveConstructor">⊥</a><a name="4752" class="Symbol">}</a><a name="4753"> </a><a name="4754" class="Symbol">{_}</a><a name="4757"> </a><a name="4758" href="#4758" class="Bound">p</a><a name="4759"> </a><a name="4760" class="Symbol">_</a><a name="4761"> </a><a name="4762" class="Symbol">=</a><a name="4763"> </a><a name="4764" href="#4758" class="Bound">p</a><a name="4765">
  </a><a name="4768" href="#4640" class="Function">⊓-conserves-≲</a><a name="4781"> </a><a name="4782" class="Symbol">{</a><a name="4783" href="#4783" class="Bound">x</a><a name="4784" class="Symbol">}</a><a name="4785"> </a><a name="4786" class="Symbol">{</a><a name="4787" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4788"> </a><a name="4789" class="Symbol">_</a><a name="4790"> </a><a name="4791" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4792" class="Symbol">}</a><a name="4793"> </a><a name="4794" class="Symbol">{</a><a name="4795" href="#3397" class="InductiveConstructor">⊤</a><a name="4796" class="Symbol">}</a><a name="4797"> </a><a name="4798" href="#4798" class="Bound">p</a><a name="4799"> </a><a name="4800" class="Symbol">_</a><a name="4801"> </a><a name="4802" class="Symbol">=</a><a name="4803"> </a><a name="4804" href="#4798" class="Bound">p</a><a name="4805">
  </a><a name="4808" href="#4640" class="Function">⊓-conserves-≲</a><a name="4821"> </a><a name="4822" class="Symbol">{</a><a name="4823" href="#4823" class="Bound">x</a><a name="4824" class="Symbol">}</a><a name="4825"> </a><a name="4826" class="Symbol">{</a><a name="4827" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4828"> </a><a name="4829" class="Symbol">_</a><a name="4830"> </a><a name="4831" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4832" class="Symbol">}</a><a name="4833"> </a><a name="4834" class="Symbol">{</a><a name="4835" href="#3408" class="InductiveConstructor">⊥</a><a name="4836" class="Symbol">}</a><a name="4837"> </a><a name="4838" class="Symbol">_</a><a name="4839"> </a><a name="4840" href="#4840" class="Bound">q</a><a name="4841"> </a><a name="4842" class="Symbol">=</a><a name="4843"> </a><a name="4844" href="#4840" class="Bound">q</a><a name="4845">
  </a><a name="4848" href="#4640" class="Function">⊓-conserves-≲</a><a name="4861"> </a><a name="4862" class="Symbol">{</a><a name="4863" href="#4863" class="Bound">x</a><a name="4864" class="Symbol">}</a><a name="4865"> </a><a name="4866" class="Symbol">{</a><a name="4867" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4868"> </a><a name="4869" href="#4869" class="Bound">y</a><a name="4870"> </a><a name="4871" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4872" class="Symbol">}</a><a name="4873"> </a><a name="4874" class="Symbol">{</a><a name="4875" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4876"> </a><a name="4877" href="#4877" class="Bound">z</a><a name="4878"> </a><a name="4879" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4880" class="Symbol">}</a><a name="4881"> </a><a name="4882" href="#4882" class="Bound">p</a><a name="4883"> </a><a name="4884" href="#4884" class="Bound">q</a><a name="4885"> </a><a name="4886" class="Keyword">with</a><a name="4890"> </a><a name="4891" href="#4869" class="Bound">y</a><a name="4892"> </a><a name="4893" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#8876" class="Function Operator" target="_blank">≤?</a><a name="4895"> </a><a name="4896" href="#4877" class="Bound">z</a><a name="4897">
  </a><a name="4900" href="#4640" class="Function">⊓-conserves-≲</a><a name="4913"> </a><a name="4914" class="Symbol">{</a><a name="4915" href="#4915" class="Bound">x</a><a name="4916" class="Symbol">}</a><a name="4917"> </a><a name="4918" class="Symbol">{</a><a name="4919" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4920"> </a><a name="4921" href="#4921" class="Bound">y</a><a name="4922"> </a><a name="4923" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4924" class="Symbol">}</a><a name="4925"> </a><a name="4926" class="Symbol">{</a><a name="4927" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4928"> </a><a name="4929" href="#4929" class="Bound">z</a><a name="4930"> </a><a name="4931" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4932" class="Symbol">}</a><a name="4933"> </a><a name="4934" href="#4934" class="Bound">p</a><a name="4935"> </a><a name="4936" class="Symbol">_</a><a name="4937"> </a><a name="4938" class="Symbol">|</a><a name="4939"> </a><a name="4940" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#520" class="InductiveConstructor" target="_blank">yes</a><a name="4943"> </a><a name="4944" href="#4944" class="Bound">y≤z</a><a name="4947"> </a><a name="4948" class="Symbol">=</a><a name="4949"> </a><a name="4950" href="#4934" class="Bound">p</a><a name="4951">
  </a><a name="4954" href="#4640" class="Function">⊓-conserves-≲</a><a name="4967"> </a><a name="4968" class="Symbol">{</a><a name="4969" href="#4969" class="Bound">x</a><a name="4970" class="Symbol">}</a><a name="4971"> </a><a name="4972" class="Symbol">{</a><a name="4973" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4974"> </a><a name="4975" href="#4975" class="Bound">y</a><a name="4976"> </a><a name="4977" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4978" class="Symbol">}</a><a name="4979"> </a><a name="4980" class="Symbol">{</a><a name="4981" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="4982"> </a><a name="4983" href="#4983" class="Bound">z</a><a name="4984"> </a><a name="4985" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="4986" class="Symbol">}</a><a name="4987"> </a><a name="4988" class="Symbol">_</a><a name="4989"> </a><a name="4990" href="#4990" class="Bound">q</a><a name="4991"> </a><a name="4992" class="Symbol">|</a><a name="4993"> </a><a name="4994" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#547" class="InductiveConstructor" target="_blank">no</a><a name="4996">  </a><a name="4998" href="#4998" class="Bound">y≰z</a><a name="5001"> </a><a name="5002" class="Symbol">=</a><a name="5003"> </a><a name="5004" href="#4990" class="Bound">q</a></pre>

Insertion sort has rather complicated invariants. If we were implementing
mergesort, that we could define ordered lists as lists in which every
element is larger than those before it... But alas! Such a crude
analysis won't work for insertion sort! In fact, the only guarantee that
insertion sort gives us is that after one "bubble"---one iteration over
the list---the *last* element is sorted... and that after *k* insertions,
the last *k* elements are sorted...

So to implement insertion sort, we're going to need some way to represent
lists of which the last *k* elements are sorted. In fact, because it's
easier to implement, we're going to go with an encoding which ensures
us that at most the *first* *k* elements are still *unsorted*.

The `OVec` datatype below has three parameters: *l*, *n* and *k*. The
first of these is the lower bound... that is to say, of the sorted
part, the smallest element is *l*.
The second is the length of the list. One question that we've avoided
so far is the question "What sort of things can go wrong in a sorting
algorithm?" Obviously, the first thing that comes to mind is "it
doens't sort", but some other problems that it could have is that it
can *delete* elements, or *copy* elements. While keeping track of the
length doesn't solve *all* of those problems---if we delete as much as
we copy, we don't change the length---but it's a good starting point.
The last, *k*, is the number of still unsorted elements at the
beginning of the list.

There are three ways to construct an `OVec`:

  - we have the empty list, which has zero length, and zero unsorted
    elements... and a sorted segment of length zero with lower bound
    ⊤---this was the main reason to introduce Â;
  - we can add an element to the sorted segment of the list---as long
    as there aren't any unsorted elements in there yet---but we will
    have to prove that the new element is actually smaller than the
    current lower bound;
  - and finally, we can forgo all sorting, and just add some unsorted
    elements to the front of the list.

<pre class="Agda">  <a name="7097" class="Keyword">data</a><a name="7101"> </a><a name="7102" href="#7102" class="Datatype">OVec</a><a name="7106"> </a><a name="7107" class="Symbol">:</a><a name="7108"> </a><a name="7109" class="Symbol">(</a><a name="7110" href="#7110" class="Bound">l</a><a name="7111"> </a><a name="7112" class="Symbol">:</a><a name="7113"> </a><a name="7114" href="#3376" class="Datatype">Â</a><a name="7116" class="Symbol">)</a><a name="7117"> </a><a name="7118" class="Symbol">(</a><a name="7119" href="#7119" class="Bound">n</a><a name="7120"> </a><a name="7121" href="#7121" class="Bound">k</a><a name="7122"> </a><a name="7123" class="Symbol">:</a><a name="7124"> </a><a name="7125" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#682" class="Datatype" target="_blank">ℕ</a><a name="7126" class="Symbol">)</a><a name="7127"> </a><a name="7128" class="Symbol">→</a><a name="7129"> </a><a name="7130" class="PrimitiveType">Set</a><a name="7133"> </a><a name="7134" class="Symbol">(</a><a name="7135" href="#2879" class="Bound">c</a><a name="7136"> </a><a name="7137" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#626" class="Primitive Operator" target="_blank">⊔</a><a name="7138"> </a><a name="7139" href="#2884" class="Bound">ℓ₂</a><a name="7141" class="Symbol">)</a><a name="7142"> </a><a name="7143" class="Keyword">where</a><a name="7148">

    </a><a name="7154" href="#7154" class="InductiveConstructor">[]</a><a name="7156">     </a><a name="7161" class="Symbol">:</a><a name="7162"> </a><a name="7163" href="#7102" class="Datatype">OVec</a><a name="7167"> </a><a name="7168" href="#3397" class="InductiveConstructor">⊤</a><a name="7169"> </a><a name="7170" class="Number">0</a><a name="7171"> </a><a name="7172" class="Number">0</a><a name="7173">

    </a><a name="7179" href="#7179" class="InductiveConstructor Operator">_∷_by_</a><a name="7185"> </a><a name="7186" class="Symbol">:</a><a name="7187"> </a><a name="7188" class="Symbol">∀</a><a name="7189"> </a><a name="7190" class="Symbol">{</a><a name="7191" href="#7191" class="Bound">l</a><a name="7192"> </a><a name="7193" href="#7193" class="Bound">n</a><a name="7194" class="Symbol">}</a><a name="7195"> </a><a name="7196" class="Symbol">(</a><a name="7197" href="#7197" class="Bound">x</a><a name="7198"> </a><a name="7199" class="Symbol">:</a><a name="7200"> </a><a name="7201" href="#3009" class="Function">A</a><a name="7202" class="Symbol">)</a><a name="7203"> </a><a name="7204" class="Symbol">(</a><a name="7205" href="#7205" class="Bound">xs</a><a name="7207"> </a><a name="7208" class="Symbol">:</a><a name="7209"> </a><a name="7210" href="#7102" class="Datatype">OVec</a><a name="7214"> </a><a name="7215" href="#7191" class="Bound">l</a><a name="7216"> </a><a name="7217" href="#7193" class="Bound">n</a><a name="7218"> </a><a name="7219" class="Number">0</a><a name="7220" class="Symbol">)</a><a name="7221">
           </a><a name="7233" class="Symbol">→</a><a name="7234"> </a><a name="7235" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="7236"> </a><a name="7237" href="#7197" class="Bound">x</a><a name="7238"> </a><a name="7239" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="7240"> </a><a name="7241" href="#3675" class="Datatype Operator">≲</a><a name="7242"> </a><a name="7243" href="#7191" class="Bound">l</a><a name="7244"> </a><a name="7245" class="Symbol">→</a><a name="7246"> </a><a name="7247" href="#7102" class="Datatype">OVec</a><a name="7251"> </a><a name="7252" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="7253"> </a><a name="7254" href="#7197" class="Bound">x</a><a name="7255"> </a><a name="7256" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="7257"> </a><a name="7258" class="Symbol">(</a><a name="7259" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#709" class="InductiveConstructor" target="_blank">suc</a><a name="7262"> </a><a name="7263" href="#7193" class="Bound">n</a><a name="7264" class="Symbol">)</a><a name="7265"> </a><a name="7266" class="Number">0</a><a name="7267">

    </a><a name="7273" href="#7273" class="InductiveConstructor Operator">_∷_</a><a name="7276">    </a><a name="7280" class="Symbol">:</a><a name="7281"> </a><a name="7282" class="Symbol">∀</a><a name="7283"> </a><a name="7284" class="Symbol">{</a><a name="7285" href="#7285" class="Bound">l</a><a name="7286"> </a><a name="7287" href="#7287" class="Bound">n</a><a name="7288"> </a><a name="7289" href="#7289" class="Bound">k</a><a name="7290" class="Symbol">}</a><a name="7291"> </a><a name="7292" class="Symbol">(</a><a name="7293" href="#7293" class="Bound">x</a><a name="7294"> </a><a name="7295" class="Symbol">:</a><a name="7296"> </a><a name="7297" href="#3009" class="Function">A</a><a name="7298" class="Symbol">)</a><a name="7299"> </a><a name="7300" class="Symbol">(</a><a name="7301" href="#7301" class="Bound">xs</a><a name="7303"> </a><a name="7304" class="Symbol">:</a><a name="7305"> </a><a name="7306" href="#7102" class="Datatype">OVec</a><a name="7310"> </a><a name="7311" href="#7285" class="Bound">l</a><a name="7312"> </a><a name="7313" href="#7287" class="Bound">n</a><a name="7314"> </a><a name="7315" href="#7289" class="Bound">k</a><a name="7316" class="Symbol">)</a><a name="7317">
           </a><a name="7329" class="Symbol">→</a><a name="7330"> </a><a name="7331" href="#7102" class="Datatype">OVec</a><a name="7335"> </a><a name="7336" href="#3408" class="InductiveConstructor">⊥</a><a name="7337"> </a><a name="7338" class="Symbol">(</a><a name="7339" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#709" class="InductiveConstructor" target="_blank">suc</a><a name="7342"> </a><a name="7343" href="#7287" class="Bound">n</a><a name="7344" class="Symbol">)</a><a name="7345"> </a><a name="7346" class="Symbol">(</a><a name="7347" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#709" class="InductiveConstructor" target="_blank">suc</a><a name="7350"> </a><a name="7351" href="#7289" class="Bound">k</a><a name="7352" class="Symbol">)</a></pre>

If we have a regular vector---a list which tracks its length---we can
turn it into a k-ordered vector together with some lower bound. (This
is the reason we're using vectors... if we were using lists, we'd have
another existential with the lists length in it.) Our naive process of
just inserting all elements in the vector as *unsorted* means that the
lower bound will be either ⊤ or ⊥. And we can show that!

<pre class="Agda">  <a name="7792" href="#7792" class="Function">fromVec</a><a name="7799"> </a><a name="7800" class="Symbol">:</a><a name="7801"> </a><a name="7802" class="Symbol">∀</a><a name="7803"> </a><a name="7804" class="Symbol">{</a><a name="7805" href="#7805" class="Bound">n</a><a name="7806" class="Symbol">}</a><a name="7807"> </a><a name="7808" class="Symbol">→</a><a name="7809"> </a><a name="7810" href="https://agda.github.io/agda-stdlib/Data.Vec.html#609" class="Datatype" target="_blank">Vec</a><a name="7813"> </a><a name="7814" href="#3009" class="Function">A</a><a name="7815"> </a><a name="7816" href="#7805" class="Bound">n</a><a name="7817"> </a><a name="7818" class="Symbol">→</a><a name="7819"> </a><a name="7820" href="https://agda.github.io/agda-stdlib/Data.Product.html#823" class="Function" target="_blank">∃</a><a name="7821"> </a><a name="7822" class="Symbol">(λ</a><a name="7824"> </a><a name="7825" href="#7825" class="Bound">l</a><a name="7826"> </a><a name="7827" class="Symbol">→</a><a name="7828"> </a><a name="7829" href="#7102" class="Datatype">OVec</a><a name="7833"> </a><a name="7834" href="#7825" class="Bound">l</a><a name="7835"> </a><a name="7836" href="#7805" class="Bound">n</a><a name="7837"> </a><a name="7838" href="#7805" class="Bound">n</a><a name="7839" class="Symbol">)</a><a name="7840">
  </a><a name="7843" href="#7792" class="Function">fromVec</a><a name="7850"> </a><a name="7851" href="https://agda.github.io/agda-stdlib/Data.Vec.html#649" class="InductiveConstructor" target="_blank">[]</a><a name="7853"> </a><a name="7854" class="Symbol">=</a><a name="7855"> </a><a name="7856" href="#3397" class="InductiveConstructor">⊤</a><a name="7857"> </a><a name="7858" href="https://agda.github.io/agda-stdlib/Data.Product.html#509" class="InductiveConstructor Operator" target="_blank">,</a><a name="7859"> </a><a name="7860" href="#7154" class="InductiveConstructor">[]</a><a name="7862">
  </a><a name="7865" href="#7792" class="Function">fromVec</a><a name="7872"> </a><a name="7873" class="Symbol">(</a><a name="7874" href="#7874" class="Bound">x</a><a name="7875"> </a><a name="7876" href="https://agda.github.io/agda-stdlib/Data.Vec.html#668" class="InductiveConstructor Operator" target="_blank">∷</a><a name="7877"> </a><a name="7878" href="#7878" class="Bound">xs</a><a name="7880" class="Symbol">)</a><a name="7881"> </a><a name="7882" class="Symbol">=</a><a name="7883"> </a><a name="7884" href="#3408" class="InductiveConstructor">⊥</a><a name="7885"> </a><a name="7886" href="https://agda.github.io/agda-stdlib/Data.Product.html#509" class="InductiveConstructor Operator" target="_blank">,</a><a name="7887"> </a><a name="7888" href="#7874" class="Bound">x</a><a name="7889"> </a><a name="7890" href="#7273" class="InductiveConstructor Operator">∷</a><a name="7891"> </a><a name="7892" href="https://agda.github.io/agda-stdlib/Data.Product.html#539" class="Field" target="_blank">proj₂</a><a name="7897"> </a><a name="7898" class="Symbol">(</a><a name="7899" href="#7792" class="Function">fromVec</a><a name="7906"> </a><a name="7907" href="#7878" class="Bound">xs</a><a name="7909" class="Symbol">)</a><a name="7910">

  </a><a name="7914" href="#7914" class="Function">fromVec-⊤or⊥</a><a name="7926"> </a><a name="7927" class="Symbol">:</a><a name="7928"> </a><a name="7929" class="Symbol">∀</a><a name="7930"> </a><a name="7931" class="Symbol">{</a><a name="7932" href="#7932" class="Bound">n</a><a name="7933" class="Symbol">}</a><a name="7934"> </a><a name="7935" class="Symbol">{</a><a name="7936" href="#7936" class="Bound">xs</a><a name="7938"> </a><a name="7939" class="Symbol">:</a><a name="7940"> </a><a name="7941" href="https://agda.github.io/agda-stdlib/Data.Vec.html#609" class="Datatype" target="_blank">Vec</a><a name="7944"> </a><a name="7945" href="#3009" class="Function">A</a><a name="7946"> </a><a name="7947" href="#7932" class="Bound">n</a><a name="7948" class="Symbol">}</a><a name="7949">
    </a><a name="7954" class="Symbol">→</a><a name="7955"> </a><a name="7956" class="Keyword">let</a><a name="7959"> </a><a name="7960" href="#7960" class="Bound">l</a><a name="7961"> </a><a name="7962" class="Symbol">=</a><a name="7963"> </a><a name="7964" href="https://agda.github.io/agda-stdlib/Data.Product.html#525" class="Field" target="_blank">proj₁</a><a name="7969"> </a><a name="7970" class="Symbol">(</a><a name="7971" href="#7792" class="Function">fromVec</a><a name="7978"> </a><a name="7979" href="#7936" class="Bound">xs</a><a name="7981" class="Symbol">)</a><a name="7982"> </a><a name="7983" class="Keyword">in</a><a name="7985"> </a><a name="7986" href="#7960" class="Bound">l</a><a name="7987"> </a><a name="7988" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="7989"> </a><a name="7990" href="#3397" class="InductiveConstructor">⊤</a><a name="7991"> </a><a name="7992" href="https://agda.github.io/agda-stdlib/Data.Sum.html#433" class="Datatype Operator" target="_blank">⊎</a><a name="7993"> </a><a name="7994" href="#7960" class="Bound">l</a><a name="7995"> </a><a name="7996" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="7997"> </a><a name="7998" href="#3408" class="InductiveConstructor">⊥</a><a name="7999">
  </a><a name="8002" href="#7914" class="Function">fromVec-⊤or⊥</a><a name="8014"> </a><a name="8015" class="Symbol">{</a><a name="8016" class="DottedPattern Symbol">.</a><a name="8017" class="DottedPattern Number">0</a><a name="8018" class="Symbol">}</a><a name="8019">       </a><a name="8026" class="Symbol">{</a><a name="8027" href="https://agda.github.io/agda-stdlib/Data.Vec.html#649" class="InductiveConstructor" target="_blank">[]</a><a name="8029" class="Symbol">}</a><a name="8030">     </a><a name="8035" class="Symbol">=</a><a name="8036"> </a><a name="8037" href="https://agda.github.io/agda-stdlib/Data.Sum.html#489" class="InductiveConstructor" target="_blank">inj₁</a><a name="8041"> </a><a name="8042" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="8046">
  </a><a name="8049" href="#7914" class="Function">fromVec-⊤or⊥</a><a name="8061"> </a><a name="8062" class="Symbol">{</a><a name="8063" class="DottedPattern Symbol">.(</a><a name="8065" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#709" class="DottedPattern InductiveConstructor" target="_blank">suc</a><a name="8068"> </a><a name="8069" class="DottedPattern Symbol">_)</a><a name="8071" class="Symbol">}</a><a name="8072"> </a><a name="8073" class="Symbol">{</a><a name="8074" href="#8074" class="Bound">x</a><a name="8075"> </a><a name="8076" href="https://agda.github.io/agda-stdlib/Data.Vec.html#668" class="InductiveConstructor Operator" target="_blank">∷</a><a name="8077"> </a><a name="8078" href="#8078" class="Bound">xs</a><a name="8080" class="Symbol">}</a><a name="8081"> </a><a name="8082" class="Symbol">=</a><a name="8083"> </a><a name="8084" href="https://agda.github.io/agda-stdlib/Data.Sum.html#514" class="InductiveConstructor" target="_blank">inj₂</a><a name="8088"> </a><a name="8089" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a></pre>

And obviously, we can also turn any k-ordered vector into a regular
vector simply by forgetting about all the order evidence:

<pre class="Agda">  <a name="8248" href="#8248" class="Function">toVec</a><a name="8253"> </a><a name="8254" class="Symbol">:</a><a name="8255"> </a><a name="8256" class="Symbol">∀</a><a name="8257"> </a><a name="8258" class="Symbol">{</a><a name="8259" href="#8259" class="Bound">l</a><a name="8260"> </a><a name="8261" href="#8261" class="Bound">n</a><a name="8262"> </a><a name="8263" href="#8263" class="Bound">k</a><a name="8264" class="Symbol">}</a><a name="8265"> </a><a name="8266" class="Symbol">→</a><a name="8267"> </a><a name="8268" href="#7102" class="Datatype">OVec</a><a name="8272"> </a><a name="8273" href="#8259" class="Bound">l</a><a name="8274"> </a><a name="8275" href="#8261" class="Bound">n</a><a name="8276"> </a><a name="8277" href="#8263" class="Bound">k</a><a name="8278"> </a><a name="8279" class="Symbol">→</a><a name="8280"> </a><a name="8281" href="https://agda.github.io/agda-stdlib/Data.Vec.html#609" class="Datatype" target="_blank">Vec</a><a name="8284"> </a><a name="8285" href="#3009" class="Function">A</a><a name="8286"> </a><a name="8287" href="#8261" class="Bound">n</a><a name="8288">
  </a><a name="8291" href="#8248" class="Function">toVec</a><a name="8296"> </a><a name="8297" href="#7154" class="InductiveConstructor">[]</a><a name="8299"> </a><a name="8300" class="Symbol">=</a><a name="8301"> </a><a name="8302" href="https://agda.github.io/agda-stdlib/Data.Vec.html#649" class="InductiveConstructor" target="_blank">[]</a><a name="8304">
  </a><a name="8307" href="#8248" class="Function">toVec</a><a name="8312"> </a><a name="8313" class="Symbol">(</a><a name="8314" href="#8314" class="Bound">x</a><a name="8315"> </a><a name="8316" href="#7273" class="InductiveConstructor Operator">∷</a><a name="8317"> </a><a name="8318" href="#8318" class="Bound">xs</a><a name="8320" class="Symbol">)</a><a name="8321"> </a><a name="8322" class="Symbol">=</a><a name="8323"> </a><a name="8324" href="#8314" class="Bound">x</a><a name="8325"> </a><a name="8326" href="https://agda.github.io/agda-stdlib/Data.Vec.html#668" class="InductiveConstructor Operator" target="_blank">∷</a><a name="8327"> </a><a name="8328" href="#8248" class="Function">toVec</a><a name="8333"> </a><a name="8334" href="#8318" class="Bound">xs</a><a name="8336">
  </a><a name="8339" href="#8248" class="Function">toVec</a><a name="8344"> </a><a name="8345" class="Symbol">(</a><a name="8346" href="#8346" class="Bound">x</a><a name="8347"> </a><a name="8348" href="#7179" class="InductiveConstructor Operator">∷</a><a name="8349"> </a><a name="8350" href="#8350" class="Bound">xs</a><a name="8352"> </a><a name="8353" href="#7179" class="InductiveConstructor Operator">by</a><a name="8355"> </a><a name="8356" class="Symbol">_)</a><a name="8358"> </a><a name="8359" class="Symbol">=</a><a name="8360"> </a><a name="8361" href="#8346" class="Bound">x</a><a name="8362"> </a><a name="8363" href="https://agda.github.io/agda-stdlib/Data.Vec.html#668" class="InductiveConstructor Operator" target="_blank">∷</a><a name="8364"> </a><a name="8365" href="#8248" class="Function">toVec</a><a name="8370"> </a><a name="8371" href="#8350" class="Bound">xs</a></pre>

Finally! We've developed enough vocabulary to write down what it
really means to perform an insertion:

<pre class="Agda">  <a name="8505" href="#8505" class="Function">insert</a><a name="8511"> </a><a name="8512" class="Symbol">:</a><a name="8513"> </a><a name="8514" class="Symbol">∀</a><a name="8515"> </a><a name="8516" class="Symbol">{</a><a name="8517" href="#8517" class="Bound">l</a><a name="8518"> </a><a name="8519" href="#8519" class="Bound">n</a><a name="8520"> </a><a name="8521" href="#8521" class="Bound">k</a><a name="8522" class="Symbol">}</a><a name="8523"> </a><a name="8524" class="Symbol">(</a><a name="8525" href="#8525" class="Bound">x</a><a name="8526"> </a><a name="8527" class="Symbol">:</a><a name="8528"> </a><a name="8529" href="#3009" class="Function">A</a><a name="8530" class="Symbol">)</a><a name="8531"> </a><a name="8532" class="Symbol">→</a><a name="8533"> </a><a name="8534" href="#7102" class="Datatype">OVec</a><a name="8538"> </a><a name="8539" href="#8517" class="Bound">l</a><a name="8540"> </a><a name="8541" href="#8519" class="Bound">n</a><a name="8542"> </a><a name="8543" href="#8521" class="Bound">k</a><a name="8544"> </a><a name="8545" class="Symbol">→</a><a name="8546"> </a><a name="8547" href="#7102" class="Datatype">OVec</a><a name="8551"> </a><a name="8552" class="Symbol">(</a><a name="8553" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="8554"> </a><a name="8555" href="#8525" class="Bound">x</a><a name="8556"> </a><a name="8557" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="8558"> </a><a name="8559" href="#4474" class="Function Operator">⊓</a><a name="8560"> </a><a name="8561" href="#8517" class="Bound">l</a><a name="8562" class="Symbol">)</a><a name="8563"> </a><a name="8564" class="Symbol">(</a><a name="8565" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#709" class="InductiveConstructor" target="_blank">suc</a><a name="8568"> </a><a name="8569" href="#8519" class="Bound">n</a><a name="8570" class="Symbol">)</a><a name="8571"> </a><a name="8572" href="#8521" class="Bound">k</a><a name="8573">
  </a><a name="8576" href="#8505" class="Function">insert</a><a name="8582"> </a><a name="8583" href="#8583" class="Bound">x</a><a name="8584"> </a><a name="8585" href="#7154" class="InductiveConstructor">[]</a><a name="8587">       </a><a name="8594" class="Symbol">=</a><a name="8595"> </a><a name="8596" href="#8583" class="Bound">x</a><a name="8597"> </a><a name="8598" href="#7179" class="InductiveConstructor Operator">∷</a><a name="8599"> </a><a name="8600" href="#7154" class="InductiveConstructor">[]</a><a name="8602"> </a><a name="8603" href="#7179" class="InductiveConstructor Operator">by</a><a name="8605"> </a><a name="8606" href="#3730" class="InductiveConstructor">≲⊤</a><a name="8608">
  </a><a name="8611" href="#8505" class="Function">insert</a><a name="8617"> </a><a name="8618" href="#8618" class="Bound">x</a><a name="8619"> </a><a name="8620" class="Symbol">(</a><a name="8621" href="#8621" class="Bound">y</a><a name="8622"> </a><a name="8623" href="#7273" class="InductiveConstructor Operator">∷</a><a name="8624"> </a><a name="8625" href="#8625" class="Bound">xs</a><a name="8627" class="Symbol">)</a><a name="8628"> </a><a name="8629" class="Symbol">=</a><a name="8630"> </a><a name="8631" href="#8621" class="Bound">y</a><a name="8632"> </a><a name="8633" href="#7273" class="InductiveConstructor Operator">∷</a><a name="8634"> </a><a name="8635" href="#8505" class="Function">insert</a><a name="8641"> </a><a name="8642" href="#8618" class="Bound">x</a><a name="8643"> </a><a name="8644" href="#8625" class="Bound">xs</a><a name="8646">
  </a><a name="8649" href="#8505" class="Function">insert</a><a name="8655"> </a><a name="8656" href="#8656" class="Bound">x</a><a name="8657"> </a><a name="8658" class="Symbol">(</a><a name="8659" href="#8659" class="Bound">y</a><a name="8660"> </a><a name="8661" href="#7179" class="InductiveConstructor Operator">∷</a><a name="8662"> </a><a name="8663" href="#8663" class="Bound">xs</a><a name="8665"> </a><a name="8666" href="#7179" class="InductiveConstructor Operator">by</a><a name="8668"> </a><a name="8669" href="#8669" class="Bound">p</a><a name="8670" class="Symbol">)</a><a name="8671"> </a><a name="8672" class="Keyword">with</a><a name="8676"> </a><a name="8677" href="#8656" class="Bound">x</a><a name="8678"> </a><a name="8679" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#8876" class="Function Operator" target="_blank">≤?</a><a name="8681"> </a><a name="8682" href="#8659" class="Bound">y</a><a name="8683">
  </a><a name="8686" class="Symbol">...</a><a name="8689"> </a><a name="8690" class="Symbol">|</a><a name="8691"> </a><a name="8692" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#520" class="InductiveConstructor" target="_blank">yes</a><a name="8695"> </a><a name="8696" href="#8696" class="Bound">x≤y</a><a name="8699"> </a><a name="8700" class="Symbol">=</a><a name="8701"> </a><a name="8702" href="#8656" class="Bound">x</a><a name="8703"> </a><a name="8704" href="#7179" class="InductiveConstructor Operator">∷</a><a name="8705"> </a><a name="8706" class="Symbol">(</a><a name="8707" href="#8659" class="Bound">y</a><a name="8708"> </a><a name="8709" href="#7179" class="InductiveConstructor Operator">∷</a><a name="8710"> </a><a name="8711" href="#8663" class="Bound">xs</a><a name="8713"> </a><a name="8714" href="#7179" class="InductiveConstructor Operator">by</a><a name="8716"> </a><a name="8717" href="#8669" class="Bound">p</a><a name="8718" class="Symbol">)</a><a name="8719"> </a><a name="8720" href="#7179" class="InductiveConstructor Operator">by</a><a name="8722"> </a><a name="8723" class="Symbol">(</a><a name="8724" href="#3753" class="InductiveConstructor">≤-lift</a><a name="8730"> </a><a name="8731" href="#8696" class="Bound">x≤y</a><a name="8734" class="Symbol">)</a><a name="8735">
  </a><a name="8738" class="Symbol">...</a><a name="8741"> </a><a name="8742" class="Symbol">|</a><a name="8743"> </a><a name="8744" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#547" class="InductiveConstructor" target="_blank">no</a><a name="8746">  </a><a name="8748" href="#8748" class="Bound">x≰y</a><a name="8751"> </a><a name="8752" class="Symbol">=</a><a name="8753"> </a><a name="8754" href="#8659" class="Bound">y</a><a name="8755"> </a><a name="8756" href="#7179" class="InductiveConstructor Operator">∷</a><a name="8757"> </a><a name="8758" class="Symbol">(</a><a name="8759" href="#8505" class="Function">insert</a><a name="8765"> </a><a name="8766" href="#8656" class="Bound">x</a><a name="8767"> </a><a name="8768" href="#8663" class="Bound">xs</a><a name="8770" class="Symbol">)</a><a name="8771"> </a><a name="8772" href="#7179" class="InductiveConstructor Operator">by</a><a name="8774"> </a><a name="8775" class="Symbol">(</a><a name="8776" href="#4640" class="Function">⊓-conserves-≲</a><a name="8789"> </a><a name="8790" class="Symbol">(</a><a name="8791" href="#4051" class="Function">≰-lift</a><a name="8797"> </a><a name="8798" href="#8748" class="Bound">x≰y</a><a name="8801" class="Symbol">)</a><a name="8802"> </a><a name="8803" href="#8669" class="Bound">p</a><a name="8804" class="Symbol">)</a></pre>

Note that insert takes a vector with *k* unsorted elements, and
returns a vector which has one more element, but still only *k*
unsorted elements! It does this (obviously) by inserting the element
at the right position within the sorted portion of the vector.

It follows fairly easily from the fact that 'insert' inserts an
element in the sorted portion of the vector, that if we take elements
from the unsorted portion, insert it, and repeat this *k* times, we'll
have sorted *k* elements... and therefore the list.

<pre class="Agda">  <a name="9352" href="#9352" class="Function">insertsort</a><a name="9362"> </a><a name="9363" class="Symbol">:</a><a name="9364"> </a><a name="9365" class="Symbol">∀</a><a name="9366"> </a><a name="9367" class="Symbol">{</a><a name="9368" href="#9368" class="Bound">l</a><a name="9369"> </a><a name="9370" href="#9370" class="Bound">n</a><a name="9371"> </a><a name="9372" href="#9372" class="Bound">k</a><a name="9373" class="Symbol">}</a><a name="9374"> </a><a name="9375" class="Symbol">→</a><a name="9376"> </a><a name="9377" href="#7102" class="Datatype">OVec</a><a name="9381"> </a><a name="9382" href="#9368" class="Bound">l</a><a name="9383"> </a><a name="9384" href="#9370" class="Bound">n</a><a name="9385"> </a><a name="9386" href="#9372" class="Bound">k</a><a name="9387"> </a><a name="9388" class="Symbol">→</a><a name="9389"> </a><a name="9390" href="https://agda.github.io/agda-stdlib/Data.Product.html#823" class="Function" target="_blank">∃</a><a name="9391"> </a><a name="9392" class="Symbol">(λ</a><a name="9394"> </a><a name="9395" href="#9395" class="Bound">l</a><a name="9396"> </a><a name="9397" class="Symbol">→</a><a name="9398"> </a><a name="9399" href="#7102" class="Datatype">OVec</a><a name="9403"> </a><a name="9404" href="#9395" class="Bound">l</a><a name="9405"> </a><a name="9406" href="#9370" class="Bound">n</a><a name="9407"> </a><a name="9408" class="Number">0</a><a name="9409" class="Symbol">)</a><a name="9410">
  </a><a name="9413" href="#9352" class="Function">insertsort</a><a name="9423"> </a><a name="9424" href="#7154" class="InductiveConstructor">[]</a><a name="9426">            </a><a name="9438" class="Symbol">=</a><a name="9439"> </a><a name="9440" href="#3397" class="InductiveConstructor">⊤</a><a name="9441"> </a><a name="9442" href="https://agda.github.io/agda-stdlib/Data.Product.html#509" class="InductiveConstructor Operator" target="_blank">,</a><a name="9443"> </a><a name="9444" href="#7154" class="InductiveConstructor">[]</a><a name="9446">
  </a><a name="9449" href="#9352" class="Function">insertsort</a><a name="9459"> </a><a name="9460" class="Symbol">(</a><a name="9461" href="#9461" class="Bound">x</a><a name="9462"> </a><a name="9463" href="#7273" class="InductiveConstructor Operator">∷</a><a name="9464"> </a><a name="9465" href="#9465" class="Bound">xs</a><a name="9467" class="Symbol">)</a><a name="9468">      </a><a name="9474" class="Symbol">=</a><a name="9475"> </a><a name="9476" href="#9352" class="Function">insertsort</a><a name="9486"> </a><a name="9487" class="Symbol">(</a><a name="9488" href="#8505" class="Function">insert</a><a name="9494"> </a><a name="9495" href="#9461" class="Bound">x</a><a name="9496"> </a><a name="9497" href="#9465" class="Bound">xs</a><a name="9499" class="Symbol">)</a><a name="9500">
  </a><a name="9503" href="#9352" class="Function">insertsort</a><a name="9513"> </a><a name="9514" class="Symbol">(</a><a name="9515" href="#9515" class="Bound">x</a><a name="9516"> </a><a name="9517" href="#7179" class="InductiveConstructor Operator">∷</a><a name="9518"> </a><a name="9519" href="#9519" class="Bound">xs</a><a name="9521"> </a><a name="9522" href="#7179" class="InductiveConstructor Operator">by</a><a name="9524"> </a><a name="9525" href="#9525" class="Bound">p</a><a name="9526" class="Symbol">)</a><a name="9527"> </a><a name="9528" class="Symbol">=</a><a name="9529"> </a><a name="9530" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="9531"> </a><a name="9532" href="#9515" class="Bound">x</a><a name="9533"> </a><a name="9534" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="9535"> </a><a name="9536" href="https://agda.github.io/agda-stdlib/Data.Product.html#509" class="InductiveConstructor Operator" target="_blank">,</a><a name="9537"> </a><a name="9538" href="#9515" class="Bound">x</a><a name="9539"> </a><a name="9540" href="#7179" class="InductiveConstructor Operator">∷</a><a name="9541"> </a><a name="9542" href="#9519" class="Bound">xs</a><a name="9544"> </a><a name="9545" href="#7179" class="InductiveConstructor Operator">by</a><a name="9547"> </a><a name="9548" href="#9525" class="Bound">p</a></pre>

There is one thing we haven't verified so far---and I've hinted at this
possibility above. It is fairly simple to implement an insertion sort
algorithm with the *same* type which simply takes the first element
and repeats it *n* times.
So our types aren't perfect. However, such constraints are a little
harder to encode in data types. One approach would be to construct a
sorting permutation instead of working with an input and output list.
What we could do to make this code work is to give a separate
proof---though this would go against my correctness by construction
sensibilities---stating that if an element is in the input list it is
in the output list. However, as I mostly wrote this blog post as a
test case for my Jekyll/Agda integration... I'm not going to put in
the effort to do either.

One amusing anecdote about this code is that while I was writing it, I
thought I was implementing bubble sort---so much for safety. However,
if you have a look at the invariants that both algorithms maintain,
they are really quite similar. In fact, we can easily implement bubble
sort using our `OVec` data type. The underlying algorithm is
incredibly similar to insert. However, as opposed to inserting the
first element in the correct position, `bubble` has trouble making up
its mind and drops whatever it's hold when it sees a bigger element!

<pre class="Agda">  <a name="10929" href="#10929" class="Function">bubble</a><a name="10935"> </a><a name="10936" class="Symbol">:</a><a name="10937"> </a><a name="10938" class="Symbol">∀</a><a name="10939"> </a><a name="10940" class="Symbol">{</a><a name="10941" href="#10941" class="Bound">l</a><a name="10942"> </a><a name="10943" href="#10943" class="Bound">n</a><a name="10944"> </a><a name="10945" href="#10945" class="Bound">k</a><a name="10946" class="Symbol">}</a><a name="10947"> </a><a name="10948" class="Symbol">(</a><a name="10949" href="#10949" class="Bound">x</a><a name="10950"> </a><a name="10951" class="Symbol">:</a><a name="10952"> </a><a name="10953" href="#3009" class="Function">A</a><a name="10954" class="Symbol">)</a><a name="10955"> </a><a name="10956" class="Symbol">→</a><a name="10957"> </a><a name="10958" href="#7102" class="Datatype">OVec</a><a name="10962"> </a><a name="10963" href="#10941" class="Bound">l</a><a name="10964"> </a><a name="10965" href="#10943" class="Bound">n</a><a name="10966"> </a><a name="10967" href="#10945" class="Bound">k</a><a name="10968"> </a><a name="10969" class="Symbol">→</a><a name="10970"> </a><a name="10971" href="#7102" class="Datatype">OVec</a><a name="10975"> </a><a name="10976" class="Symbol">(</a><a name="10977" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="10978"> </a><a name="10979" href="#10949" class="Bound">x</a><a name="10980"> </a><a name="10981" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="10982"> </a><a name="10983" href="#4474" class="Function Operator">⊓</a><a name="10984"> </a><a name="10985" href="#10941" class="Bound">l</a><a name="10986" class="Symbol">)</a><a name="10987"> </a><a name="10988" class="Symbol">(</a><a name="10989" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#709" class="InductiveConstructor" target="_blank">suc</a><a name="10992"> </a><a name="10993" href="#10943" class="Bound">n</a><a name="10994" class="Symbol">)</a><a name="10995"> </a><a name="10996" href="#10945" class="Bound">k</a><a name="10997">
  </a><a name="11000" href="#10929" class="Function">bubble</a><a name="11006"> </a><a name="11007" href="#11007" class="Bound">x</a><a name="11008"> </a><a name="11009" href="#7154" class="InductiveConstructor">[]</a><a name="11011">            </a><a name="11023" class="Symbol">=</a><a name="11024"> </a><a name="11025" href="#11007" class="Bound">x</a><a name="11026"> </a><a name="11027" href="#7179" class="InductiveConstructor Operator">∷</a><a name="11028"> </a><a name="11029" href="#7154" class="InductiveConstructor">[]</a><a name="11031"> </a><a name="11032" href="#7179" class="InductiveConstructor Operator">by</a><a name="11034"> </a><a name="11035" href="#3730" class="InductiveConstructor">≲⊤</a><a name="11037">
  </a><a name="11040" href="#10929" class="Function">bubble</a><a name="11046"> </a><a name="11047" href="#11047" class="Bound">x</a><a name="11048"> </a><a name="11049" class="Symbol">(</a><a name="11050" href="#11050" class="Bound">y</a><a name="11051"> </a><a name="11052" href="#7273" class="InductiveConstructor Operator">∷</a><a name="11053"> </a><a name="11054" href="#11054" class="Bound">xs</a><a name="11056" class="Symbol">)</a><a name="11057">      </a><a name="11063" class="Keyword">with</a><a name="11067"> </a><a name="11068" href="#11047" class="Bound">x</a><a name="11069"> </a><a name="11070" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#8876" class="Function Operator" target="_blank">≤?</a><a name="11072"> </a><a name="11073" href="#11050" class="Bound">y</a><a name="11074">
  </a><a name="11077" class="Symbol">...</a><a name="11080"> </a><a name="11081" class="Symbol">|</a><a name="11082"> </a><a name="11083" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#547" class="InductiveConstructor" target="_blank">no</a><a name="11085">  </a><a name="11087" href="#11087" class="Bound">x≰y</a><a name="11090"> </a><a name="11091" class="Symbol">=</a><a name="11092"> </a><a name="11093" href="#11050" class="Bound">y</a><a name="11094"> </a><a name="11095" href="#7273" class="InductiveConstructor Operator">∷</a><a name="11096"> </a><a name="11097" href="#10929" class="Function">bubble</a><a name="11103"> </a><a name="11104" href="#11047" class="Bound">x</a><a name="11105"> </a><a name="11106" href="#11054" class="Bound">xs</a><a name="11108">
  </a><a name="11111" class="Symbol">...</a><a name="11114"> </a><a name="11115" class="Symbol">|</a><a name="11116"> </a><a name="11117" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#520" class="InductiveConstructor" target="_blank">yes</a><a name="11120"> </a><a name="11121" href="#11121" class="Bound">x≤y</a><a name="11124"> </a><a name="11125" class="Symbol">=</a><a name="11126"> </a><a name="11127" href="#11047" class="Bound">x</a><a name="11128"> </a><a name="11129" href="#7273" class="InductiveConstructor Operator">∷</a><a name="11130"> </a><a name="11131" href="#10929" class="Function">bubble</a><a name="11137"> </a><a name="11138" href="#11050" class="Bound">y</a><a name="11139"> </a><a name="11140" href="#11054" class="Bound">xs</a><a name="11142">
  </a><a name="11145" href="#10929" class="Function">bubble</a><a name="11151"> </a><a name="11152" href="#11152" class="Bound">x</a><a name="11153"> </a><a name="11154" class="Symbol">(</a><a name="11155" href="#11155" class="Bound">y</a><a name="11156"> </a><a name="11157" href="#7179" class="InductiveConstructor Operator">∷</a><a name="11158"> </a><a name="11159" href="#11159" class="Bound">xs</a><a name="11161"> </a><a name="11162" href="#7179" class="InductiveConstructor Operator">by</a><a name="11164"> </a><a name="11165" href="#11165" class="Bound">p</a><a name="11166" class="Symbol">)</a><a name="11167"> </a><a name="11168" class="Keyword">with</a><a name="11172"> </a><a name="11173" href="#11152" class="Bound">x</a><a name="11174"> </a><a name="11175" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#8876" class="Function Operator" target="_blank">≤?</a><a name="11177"> </a><a name="11178" href="#11155" class="Bound">y</a><a name="11179">
  </a><a name="11182" class="Symbol">...</a><a name="11185"> </a><a name="11186" class="Symbol">|</a><a name="11187"> </a><a name="11188" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#547" class="InductiveConstructor" target="_blank">no</a><a name="11190">  </a><a name="11192" href="#11192" class="Bound">x≰y</a><a name="11195"> </a><a name="11196" class="Symbol">=</a><a name="11197"> </a><a name="11198" href="#11155" class="Bound">y</a><a name="11199"> </a><a name="11200" href="#7179" class="InductiveConstructor Operator">∷</a><a name="11201"> </a><a name="11202" href="#10929" class="Function">bubble</a><a name="11208"> </a><a name="11209" href="#11152" class="Bound">x</a><a name="11210"> </a><a name="11211" href="#11159" class="Bound">xs</a><a name="11213"> </a><a name="11214" href="#7179" class="InductiveConstructor Operator">by</a><a name="11216"> </a><a name="11217" href="#4640" class="Function">⊓-conserves-≲</a><a name="11230"> </a><a name="11231" class="Symbol">(</a><a name="11232" href="#4051" class="Function">≰-lift</a><a name="11238"> </a><a name="11239" href="#11192" class="Bound">x≰y</a><a name="11242" class="Symbol">)</a><a name="11243"> </a><a name="11244" href="#11165" class="Bound">p</a><a name="11245">
  </a><a name="11248" class="Symbol">...</a><a name="11251"> </a><a name="11252" class="Symbol">|</a><a name="11253"> </a><a name="11254" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#520" class="InductiveConstructor" target="_blank">yes</a><a name="11257"> </a><a name="11258" href="#11258" class="Bound">x≤y</a><a name="11261"> </a><a name="11262" class="Symbol">=</a><a name="11263"> </a><a name="11264" href="#11152" class="Bound">x</a><a name="11265"> </a><a name="11266" href="#7179" class="InductiveConstructor Operator">∷</a><a name="11267"> </a><a name="11268" href="#10929" class="Function">bubble</a><a name="11274"> </a><a name="11275" href="#11155" class="Bound">y</a><a name="11276"> </a><a name="11277" href="#11159" class="Bound">xs</a><a name="11279"> </a><a name="11280" href="#7179" class="InductiveConstructor Operator">by</a><a name="11282"> </a><a name="11283" href="#4640" class="Function">⊓-conserves-≲</a><a name="11296"> </a><a name="11297" href="#11333" class="Function">x≲y</a><a name="11300"> </a><a name="11301" class="Symbol">(</a><a name="11302" href="#11645" class="Function">≲-trans</a><a name="11309"> </a><a name="11310" href="#11333" class="Function">x≲y</a><a name="11313"> </a><a name="11314" href="#11165" class="Bound">p</a><a name="11315" class="Symbol">)</a><a name="11316">
    </a><a name="11321" class="Keyword">where</a><a name="11326">
      </a><a name="11333" href="#11333" class="Function">x≲y</a><a name="11336"> </a><a name="11337" class="Symbol">=</a><a name="11338"> </a><a name="11339" href="#3753" class="InductiveConstructor">≤-lift</a><a name="11345"> </a><a name="11346" href="#11258" class="Bound">x≤y</a></pre>

All that we need is to show that our home-brewed ≲-relation is
transitive. This follows immediately from the underlying
order. But this sort of lemma should really be provided by the
standard library anyway---and perhaps it is, and I've simply failed to
find it!

<pre class="Agda">      <a name="11645" href="#11645" class="Function">≲-trans</a><a name="11652"> </a><a name="11653" class="Symbol">:</a><a name="11654"> </a><a name="11655" class="Symbol">∀</a><a name="11656"> </a><a name="11657" class="Symbol">{</a><a name="11658" href="#11658" class="Bound">x</a><a name="11659"> </a><a name="11660" href="#11660" class="Bound">y</a><a name="11661"> </a><a name="11662" href="#11662" class="Bound">z</a><a name="11663" class="Symbol">}</a><a name="11664"> </a><a name="11665" class="Symbol">→</a><a name="11666"> </a><a name="11667" href="#11658" class="Bound">x</a><a name="11668"> </a><a name="11669" href="#3675" class="Datatype Operator">≲</a><a name="11670"> </a><a name="11671" href="#11660" class="Bound">y</a><a name="11672"> </a><a name="11673" class="Symbol">→</a><a name="11674"> </a><a name="11675" href="#11660" class="Bound">y</a><a name="11676"> </a><a name="11677" href="#3675" class="Datatype Operator">≲</a><a name="11678"> </a><a name="11679" href="#11662" class="Bound">z</a><a name="11680"> </a><a name="11681" class="Symbol">→</a><a name="11682"> </a><a name="11683" href="#11658" class="Bound">x</a><a name="11684"> </a><a name="11685" href="#3675" class="Datatype Operator">≲</a><a name="11686"> </a><a name="11687" href="#11662" class="Bound">z</a><a name="11688">
      </a><a name="11695" href="#11645" class="Function">≲-trans</a><a name="11702">  </a><a name="11704" href="#3707" class="InductiveConstructor">⊥≲</a><a name="11706">         </a><a name="11715" class="Symbol">_</a><a name="11716">         </a><a name="11725" class="Symbol">=</a><a name="11726"> </a><a name="11727" href="#3707" class="InductiveConstructor">⊥≲</a><a name="11729">
      </a><a name="11736" href="#11645" class="Function">≲-trans</a><a name="11743">  </a><a name="11745" class="Symbol">_</a><a name="11746">          </a><a name="11756" href="#3730" class="InductiveConstructor">≲⊤</a><a name="11758">        </a><a name="11766" class="Symbol">=</a><a name="11767"> </a><a name="11768" href="#3730" class="InductiveConstructor">≲⊤</a><a name="11770">
      </a><a name="11777" href="#11645" class="Function">≲-trans</a><a name="11784"> </a><a name="11785" class="Symbol">(</a><a name="11786" href="#3753" class="InductiveConstructor">≤-lift</a><a name="11792"> </a><a name="11793" href="#11793" class="Bound">p</a><a name="11794" class="Symbol">)</a><a name="11795"> </a><a name="11796" class="Symbol">(</a><a name="11797" href="#3753" class="InductiveConstructor">≤-lift</a><a name="11803"> </a><a name="11804" href="#11804" class="Bound">q</a><a name="11805" class="Symbol">)</a><a name="11806"> </a><a name="11807" class="Symbol">=</a><a name="11808"> </a><a name="11809" href="#3753" class="InductiveConstructor">≤-lift</a><a name="11815"> </a><a name="11816" class="Symbol">(</a><a name="11817" href="https://agda.github.io/agda-stdlib/Relation.Binary.html#1190" class="Function" target="_blank">≤-trans</a><a name="11824"> </a><a name="11825" href="#11793" class="Bound">p</a><a name="11826"> </a><a name="11827" href="#11804" class="Bound">q</a><a name="11828" class="Symbol">)</a></pre>

At any rate, once we have our "bubble" function, the implementation of
the sorting algorithm is trivial---and exactly identical to the
definition of insertion sort!

<pre class="Agda">  <a name="12023" href="#12023" class="Function">bubblesort</a><a name="12033"> </a><a name="12034" class="Symbol">:</a><a name="12035"> </a><a name="12036" class="Symbol">∀</a><a name="12037"> </a><a name="12038" class="Symbol">{</a><a name="12039" href="#12039" class="Bound">l</a><a name="12040"> </a><a name="12041" href="#12041" class="Bound">n</a><a name="12042"> </a><a name="12043" href="#12043" class="Bound">k</a><a name="12044" class="Symbol">}</a><a name="12045"> </a><a name="12046" class="Symbol">→</a><a name="12047"> </a><a name="12048" href="#7102" class="Datatype">OVec</a><a name="12052"> </a><a name="12053" href="#12039" class="Bound">l</a><a name="12054"> </a><a name="12055" href="#12041" class="Bound">n</a><a name="12056"> </a><a name="12057" href="#12043" class="Bound">k</a><a name="12058"> </a><a name="12059" class="Symbol">→</a><a name="12060"> </a><a name="12061" href="https://agda.github.io/agda-stdlib/Data.Product.html#823" class="Function" target="_blank">∃</a><a name="12062"> </a><a name="12063" class="Symbol">(λ</a><a name="12065"> </a><a name="12066" href="#12066" class="Bound">l</a><a name="12067"> </a><a name="12068" class="Symbol">→</a><a name="12069"> </a><a name="12070" href="#7102" class="Datatype">OVec</a><a name="12074"> </a><a name="12075" href="#12066" class="Bound">l</a><a name="12076"> </a><a name="12077" href="#12041" class="Bound">n</a><a name="12078"> </a><a name="12079" class="Number">0</a><a name="12080" class="Symbol">)</a><a name="12081">
  </a><a name="12084" href="#12023" class="Function">bubblesort</a><a name="12094"> </a><a name="12095" href="#7154" class="InductiveConstructor">[]</a><a name="12097">            </a><a name="12109" class="Symbol">=</a><a name="12110"> </a><a name="12111" href="#3397" class="InductiveConstructor">⊤</a><a name="12112"> </a><a name="12113" href="https://agda.github.io/agda-stdlib/Data.Product.html#509" class="InductiveConstructor Operator" target="_blank">,</a><a name="12114"> </a><a name="12115" href="#7154" class="InductiveConstructor">[]</a><a name="12117">
  </a><a name="12120" href="#12023" class="Function">bubblesort</a><a name="12130"> </a><a name="12131" class="Symbol">(</a><a name="12132" href="#12132" class="Bound">x</a><a name="12133"> </a><a name="12134" href="#7273" class="InductiveConstructor Operator">∷</a><a name="12135"> </a><a name="12136" href="#12136" class="Bound">xs</a><a name="12138" class="Symbol">)</a><a name="12139">      </a><a name="12145" class="Symbol">=</a><a name="12146"> </a><a name="12147" href="#12023" class="Function">bubblesort</a><a name="12157"> </a><a name="12158" class="Symbol">(</a><a name="12159" href="#10929" class="Function">bubble</a><a name="12165"> </a><a name="12166" href="#12132" class="Bound">x</a><a name="12167"> </a><a name="12168" href="#12136" class="Bound">xs</a><a name="12170" class="Symbol">)</a><a name="12171">
  </a><a name="12174" href="#12023" class="Function">bubblesort</a><a name="12184"> </a><a name="12185" class="Symbol">(</a><a name="12186" href="#12186" class="Bound">x</a><a name="12187"> </a><a name="12188" href="#7179" class="InductiveConstructor Operator">∷</a><a name="12189"> </a><a name="12190" href="#12190" class="Bound">xs</a><a name="12192"> </a><a name="12193" href="#7179" class="InductiveConstructor Operator">by</a><a name="12195"> </a><a name="12196" href="#12196" class="Bound">p</a><a name="12197" class="Symbol">)</a><a name="12198"> </a><a name="12199" class="Symbol">=</a><a name="12200"> </a><a name="12201" href="#3419" class="InductiveConstructor Operator">⟦</a><a name="12202"> </a><a name="12203" href="#12186" class="Bound">x</a><a name="12204"> </a><a name="12205" href="#3419" class="InductiveConstructor Operator">⟧</a><a name="12206"> </a><a name="12207" href="https://agda.github.io/agda-stdlib/Data.Product.html#509" class="InductiveConstructor Operator" target="_blank">,</a><a name="12208"> </a><a name="12209" href="#12186" class="Bound">x</a><a name="12210"> </a><a name="12211" href="#7179" class="InductiveConstructor Operator">∷</a><a name="12212"> </a><a name="12213" href="#12190" class="Bound">xs</a><a name="12215"> </a><a name="12216" href="#7179" class="InductiveConstructor Operator">by</a><a name="12218"> </a><a name="12219" href="#12196" class="Bound">p</a></pre>