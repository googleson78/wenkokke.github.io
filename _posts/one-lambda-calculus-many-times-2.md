---
title         : One λ-calculus, many times... (2)
date          : 2016-03-26 12:00:00
categories    : [compsci]
tags          : [agda]
hide_implicit : true
---

This post is a continuation of *[One λ-calculus, many times...](
{% post_url 2016-03-20-one-lambda-calculus-many-times %})*, in which I
explored the use natural deduction and sequent calculus systems as
type systems for the simply-typed lambda calculus.[^minproplog] In
this post, I will have a look at a variant of one of these systems
which has explicit structural rules: Gentzen's LJ.

<div class="hidden">
<pre class="Agda"><a name="589" class="Keyword">import</a><a name="595"> </a><a name="596" href="/2016/one-lambda-calculus-many-times/#1" class="Module">2016-03-20-one-lambda-calculus-many-times</a><a name="637"> </a><a name="638" class="Symbol">as</a><a name="640"> </a><a name="641" class="Module">Part1</a><a name="646">
</a><a name="647" class="Keyword">module</a><a name="653"> </a><a name="654" href="/2016/one-lambda-calculus-many-times-2/#1" class="Module">2016-03-26-one-lambda-calculus-many-times-2</a><a name="697"> </a><a name="698" class="Keyword">where</a></pre>
</div>

The structure of this post will be very similar to that of part
one---which means that we will start out by having a look at the
syntax of LJ:

<pre class="Agda"><a name="880" class="Keyword">module</a><a name="886"> </a><a name="887" href="/2016/one-lambda-calculus-many-times-2/#887" class="Module">Syntax</a><a name="893"> </a><a name="894" class="Symbol">(</a><a name="895" href="/2016/one-lambda-calculus-many-times-2/#895" class="Bound">Atom</a><a name="899"> </a><a name="900" class="Symbol">:</a><a name="901"> </a><a name="902" class="PrimitiveType">Set</a><a name="905" class="Symbol">)</a><a name="906"> </a><a name="907" class="Keyword">where</a></pre>

We will reuse our notions of types and sequents from the previous post:

<div class="hidden">
<pre class="Agda">  <a name="1034" class="Keyword">open</a><a name="1038"> </a><a name="1039" href="/2016/one-lambda-calculus-many-times/#1142" class="Module">Part1.</a><a name="1045" href="/2016/one-lambda-calculus-many-times/#1489" class="Module">Syntax</a><a name="1051"> </a><a name="1052" href="/2016/one-lambda-calculus-many-times-2/#895" class="Bound">Atom</a><a name="1056"> </a><a name="1057" class="Keyword">using</a><a name="1062"> </a><a name="1063" class="Symbol">(</a><a name="1064">Type</a><a name="1068" class="Symbol">;</a><a name="1069"> El</a><a name="1072" class="Symbol">;</a><a name="1073"> _⇒_</a><a name="1077" class="Symbol">;</a><a name="1078"> Sequent</a><a name="1086" class="Symbol">;</a><a name="1087"> _⊢_</a><a name="1091" class="Symbol">)</a><a name="1092">
  </a><a name="1095" class="Keyword">open</a><a name="1099"> </a><a name="1100" class="Keyword">import</a><a name="1106"> </a><a name="1107" href="https://agda.github.io/agda-stdlib/Data.Nat.html#1" class="Module" target="_blank">Data.Nat</a><a name="1115">             </a><a name="1128" class="Keyword">using</a><a name="1133"> </a><a name="1134" class="Symbol">(</a><a name="1135">ℕ</a><a name="1136" class="Symbol">;</a><a name="1137"> suc</a><a name="1141" class="Symbol">;</a><a name="1142"> zero</a><a name="1147" class="Symbol">)</a><a name="1148">
  </a><a name="1151" class="Keyword">open</a><a name="1155"> </a><a name="1156" class="Keyword">import</a><a name="1162"> </a><a name="1163" href="https://agda.github.io/agda-stdlib/Data.Fin.html#1" class="Module" target="_blank">Data.Fin</a><a name="1171">             </a><a name="1184" class="Keyword">using</a><a name="1189"> </a><a name="1190" class="Symbol">(</a><a name="1191">Fin</a><a name="1194" class="Symbol">;</a><a name="1195"> suc</a><a name="1199" class="Symbol">;</a><a name="1200"> zero</a><a name="1205" class="Symbol">)</a><a name="1206">
  </a><a name="1209" class="Keyword">open</a><a name="1213"> </a><a name="1214" class="Keyword">import</a><a name="1220"> </a><a name="1221" href="https://agda.github.io/agda-stdlib/Data.List.html#1" class="Module" target="_blank">Data.List</a><a name="1230">            </a><a name="1242" class="Keyword">using</a><a name="1247"> </a><a name="1248" class="Symbol">(</a><a name="1249">List</a><a name="1253" class="Symbol">;</a><a name="1254"> _∷_</a><a name="1258" class="Symbol">;</a><a name="1259"> []</a><a name="1262" class="Symbol">;</a><a name="1263"> _++_</a><a name="1268" class="Symbol">)</a><a name="1269">
  </a><a name="1272" class="Keyword">open</a><a name="1276"> </a><a name="1277" class="Keyword">import</a><a name="1283"> </a><a name="1284" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1" class="Module" target="_blank">Data.List.Any</a><a name="1297">        </a><a name="1305" class="Keyword">using</a><a name="1310"> </a><a name="1311" class="Symbol">(</a><a name="1312" class="Keyword">module</a><a name="1318"> Membership</a><a name="1329" class="Symbol">;</a><a name="1330"> here</a><a name="1335" class="Symbol">;</a><a name="1336"> there</a><a name="1342" class="Symbol">)</a><a name="1343">
  </a><a name="1346" class="Keyword">open</a><a name="1350"> </a><a name="1351" class="Keyword">import</a><a name="1357"> </a><a name="1358" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#1" class="Module" target="_blank">Function.Equivalence</a><a name="1378"> </a><a name="1379" class="Keyword">using</a><a name="1384"> </a><a name="1385" class="Symbol">(</a><a name="1386">_⇔_</a><a name="1389" class="Symbol">;</a><a name="1390"> id</a><a name="1393" class="Symbol">;</a><a name="1394"> map</a><a name="1398" class="Symbol">;</a><a name="1399"> equivalence</a><a name="1411" class="Symbol">)</a><a name="1412">
  </a><a name="1415" class="Keyword">open</a><a name="1419"> </a><a name="1420" class="Keyword">import</a><a name="1426"> </a><a name="1427" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality</a><a name="1464">
  </a><a name="1467" class="Keyword">open</a><a name="1471"> </a><a name="1472" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2298" class="Module" target="_blank">Membership</a><a name="1482"> </a><a name="1483" class="Symbol">(</a><a name="1484" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1526" class="Function" target="_blank">setoid</a><a name="1490"> </a><a name="1491" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="1495" class="Symbol">)</a><a name="1496">    </a><a name="1500" class="Keyword">using</a><a name="1505"> </a><a name="1506" class="Symbol">(</a><a name="1507">_∈_</a><a name="1510" class="Symbol">;</a><a name="1511"> _⊆_</a><a name="1515" class="Symbol">)</a></pre>
</div>
<pre class="Agda Spec">  </a><a name="2567" class="Keyword">data</a><a name="2571"> </a><a name="2572" href="/2016/one-lambda-calculus-many-times/#1142" class="Module">Type</a><a name="2576"> </a><a name="2577" class="Symbol">:</a><a name="2578"> </a><a name="2579" class="PrimitiveType">Set</a><a name="2582"> </a><a name="2583" class="Keyword">where</a><a name="2588">
    </a><a name="2593" href="/2016/one-lambda-calculus-many-times/#2593" class="InductiveConstructor">El</a><a name="2595">  </a><a name="2597" class="Symbol">:</a><a name="2598"> </a><a name="2599" href="/2016/one-lambda-calculus-many-times/#1497" class="Bound">Atom</a><a name="2603"> </a><a name="2604" class="Symbol">→</a><a name="2605"> </a><a name="2606" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="2610">
    </a><a name="2615" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">_⇒_</a><a name="2618"> </a><a name="2619" class="Symbol">:</a><a name="2620"> </a><a name="2621" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="2625"> </a><a name="2626" class="Symbol">→</a><a name="2627"> </a><a name="2628" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="2632"> </a><a name="2633" class="Symbol">→</a><a name="2634"> </a><a name="2635" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a>

  </a><a name="3873" class="Keyword">data</a><a name="3877"> </a><a name="3878" href="/2016/one-lambda-calculus-many-times/#1142" class="Module">Sequent</a><a name="3885"> </a><a name="3886" class="Symbol">:</a><a name="3887"> </a><a name="3888" class="PrimitiveType">Set</a><a name="3891"> </a><a name="3892" class="Keyword">where</a><a name="3897">
    </a><a name="3902" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">_⊢_</a><a name="3905"> </a><a name="3906" class="Symbol">:</a><a name="3907"> </a><a name="3908" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#669" class="Datatype" target="_blank">List</a><a name="3912"> </a><a name="3913" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="3917"> </a><a name="3918" class="Symbol">→</a><a name="3919"> </a><a name="3920" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="3924"> </a><a name="3925" class="Symbol">→</a><a name="3926"> </a><a name="3927" href="/2016/one-lambda-calculus-many-times/#3878" class="Datatype">Sequent</a></pre>



$$
    \begin{array}{c}
    \frac{}{A \vdash A}{\small ax}
    \quad
    \frac{\Gamma \vdash A \quad A , \Delta \vdash B}{\Gamma, \Delta \vdash B}{\small cut}
    \quad
    \frac{\Gamma \vdash A \quad B , \Delta \vdash C}{A \Rightarrow  B , \Gamma, \Delta \vdash C}{\small{\Rightarrow}\!l}
    \quad
    \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!r}
    \\
    \\
    \frac{\Gamma \vdash B}{A , \Gamma \vdash B}{\small w}
    \quad
    \frac{A , A , \Gamma \vdash B}{A , \Gamma \vdash B}{\small c}
    \quad
    \frac{\Gamma , A , B , \Delta \vdash B}{\Gamma , B , A , \Delta \vdash B}{\small p}
    \end{array}
$$


<pre class="Agda">  <a name="4760" class="Keyword">infix</a><a name="4765"> </a><a name="4766" class="Number">3</a><a name="4767"> LJ_

  </a><a name="4775" class="Keyword">data</a><a name="4779"> </a><a name="4780" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ_</a><a name="4783"> </a><a name="4784" class="Symbol">:</a><a name="4785"> </a><a name="4786" href="/2016/one-lambda-calculus-many-times/#3878" class="Datatype">Sequent</a><a name="4793"> </a><a name="4794" class="Symbol">→</a><a name="4795"> </a><a name="4796" class="PrimitiveType">Set</a><a name="4799"> </a><a name="4800" class="Keyword">where</a><a name="4805">
    </a><a name="4810" href="/2016/one-lambda-calculus-many-times-2/#4810" class="InductiveConstructor">ax</a><a name="4812">  </a><a name="4814" class="Symbol">:</a><a name="4815"> </a><a name="4832" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="4834"> </a><a name="4835" href="/2016/one-lambda-calculus-many-times-2/#4819" class="Bound">A</a><a name="4836"> </a><a name="4837" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="4838"> </a><a name="4839" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#706" class="InductiveConstructor" target="_blank">[]</a><a name="4841"> </a><a name="4842" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="4843"> </a><a name="4844" href="/2016/one-lambda-calculus-many-times-2/#4819" class="Bound">A</a><a name="4845">
    </a><a name="4850" href="/2016/one-lambda-calculus-many-times-2/#4850" class="InductiveConstructor">cut</a><a name="4853"> </a><a name="4854" class="Symbol">:</a><a name="4855"> </a><a name="4872" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="4874"> </a><a name="4875" href="/2016/one-lambda-calculus-many-times-2/#4865" class="Bound">Γ</a><a name="4876"> </a><a name="4877" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="4878"> </a><a name="4879" href="/2016/one-lambda-calculus-many-times-2/#4859" class="Bound">A</a><a name="4880"> </a><a name="4881" class="Symbol">→</a><a name="4882"> </a><a name="4883" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="4885"> </a><a name="4886" href="/2016/one-lambda-calculus-many-times-2/#4859" class="Bound">A</a><a name="4887"> </a><a name="4888" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="4889"> </a><a name="4890" href="/2016/one-lambda-calculus-many-times-2/#4867" class="Bound">Δ</a><a name="4891"> </a><a name="4892" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="4893"> </a><a name="4894" href="/2016/one-lambda-calculus-many-times-2/#4861" class="Bound">B</a><a name="4895"> </a><a name="4896" class="Symbol">→</a><a name="4897"> </a><a name="4898" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="4900"> </a><a name="4901" href="/2016/one-lambda-calculus-many-times-2/#4865" class="Bound">Γ</a><a name="4902"> </a><a name="4903" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#1098" class="Function Operator" target="_blank">++</a><a name="4905"> </a><a name="4906" href="/2016/one-lambda-calculus-many-times-2/#4867" class="Bound">Δ</a><a name="4907"> </a><a name="4908" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="4909"> </a><a name="4910" href="/2016/one-lambda-calculus-many-times-2/#4861" class="Bound">B</a><a name="4911">
    </a><a name="4916" href="/2016/one-lambda-calculus-many-times-2/#4916" class="InductiveConstructor">⇒l</a><a name="4918">  </a><a name="4920" class="Symbol">:</a><a name="4921"> </a><a name="4938" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="4940"> </a><a name="4941" href="/2016/one-lambda-calculus-many-times-2/#4931" class="Bound">Γ</a><a name="4942"> </a><a name="4943" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="4944"> </a><a name="4945" href="/2016/one-lambda-calculus-many-times-2/#4925" class="Bound">A</a><a name="4946"> </a><a name="4947" class="Symbol">→</a><a name="4948"> </a><a name="4949" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="4951"> </a><a name="4952" href="/2016/one-lambda-calculus-many-times-2/#4927" class="Bound">B</a><a name="4953"> </a><a name="4954" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="4955"> </a><a name="4956" href="/2016/one-lambda-calculus-many-times-2/#4933" class="Bound">Δ</a><a name="4957"> </a><a name="4958" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="4959"> </a><a name="4960" href="/2016/one-lambda-calculus-many-times-2/#4929" class="Bound">C</a><a name="4961"> </a><a name="4962" class="Symbol">→</a><a name="4963"> </a><a name="4964" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="4966"> </a><a name="4967" href="/2016/one-lambda-calculus-many-times-2/#4925" class="Bound">A</a><a name="4968"> </a><a name="4969" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">⇒</a><a name="4970"> </a><a name="4971" href="/2016/one-lambda-calculus-many-times-2/#4927" class="Bound">B</a><a name="4972"> </a><a name="4973" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="4974"> </a><a name="4975" href="/2016/one-lambda-calculus-many-times-2/#4931" class="Bound">Γ</a><a name="4976"> </a><a name="4977" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#1098" class="Function Operator" target="_blank">++</a><a name="4979"> </a><a name="4980" href="/2016/one-lambda-calculus-many-times-2/#4933" class="Bound">Δ</a><a name="4981"> </a><a name="4982" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="4983"> </a><a name="4984" href="/2016/one-lambda-calculus-many-times-2/#4929" class="Bound">C</a><a name="4985">
    </a><a name="4990" href="/2016/one-lambda-calculus-many-times-2/#4990" class="InductiveConstructor">⇒r</a><a name="4992">  </a><a name="4994" class="Symbol">:</a><a name="4995"> </a><a name="5012" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="5014"> </a><a name="5015" href="/2016/one-lambda-calculus-many-times-2/#4999" class="Bound">A</a><a name="5016"> </a><a name="5017" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="5018"> </a><a name="5019" href="/2016/one-lambda-calculus-many-times-2/#5005" class="Bound">Γ</a><a name="5020"> </a><a name="5021" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="5022"> </a><a name="5023" href="/2016/one-lambda-calculus-many-times-2/#5001" class="Bound">B</a><a name="5024"> </a><a name="5025" class="Symbol">→</a><a name="5026"> </a><a name="5027" href="/2016/one-lambda-calculus-many-times-2/#4780" class="Datatype Operator">LJ</a><a name="5029"> </a><a name="5030" href="/2016/one-lambda-calculus-many-times-2/#5005" class="Bound">Γ</a><a name="5031"> </a><a name="5032" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="5033"> </a><a name="5034" href="/2016/one-lambda-calculus-many-times-2/#4999" class="Bound">A</a><a name="5035"> </a><a name="5036" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">⇒</a><a name="5037"> </a><a name="5038" href="/2016/one-lambda-calculus-many-times-2/#5001" class="Bound">B</a></pre>


---

[^minproplog]: Or, alternatively, as axiomatisations of minimal propositional logic.
