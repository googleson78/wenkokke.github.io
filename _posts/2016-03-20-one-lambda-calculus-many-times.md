---
title         : One λ-calculus, many times...
date          : 2016-03-20 12:00:00
categories    : [compsci]
tags          : [agda]
hide_implicit : true
---

Previously, I mentioned that one of the most common posts on Agda blogs
is implementing the simply-typed λ-calculus. [Gergő Érdi][noshortcuts]
even goes as far as to call it the FizzBuzz of dependently-typed
programming, and rightfully so: If you do a quick search, you'll find
dozens of examples.

In *[Dependently-Typed Programming with Agda][agdatutorial]*, Ulf Norell
implements a type checker the simply-typed λ-calculus;
[Francesco Mazzoli][byexample] more or less follows Ulf, but extends
his λ-calculus with a primitive operator for addition; and,
[Gergő Érdi][noshortcuts] extends Ulf's approach with a checker for
scope and binding.

I figured it would be more fun if, instead of rewriting the type
checker example, I would do something a little bit different. So for
my λ-calculus post, I'll have a look at kinds of different ways of
implementing the simply-typed λ-calculus. Today, natural deduction and
the sequent calculus.

<div class="hidden">
<pre class="Agda"><a name="1135" class="Keyword">module</a><a name="1141"> </a><a name="1142" href="/2016/one-lambda-calculus-many-times/#1" class="Module">2016-03-20-one-lambda-calculus-many-times</a><a name="1183"> </a><a name="1184" class="Keyword">where</a></pre>
</div>

### Natural Deduction and the λ-Calculus

We'll start our discussion with the syntax of types. Usually, types
are defined inductively over some set of atomic types. We don't really
care what these atomic types will be, so we might as well abstract
over them:

<pre class="Agda"><a name="1482" class="Keyword">module</a><a name="1488"> </a><a name="1489" href="/2016/one-lambda-calculus-many-times/#1489" class="Module">Syntax</a><a name="1495"> </a><a name="1496" class="Symbol">(</a><a name="1497" href="/2016/one-lambda-calculus-many-times/#1497" class="Bound">Atom</a><a name="1501"> </a><a name="1502" class="Symbol">:</a><a name="1503"> </a><a name="1504" class="PrimitiveType">Set</a><a name="1507" class="Symbol">)</a><a name="1508"> </a><a name="1509" class="Keyword">where</a></pre>

But, if it makes you feel better, we can pretend that they'll be some
like this:

<pre class="Agda Spec">  <a name="511" class="Keyword">data</a><a name="515"> </a><a name="516" href="#289" class="Module">Atom</a><a name="521"> </a><a name="522" class="Symbol">:</a><a name="523"> </a><a name="524" class="PrimitiveType">Set</a><a name="527"> </a><a name="528" class="Keyword">where</a><a name="533"><br />    </a><a name="538" href="#538" class="InductiveConstructor">Int</a><a name="542">    </a><a name="543" class="Symbol">:</a><a name="544"> </a><a name="545" href="#516" class="Datatype">Atom</a><a name="550"><br />    </a><a name="555" href="#555" class="InductiveConstructor">String</a><a name="562"> </a><a name="563" class="Symbol">:</a><a name="564"> </a><a name="565" href="#516" class="Datatype">Atom</a></pre>

Next, we defined our types. Since we're talking about minimal
propositional logic, a type is either atomic (marked by <a class="Agda
InductiveConstructor">El</a>) or an implication:

<pre class="Agda">  <a name="2551" class="Keyword">infixr</a><a name="2557"> </a><a name="2558" class="Number">6</a><a name="2559"> _⇒_

  </a><a name="2567" class="Keyword">data</a><a name="2571"> </a><a name="2572" href="/2016/one-lambda-calculus-many-times/#1142" class="Module">Type</a><a name="2576"> </a><a name="2577" class="Symbol">:</a><a name="2578"> </a><a name="2579" class="PrimitiveType">Set</a><a name="2582"> </a><a name="2583" class="Keyword">where</a><a name="2588">
    </a><a name="2593" href="/2016/one-lambda-calculus-many-times/#2593" class="InductiveConstructor">El</a><a name="2595">  </a><a name="2597" class="Symbol">:</a><a name="2598"> </a><a name="2599" href="/2016/one-lambda-calculus-many-times/#1497" class="Bound">Atom</a><a name="2603"> </a><a name="2604" class="Symbol">→</a><a name="2605"> </a><a name="2606" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="2610">
    </a><a name="2615" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">_⇒_</a><a name="2618"> </a><a name="2619" class="Symbol">:</a><a name="2620"> </a><a name="2621" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="2625"> </a><a name="2626" class="Symbol">→</a><a name="2627"> </a><a name="2628" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="2632"> </a><a name="2633" class="Symbol">→</a><a name="2634"> </a><a name="2635" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a></pre>

Now we'll define sequents. Even though this is just a tiny piece of
syntax, we should put some thought behind it...

Traditionally, the antecedent of some sequent would be a *set* of
formulas. However, we're looking at this from the perspective of
λ-calculus, and there may well be a difference between two terms of
the same type. This is usually solved by changing the antecedent to a
set of *type assignments*, which means $$x : A$$ and $$y : A$$ are now
distinct. From the logical perspective, this is the same as using a
*bag* or *multiset* antecedent. If we were doing mathematics, we'd be
done, but implementation-wise a bag is actually a rather complex
beast. For this reason, we'll use a *list*:[^imports]

<div class="hidden">
<pre class="Agda">  <a name="3403" class="Keyword">open</a><a name="3407"> </a><a name="3408" class="Keyword">import</a><a name="3414"> </a><a name="3415" href="https://agda.github.io/agda-stdlib/Data.Nat.html#1" class="Module" target="_blank">Data.Nat</a><a name="3423">             </a><a name="3436" class="Keyword">using</a><a name="3441"> </a><a name="3442" class="Symbol">(</a><a name="3443">ℕ</a><a name="3444" class="Symbol">;</a><a name="3445"> suc</a><a name="3449" class="Symbol">;</a><a name="3450"> zero</a><a name="3455" class="Symbol">)</a><a name="3456">
  </a><a name="3459" class="Keyword">open</a><a name="3463"> </a><a name="3464" class="Keyword">import</a><a name="3470"> </a><a name="3471" href="https://agda.github.io/agda-stdlib/Data.Fin.html#1" class="Module" target="_blank">Data.Fin</a><a name="3479">             </a><a name="3492" class="Keyword">using</a><a name="3497"> </a><a name="3498" class="Symbol">(</a><a name="3499">Fin</a><a name="3502" class="Symbol">;</a><a name="3503"> suc</a><a name="3507" class="Symbol">;</a><a name="3508"> zero</a><a name="3513" class="Symbol">)</a><a name="3514">
  </a><a name="3517" class="Keyword">open</a><a name="3521"> </a><a name="3522" class="Keyword">import</a><a name="3528"> </a><a name="3529" href="https://agda.github.io/agda-stdlib/Data.List.html#1" class="Module" target="_blank">Data.List</a><a name="3538">            </a><a name="3550" class="Keyword">using</a><a name="3555"> </a><a name="3556" class="Symbol">(</a><a name="3557">List</a><a name="3561" class="Symbol">;</a><a name="3562"> _∷_</a><a name="3566" class="Symbol">;</a><a name="3567"> []</a><a name="3570" class="Symbol">;</a><a name="3571"> _++_</a><a name="3576" class="Symbol">)</a><a name="3577">
  </a><a name="3580" class="Keyword">open</a><a name="3584"> </a><a name="3585" class="Keyword">import</a><a name="3591"> </a><a name="3592" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1" class="Module" target="_blank">Data.List.Any</a><a name="3605">        </a><a name="3613" class="Keyword">using</a><a name="3618"> </a><a name="3619" class="Symbol">(</a><a name="3620" class="Keyword">module</a><a name="3626"> Membership</a><a name="3637" class="Symbol">;</a><a name="3638"> here</a><a name="3643" class="Symbol">;</a><a name="3644"> there</a><a name="3650" class="Symbol">)</a><a name="3651">
  </a><a name="3654" class="Keyword">open</a><a name="3658"> </a><a name="3659" class="Keyword">import</a><a name="3665"> </a><a name="3666" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#1" class="Module" target="_blank">Function.Equivalence</a><a name="3686"> </a><a name="3687" class="Keyword">using</a><a name="3692"> </a><a name="3693" class="Symbol">(</a><a name="3694">_⇔_</a><a name="3697" class="Symbol">;</a><a name="3698"> id</a><a name="3701" class="Symbol">;</a><a name="3702"> map</a><a name="3706" class="Symbol">;</a><a name="3707"> equivalence</a><a name="3719" class="Symbol">)</a><a name="3720">
  </a><a name="3723" class="Keyword">open</a><a name="3727"> </a><a name="3728" class="Keyword">import</a><a name="3734"> </a><a name="3735" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality</a><a name="3772">
  </a><a name="3775" class="Keyword">open</a><a name="3779"> </a><a name="3780" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2298" class="Module" target="_blank">Membership</a><a name="3790"> </a><a name="3791" class="Symbol">(</a><a name="3792" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1526" class="Function" target="_blank">setoid</a><a name="3798"> </a><a name="3799" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="3803" class="Symbol">)</a><a name="3804">    </a><a name="3808" class="Keyword">using</a><a name="3813"> </a><a name="3814" class="Symbol">(</a><a name="3815">_∈_</a><a name="3818" class="Symbol">;</a><a name="3819"> _⊆_</a><a name="3823" class="Symbol">)</a></pre>
</div>
<pre class="Agda">  <a name="3858" class="Keyword">infix</a><a name="3863"> </a><a name="3864" class="Number">4</a><a name="3865"> _⊢_

  </a><a name="3873" class="Keyword">data</a><a name="3877"> </a><a name="3878" href="/2016/one-lambda-calculus-many-times/#1142" class="Module">Sequent</a><a name="3885"> </a><a name="3886" class="Symbol">:</a><a name="3887"> </a><a name="3888" class="PrimitiveType">Set</a><a name="3891"> </a><a name="3892" class="Keyword">where</a><a name="3897">
    </a><a name="3902" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">_⊢_</a><a name="3905"> </a><a name="3906" class="Symbol">:</a><a name="3907"> </a><a name="3908" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#669" class="Datatype" target="_blank">List</a><a name="3912"> </a><a name="3913" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="3917"> </a><a name="3918" class="Symbol">→</a><a name="3919"> </a><a name="3920" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="3924"> </a><a name="3925" class="Symbol">→</a><a name="3926"> </a><a name="3927" href="/2016/one-lambda-calculus-many-times/#3878" class="Datatype">Sequent</a></pre>

So what does a *proof* of a sequent look like? The logical system that
is most familiar to a computer scientist is probably *natural
deduction*. The natural deduction system for minimal propositional
logic has *three* rules:

$$
    \frac{A \in \Gamma}{\Gamma \vdash A}{\small ax}
    \quad
    \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!i}
    \quad
    \frac{\Gamma \vdash A \Rightarrow B \quad \Gamma \vdash A}{\Gamma \vdash B}{\small{\Rightarrow}\!e}
$$

Recall that λ-terms are constructed in one of three ways: a λ-term is
either a *variable*, an *abstraction* or an *application*:

$$
    M, N ::= x \mid (\lambda x . M) \mid (M\;N)
$$

These correspond exactly to the rules of natural deduction. In fact,
in type systems they are usually presented together:

$$
    \frac{(x : A) \in \Gamma}{\Gamma \vdash x : A}
    \quad
    \frac{x : A , \Gamma \vdash M : B}{\Gamma \vdash (\lambda x. M) : A \Rightarrow B}
    \quad
    \frac{\Gamma \vdash M : A \Rightarrow B \quad \Gamma \vdash N : A}{\Gamma \vdash (M\;N) : B}
$$

However, I like the clean look of the logical notation, so in the
interest of keeping things simple I will use that.
We encode the natural deduction system as a datatype, with each rule
corresponding to a *constructor*, and each proof a *value*:

<pre class="Agda">  <a name="5274" class="Keyword">infix</a><a name="5279"> </a><a name="5280" class="Number">3</a><a name="5281"> ND_

  </a><a name="5289" class="Keyword">data</a><a name="5293"> </a><a name="5294" href="/2016/one-lambda-calculus-many-times/#1142" class="Module">ND_</a><a name="5297"> </a><a name="5298" class="Symbol">:</a><a name="5299"> </a><a name="5300" href="/2016/one-lambda-calculus-many-times/#3878" class="Datatype">Sequent</a><a name="5307"> </a><a name="5308" class="Symbol">→</a><a name="5309"> </a><a name="5310" class="PrimitiveType">Set</a><a name="5313"> </a><a name="5314" class="Keyword">where</a><a name="5319">
    </a><a name="5324" href="/2016/one-lambda-calculus-many-times/#5324" class="InductiveConstructor">ax</a><a name="5326"> </a><a name="5327" class="Symbol">:</a><a name="5328"> </a><a name="5341" href="/2016/one-lambda-calculus-many-times/#5332" class="Bound">A</a><a name="5342"> </a><a name="5343" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="5344"> </a><a name="5345" href="/2016/one-lambda-calculus-many-times/#5336" class="Bound">Γ</a><a name="5346"> </a><a name="5347" class="Symbol">→</a><a name="5348"> </a><a name="5349" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="5351"> </a><a name="5352" href="/2016/one-lambda-calculus-many-times/#5336" class="Bound">Γ</a><a name="5353"> </a><a name="5354" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="5355"> </a><a name="5356" href="/2016/one-lambda-calculus-many-times/#5332" class="Bound">A</a><a name="5357">
    </a><a name="5362" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="5364"> </a><a name="5365" class="Symbol">:</a><a name="5366"> </a><a name="5379" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="5381"> </a><a name="5382" href="/2016/one-lambda-calculus-many-times/#5370" class="Bound">A</a><a name="5383"> </a><a name="5384" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="5385"> </a><a name="5386" href="/2016/one-lambda-calculus-many-times/#5374" class="Bound">Γ</a><a name="5387"> </a><a name="5388" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="5389"> </a><a name="5390" href="/2016/one-lambda-calculus-many-times/#5372" class="Bound">B</a><a name="5391"> </a><a name="5392" class="Symbol">→</a><a name="5393"> </a><a name="5394" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="5396"> </a><a name="5397" href="/2016/one-lambda-calculus-many-times/#5374" class="Bound">Γ</a><a name="5398"> </a><a name="5399" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="5400"> </a><a name="5401" href="/2016/one-lambda-calculus-many-times/#5370" class="Bound">A</a><a name="5402"> </a><a name="5403" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">⇒</a><a name="5404"> </a><a name="5405" href="/2016/one-lambda-calculus-many-times/#5372" class="Bound">B</a><a name="5406">
    </a><a name="5411" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="5413"> </a><a name="5414" class="Symbol">:</a><a name="5415"> </a><a name="5428" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="5430"> </a><a name="5431" href="/2016/one-lambda-calculus-many-times/#5423" class="Bound">Γ</a><a name="5432"> </a><a name="5433" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="5434"> </a><a name="5435" href="/2016/one-lambda-calculus-many-times/#5419" class="Bound">A</a><a name="5436"> </a><a name="5437" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">⇒</a><a name="5438"> </a><a name="5439" href="/2016/one-lambda-calculus-many-times/#5421" class="Bound">B</a><a name="5440"> </a><a name="5441" class="Symbol">→</a><a name="5442"> </a><a name="5443" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="5445"> </a><a name="5446" href="/2016/one-lambda-calculus-many-times/#5423" class="Bound">Γ</a><a name="5447"> </a><a name="5448" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="5449"> </a><a name="5450" href="/2016/one-lambda-calculus-many-times/#5419" class="Bound">A</a><a name="5451"> </a><a name="5452" class="Symbol">→</a><a name="5453"> </a><a name="5454" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="5456"> </a><a name="5457" href="/2016/one-lambda-calculus-many-times/#5423" class="Bound">Γ</a><a name="5458"> </a><a name="5459" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="5460"> </a><a name="5461" href="/2016/one-lambda-calculus-many-times/#5421" class="Bound">B</a></pre>

Note: for the sake of brevity, I'm using an Agda notation in which
implicit arguments are hidden. That means that any unbound
variable---such as the As, Bs and Γs above---is implicitly universally
quantified.

I prefer to think of things of the type <a class="Agda Datatype
Operator">ND</a> as proofs made up of rules, but if you prefer to
think of them as programs made up of the constructors of lambda terms,
just use the following syntax:

<pre class="Agda">  <a name="5933" class="Keyword">pattern</a><a name="5940"> </a><a name="5941" href="/2016/one-lambda-calculus-many-times/#5941" class="InductiveConstructor">var</a><a name="5944">   </a><a name="5947" href="/2016/one-lambda-calculus-many-times/#5956" class="Bound">x</a><a name="5948"> </a><a name="5949" class="Symbol">=</a><a name="5950"> </a><a name="5951" href="/2016/one-lambda-calculus-many-times/#5324" class="InductiveConstructor">ax</a><a name="5953">   </a><a name="5956" href="/2016/one-lambda-calculus-many-times/#5956" class="Bound">x</a><a name="5957">
  </a><a name="5960" class="Keyword">pattern</a><a name="5967"> </a><a name="5968" href="/2016/one-lambda-calculus-many-times/#5968" class="InductiveConstructor">lam</a><a name="5971">   </a><a name="5974" href="/2016/one-lambda-calculus-many-times/#5983" class="Bound">x</a><a name="5975"> </a><a name="5976" class="Symbol">=</a><a name="5977"> </a><a name="5978" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="5980">   </a><a name="5983" href="/2016/one-lambda-calculus-many-times/#5983" class="Bound">x</a><a name="5984">
  </a><a name="5987" class="Keyword">pattern</a><a name="5994"> </a><a name="5995" href="/2016/one-lambda-calculus-many-times/#5995" class="InductiveConstructor Operator">_∙_</a><a name="5998"> </a><a name="5999" href="/2016/one-lambda-calculus-many-times/#6008" class="Bound">f</a><a name="6000"> </a><a name="6001" href="/2016/one-lambda-calculus-many-times/#6010" class="Bound">x</a><a name="6002"> </a><a name="6003" class="Symbol">=</a><a name="6004"> </a><a name="6005" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="6007"> </a><a name="6008" href="/2016/one-lambda-calculus-many-times/#6008" class="Bound">f</a><a name="6009"> </a><a name="6010" href="/2016/one-lambda-calculus-many-times/#6010" class="Bound">x</a></pre>

Earlier, we made the conscious choice to use *lists* to represent the
antecedent. However, this introduced a minor problem: while two
programs of the same type may not do the same thing, they *should* be
equivalent, as far as the type system is concerned, and so it *should*
be possible to rewrite a program which needs *two* values of type
$$A$$ to a program which needs only *one*.

Similarily, by using lists, we have introduced a fixed order in our
antecedent which isn't exactly desirable. While they may be different
programs, we *should* be able to rewrite the program $$f : A\to B\to C$$
to receive its arguments in the different order, i.e. to a program
$$f\prime : B\to A\to C$$.

Collectively, such properties are known as *structural* properties,
and for this particular logic we can summarise them neatly as follows:

> If $$\Gamma \subseteq \Gamma\prime$$ and $$\Gamma \vdash A$$, then
> $$\Gamma\prime \vdash A$$.

We can give a proof of this theorem by induction on the structure of
natural deduction proofs. Note that we represent the subset relation
as a *function*, that is to say $$\Gamma \subseteq \Gamma\prime$$ is
the *function* $$A\in\Gamma\to A\in\Gamma\prime$$:

<pre class="Agda">  <a name="7228" href="/2016/one-lambda-calculus-many-times/#7228" class="Function">struct</a><a name="7234"> </a><a name="7235" class="Symbol">:</a><a name="7236"> </a><a name="7250" href="/2016/one-lambda-calculus-many-times/#7242" class="Bound">Γ</a><a name="7251"> </a><a name="7252" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7253"> </a><a name="7254" href="/2016/one-lambda-calculus-many-times/#7244" class="Bound">Γ′</a><a name="7256"> </a><a name="7257" class="Symbol">→</a><a name="7258"> </a><a name="7259" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="7261"> </a><a name="7262" href="/2016/one-lambda-calculus-many-times/#7242" class="Bound">Γ</a><a name="7263"> </a><a name="7264" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="7265"> </a><a name="7266" href="/2016/one-lambda-calculus-many-times/#7240" class="Bound">A</a><a name="7267"> </a><a name="7268" class="Symbol">→</a><a name="7269"> </a><a name="7270" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="7272"> </a><a name="7273" href="/2016/one-lambda-calculus-many-times/#7244" class="Bound">Γ′</a><a name="7275"> </a><a name="7276" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="7277"> </a><a name="7278" href="/2016/one-lambda-calculus-many-times/#7240" class="Bound">A</a><a name="7279">
  </a><a name="7282" href="/2016/one-lambda-calculus-many-times/#7228" class="Function">struct</a><a name="7288"> </a><a name="7289" href="/2016/one-lambda-calculus-many-times/#7289" class="Bound">Γ⊆Γ′</a><a name="7293"> </a><a name="7294" class="Symbol">(</a><a name="7295" href="/2016/one-lambda-calculus-many-times/#5324" class="InductiveConstructor">ax</a><a name="7297"> </a><a name="7298" href="/2016/one-lambda-calculus-many-times/#7298" class="Bound">x</a><a name="7299" class="Symbol">)</a><a name="7300">   </a><a name="7303" class="Symbol">=</a><a name="7304"> </a><a name="7305" href="/2016/one-lambda-calculus-many-times/#5324" class="InductiveConstructor">ax</a><a name="7307"> </a><a name="7308" class="Symbol">(</a><a name="7309" href="/2016/one-lambda-calculus-many-times/#7289" class="Bound">Γ⊆Γ′</a><a name="7313"> </a><a name="7314" href="/2016/one-lambda-calculus-many-times/#7298" class="Bound">x</a><a name="7315" class="Symbol">)</a><a name="7316">
  </a><a name="7319" href="/2016/one-lambda-calculus-many-times/#7228" class="Function">struct</a><a name="7325"> </a><a name="7326" href="/2016/one-lambda-calculus-many-times/#7326" class="Bound">Γ⊆Γ′</a><a name="7330"> </a><a name="7331" class="Symbol">(</a><a name="7332" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="7334"> </a><a name="7335" href="/2016/one-lambda-calculus-many-times/#7335" class="Bound">f</a><a name="7336" class="Symbol">)</a><a name="7337">   </a><a name="7340" class="Symbol">=</a><a name="7341"> </a><a name="7342" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="7344"> </a><a name="7345" class="Symbol">(</a><a name="7346" href="/2016/one-lambda-calculus-many-times/#7228" class="Function">struct</a><a name="7352"> </a><a name="7353" class="Symbol">(</a><a name="7354" href="/2016/one-lambda-calculus-many-times/#7389" class="Function">∷-resp-⊆</a><a name="7362"> </a><a name="7363" href="/2016/one-lambda-calculus-many-times/#7326" class="Bound">Γ⊆Γ′</a><a name="7367" class="Symbol">)</a><a name="7368"> </a><a name="7369" href="/2016/one-lambda-calculus-many-times/#7335" class="Bound">f</a><a name="7370" class="Symbol">)</a><a name="7371">
    </a><a name="7376" class="Keyword">where</a><a name="7381">

      </a><a name="7389" href="/2016/one-lambda-calculus-many-times/#7389" class="Function">∷-resp-⊆</a><a name="7397"> </a><a name="7398" class="Symbol">:</a><a name="7399"> </a><a name="7413" href="/2016/one-lambda-calculus-many-times/#7405" class="Bound">Γ</a><a name="7414"> </a><a name="7415" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7416"> </a><a name="7417" href="/2016/one-lambda-calculus-many-times/#7407" class="Bound">Γ′</a><a name="7419"> </a><a name="7420" class="Symbol">→</a><a name="7421"> </a><a name="7422" href="/2016/one-lambda-calculus-many-times/#7403" class="Bound">A</a><a name="7423"> </a><a name="7424" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="7425"> </a><a name="7426" href="/2016/one-lambda-calculus-many-times/#7405" class="Bound">Γ</a><a name="7427"> </a><a name="7428" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7429"> </a><a name="7430" href="/2016/one-lambda-calculus-many-times/#7403" class="Bound">A</a><a name="7431"> </a><a name="7432" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="7433"> </a><a name="7434" href="/2016/one-lambda-calculus-many-times/#7407" class="Bound">Γ′</a><a name="7436">
      </a><a name="7443" href="/2016/one-lambda-calculus-many-times/#7389" class="Function">∷-resp-⊆</a><a name="7451"> </a><a name="7452" href="/2016/one-lambda-calculus-many-times/#7452" class="Bound">Γ⊆Γ′</a><a name="7456"> </a><a name="7457" class="Symbol">(</a><a name="7458" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="7462">  </a><a name="7464" href="/2016/one-lambda-calculus-many-times/#7464" class="Bound">x</a><a name="7465" class="Symbol">)</a><a name="7466"> </a><a name="7467" class="Symbol">=</a><a name="7468"> </a><a name="7469" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="7473"> </a><a name="7474" href="/2016/one-lambda-calculus-many-times/#7464" class="Bound">x</a><a name="7475">
      </a><a name="7482" href="/2016/one-lambda-calculus-many-times/#7389" class="Function">∷-resp-⊆</a><a name="7490"> </a><a name="7491" href="/2016/one-lambda-calculus-many-times/#7491" class="Bound">Γ⊆Γ′</a><a name="7495"> </a><a name="7496" class="Symbol">(</a><a name="7497" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="7502"> </a><a name="7503" href="/2016/one-lambda-calculus-many-times/#7503" class="Bound">x</a><a name="7504" class="Symbol">)</a><a name="7505"> </a><a name="7506" class="Symbol">=</a><a name="7507"> </a><a name="7508" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="7513"> </a><a name="7514" class="Symbol">(</a><a name="7515" href="/2016/one-lambda-calculus-many-times/#7491" class="Bound">Γ⊆Γ′</a><a name="7519"> </a><a name="7520" href="/2016/one-lambda-calculus-many-times/#7503" class="Bound">x</a><a name="7521" class="Symbol">)</a><a name="7522">

  </a><a name="7526" href="/2016/one-lambda-calculus-many-times/#7228" class="Function">struct</a><a name="7532"> </a><a name="7533" href="/2016/one-lambda-calculus-many-times/#7533" class="Bound">Γ⊆Γ′</a><a name="7537"> </a><a name="7538" class="Symbol">(</a><a name="7539" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="7541"> </a><a name="7542" href="/2016/one-lambda-calculus-many-times/#7542" class="Bound">f</a><a name="7543"> </a><a name="7544" href="/2016/one-lambda-calculus-many-times/#7544" class="Bound">g</a><a name="7545" class="Symbol">)</a><a name="7546"> </a><a name="7547" class="Symbol">=</a><a name="7548"> </a><a name="7549" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="7551"> </a><a name="7552" class="Symbol">(</a><a name="7553" href="/2016/one-lambda-calculus-many-times/#7228" class="Function">struct</a><a name="7559"> </a><a name="7560" href="/2016/one-lambda-calculus-many-times/#7533" class="Bound">Γ⊆Γ′</a><a name="7564"> </a><a name="7565" href="/2016/one-lambda-calculus-many-times/#7542" class="Bound">f</a><a name="7566" class="Symbol">)</a><a name="7567"> </a><a name="7568" class="Symbol">(</a><a name="7569" href="/2016/one-lambda-calculus-many-times/#7228" class="Function">struct</a><a name="7575"> </a><a name="7576" href="/2016/one-lambda-calculus-many-times/#7533" class="Bound">Γ⊆Γ′</a><a name="7580"> </a><a name="7581" href="/2016/one-lambda-calculus-many-times/#7544" class="Bound">g</a><a name="7582" class="Symbol">)</a></pre>

Note that values of type $$A\in\Gamma$$ are constructed using <a
class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174">here</a>
and <a class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227">there</a>,
which makes them more or less just numbers, i.e. "first value",
"second value", etc...

I mentioned two uses of this structural rule: contracting two
different variables of the *same* type into one, and exchanging the
order of the types in the antecedent. There is one more canonical use:
*weakning*.
Weakening is so obvious to programmers that they don't really think of
it, but what it says is that if you can run a program in *some*
environment, then you should *certainly* be able to run that program
in that enviroment with some irrelevant stuff added to it. Formally,
we write it as:

<pre class="Agda">  <a name="8526" href="/2016/one-lambda-calculus-many-times/#8526" class="Function">weak</a><a name="8530"> </a><a name="8531" class="Symbol">:</a><a name="8532"> </a><a name="8545" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="8547"> </a><a name="8548" href="/2016/one-lambda-calculus-many-times/#8540" class="Bound">Γ</a><a name="8549"> </a><a name="8550" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="8551"> </a><a name="8552" href="/2016/one-lambda-calculus-many-times/#8538" class="Bound">B</a><a name="8553"> </a><a name="8554" class="Symbol">→</a><a name="8555"> </a><a name="8556" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="8558"> </a><a name="8559" href="/2016/one-lambda-calculus-many-times/#8536" class="Bound">A</a><a name="8560"> </a><a name="8561" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="8562"> </a><a name="8563" href="/2016/one-lambda-calculus-many-times/#8540" class="Bound">Γ</a><a name="8564"> </a><a name="8565" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="8566"> </a><a name="8567" href="/2016/one-lambda-calculus-many-times/#8538" class="Bound">B</a><a name="8568">
  </a><a name="8571" href="/2016/one-lambda-calculus-many-times/#8526" class="Function">weak</a><a name="8575"> </a><a name="8576" class="Symbol">=</a><a name="8577"> </a><a name="8578" href="/2016/one-lambda-calculus-many-times/#7228" class="Function">struct</a><a name="8584"> </a><a name="8585" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a></pre>

Passing <a class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227">there</a>
to <a href="#6956" class="Agda Function">struct</a> simply
moves every value by one: the first value becomes the second, the
second becomes the third, etc... In the new antecedent, the first
value will be our "irrelevant stuff".


### Sequent Calculus and Natural Deduction

We've got enough to start talking about the sequent calculus now. The
sequent calculus is a different way of writing down logical systems,
and it has some pros and cons when compared to natural deduction.
It's usual presentation is as follows:

$$
    \frac{A \in \Gamma}{\Gamma \vdash A}{\small ax}
    \quad
    \frac{\Gamma \vdash A \quad A , \Gamma \vdash B}{\Gamma \vdash B}{\small cut}
    \quad
    \frac{\Gamma \vdash A \quad B , \Gamma \vdash C}{A \Rightarrow  B , \Gamma \vdash C}{\small{\Rightarrow}\!l}
    \quad
    \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!r}
$$

We can encode these rules in Agda as follows:

<pre class="Agda">  <a name="9692" class="Keyword">infix</a><a name="9697"> </a><a name="9698" class="Number">3</a><a name="9699"> SC_

  </a><a name="9707" class="Keyword">data</a><a name="9711"> </a><a name="9712" href="/2016/one-lambda-calculus-many-times/#1142" class="Module">SC_</a><a name="9715"> </a><a name="9716" class="Symbol">:</a><a name="9717"> </a><a name="9718" href="/2016/one-lambda-calculus-many-times/#3878" class="Datatype">Sequent</a><a name="9725"> </a><a name="9726" class="Symbol">→</a><a name="9727"> </a><a name="9728" class="PrimitiveType">Set</a><a name="9731"> </a><a name="9732" class="Keyword">where</a><a name="9737">
    </a><a name="9742" href="/2016/one-lambda-calculus-many-times/#9742" class="InductiveConstructor">ax</a><a name="9744">  </a><a name="9746" class="Symbol">:</a><a name="9747"> </a><a name="9762" href="/2016/one-lambda-calculus-many-times/#9751" class="Bound">A</a><a name="9763"> </a><a name="9764" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="9765"> </a><a name="9766" href="/2016/one-lambda-calculus-many-times/#9757" class="Bound">Γ</a><a name="9767"> </a><a name="9768" class="Symbol">→</a><a name="9769"> </a><a name="9770" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9772"> </a><a name="9773" href="/2016/one-lambda-calculus-many-times/#9757" class="Bound">Γ</a><a name="9774"> </a><a name="9775" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9776"> </a><a name="9777" href="/2016/one-lambda-calculus-many-times/#9751" class="Bound">A</a><a name="9778">
    </a><a name="9783" href="/2016/one-lambda-calculus-many-times/#9783" class="InductiveConstructor">cut</a><a name="9786"> </a><a name="9787" class="Symbol">:</a><a name="9788"> </a><a name="9803" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9805"> </a><a name="9806" href="/2016/one-lambda-calculus-many-times/#9798" class="Bound">Γ</a><a name="9807"> </a><a name="9808" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9809"> </a><a name="9810" href="/2016/one-lambda-calculus-many-times/#9792" class="Bound">A</a><a name="9811"> </a><a name="9812" class="Symbol">→</a><a name="9813"> </a><a name="9814" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9816"> </a><a name="9817" href="/2016/one-lambda-calculus-many-times/#9792" class="Bound">A</a><a name="9818"> </a><a name="9819" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9820"> </a><a name="9821" href="/2016/one-lambda-calculus-many-times/#9798" class="Bound">Γ</a><a name="9822"> </a><a name="9823" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9824"> </a><a name="9825" href="/2016/one-lambda-calculus-many-times/#9794" class="Bound">B</a><a name="9826"> </a><a name="9827" class="Symbol">→</a><a name="9828"> </a><a name="9829" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9831"> </a><a name="9832" href="/2016/one-lambda-calculus-many-times/#9798" class="Bound">Γ</a><a name="9833"> </a><a name="9834" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9835"> </a><a name="9836" href="/2016/one-lambda-calculus-many-times/#9794" class="Bound">B</a><a name="9837">
    </a><a name="9842" href="/2016/one-lambda-calculus-many-times/#9842" class="InductiveConstructor">⇒l</a><a name="9844">  </a><a name="9846" class="Symbol">:</a><a name="9847"> </a><a name="9862" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9864"> </a><a name="9865" href="/2016/one-lambda-calculus-many-times/#9857" class="Bound">Γ</a><a name="9866"> </a><a name="9867" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9868"> </a><a name="9869" href="/2016/one-lambda-calculus-many-times/#9851" class="Bound">A</a><a name="9870"> </a><a name="9871" class="Symbol">→</a><a name="9872"> </a><a name="9873" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9875"> </a><a name="9876" href="/2016/one-lambda-calculus-many-times/#9853" class="Bound">B</a><a name="9877"> </a><a name="9878" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9879"> </a><a name="9880" href="/2016/one-lambda-calculus-many-times/#9857" class="Bound">Γ</a><a name="9881"> </a><a name="9882" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9883"> </a><a name="9884" href="/2016/one-lambda-calculus-many-times/#9855" class="Bound">C</a><a name="9885"> </a><a name="9886" class="Symbol">→</a><a name="9887"> </a><a name="9888" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9890"> </a><a name="9891" href="/2016/one-lambda-calculus-many-times/#9851" class="Bound">A</a><a name="9892"> </a><a name="9893" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">⇒</a><a name="9894"> </a><a name="9895" href="/2016/one-lambda-calculus-many-times/#9853" class="Bound">B</a><a name="9896"> </a><a name="9897" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9898"> </a><a name="9899" href="/2016/one-lambda-calculus-many-times/#9857" class="Bound">Γ</a><a name="9900"> </a><a name="9901" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9902"> </a><a name="9903" href="/2016/one-lambda-calculus-many-times/#9855" class="Bound">C</a><a name="9904">
    </a><a name="9909" href="/2016/one-lambda-calculus-many-times/#9909" class="InductiveConstructor">⇒r</a><a name="9911">  </a><a name="9913" class="Symbol">:</a><a name="9914"> </a><a name="9929" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9931"> </a><a name="9932" href="/2016/one-lambda-calculus-many-times/#9918" class="Bound">A</a><a name="9933"> </a><a name="9934" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9935"> </a><a name="9936" href="/2016/one-lambda-calculus-many-times/#9924" class="Bound">Γ</a><a name="9937"> </a><a name="9938" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9939"> </a><a name="9940" href="/2016/one-lambda-calculus-many-times/#9920" class="Bound">B</a><a name="9941"> </a><a name="9942" class="Symbol">→</a><a name="9943"> </a><a name="9944" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="9946"> </a><a name="9947" href="/2016/one-lambda-calculus-many-times/#9924" class="Bound">Γ</a><a name="9948"> </a><a name="9949" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="9950"> </a><a name="9951" href="/2016/one-lambda-calculus-many-times/#9918" class="Bound">A</a><a name="9952"> </a><a name="9953" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">⇒</a><a name="9954"> </a><a name="9955" href="/2016/one-lambda-calculus-many-times/#9920" class="Bound">B</a></pre>

We will define a few patterns that we'd otherwise have to write out,
over and over again. Namely, names for the first, second, and third
variable in a context:

<pre class="Agda">  <a name="10145" class="Keyword">pattern</a><a name="10152"> </a><a name="10153" href="/2016/one-lambda-calculus-many-times/#10153" class="InductiveConstructor">ax₀</a><a name="10156"> </a><a name="10157" class="Symbol">=</a><a name="10158"> </a><a name="10159" class="InductiveConstructor">ax</a><a name="10161"> </a><a name="10162" class="Symbol">(</a><a name="10163" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10167"> </a><a name="10168" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="10172" class="Symbol">)</a><a name="10173">
  </a><a name="10176" class="Keyword">pattern</a><a name="10183"> </a><a name="10184" href="/2016/one-lambda-calculus-many-times/#10184" class="InductiveConstructor">ax₁</a><a name="10187"> </a><a name="10188" class="Symbol">=</a><a name="10189"> </a><a name="10190" class="InductiveConstructor">ax</a><a name="10192"> </a><a name="10193" class="Symbol">(</a><a name="10194" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10199"> </a><a name="10200" class="Symbol">(</a><a name="10201" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10205"> </a><a name="10206" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="10210" class="Symbol">))</a><a name="10212">
  </a><a name="10215" class="Keyword">pattern</a><a name="10222"> </a><a name="10223" href="/2016/one-lambda-calculus-many-times/#10223" class="InductiveConstructor">ax₂</a><a name="10226"> </a><a name="10227" class="Symbol">=</a><a name="10228"> </a><a name="10229" class="InductiveConstructor">ax</a><a name="10231"> </a><a name="10232" class="Symbol">(</a><a name="10233" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10238"> </a><a name="10239" class="Symbol">(</a><a name="10240" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10245"> </a><a name="10246" class="Symbol">(</a><a name="10247" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10251"> </a><a name="10252" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="10256" class="Symbol">)))</a></pre>

It's a little bit of a puzzle, but given <a href="#8254" class="Agda
Function">weak</a> it becomes quite easy to show that the two logics
are in fact equivalent---that they derive the *same sequents*:

<pre class="Agda">  <a name="10489" class="Keyword">module</a><a name="10495"> </a><a name="10496" href="/2016/one-lambda-calculus-many-times/#10496" class="Module">ND⇔SC</a><a name="10501"> </a><a name="10502" class="Keyword">where</a><a name="10507">

    </a><a name="10513" href="/2016/one-lambda-calculus-many-times/#10513" class="Function">⟹</a><a name="10514"> </a><a name="10515" class="Symbol">:</a><a name="10516"> </a><a name="10525" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="10527"> </a><a name="10528" href="/2016/one-lambda-calculus-many-times/#10520" class="Bound">S</a><a name="10529"> </a><a name="10530" class="Symbol">→</a><a name="10531"> </a><a name="10532" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="10534"> </a><a name="10535" href="/2016/one-lambda-calculus-many-times/#10520" class="Bound">S</a><a name="10536">
    </a><a name="10541" href="/2016/one-lambda-calculus-many-times/#10513" class="Function">⟹</a><a name="10542"> </a><a name="10543" class="Symbol">(</a><a name="10544" href="/2016/one-lambda-calculus-many-times/#5324" class="InductiveConstructor">ax</a><a name="10546">  </a><a name="10548" href="/2016/one-lambda-calculus-many-times/#10548" class="Bound">x</a><a name="10549" class="Symbol">)</a><a name="10550">   </a><a name="10553" class="Symbol">=</a><a name="10554"> </a><a name="10555" href="/2016/one-lambda-calculus-many-times/#9742" class="InductiveConstructor">ax</a><a name="10557"> </a><a name="10558" href="/2016/one-lambda-calculus-many-times/#10548" class="Bound">x</a><a name="10559">
    </a><a name="10564" href="/2016/one-lambda-calculus-many-times/#10513" class="Function">⟹</a><a name="10565"> </a><a name="10566" class="Symbol">(</a><a name="10567" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="10569">  </a><a name="10571" href="/2016/one-lambda-calculus-many-times/#10571" class="Bound">f</a><a name="10572" class="Symbol">)</a><a name="10573">   </a><a name="10576" class="Symbol">=</a><a name="10577"> </a><a name="10578" href="/2016/one-lambda-calculus-many-times/#9909" class="InductiveConstructor">⇒r</a><a name="10580">  </a><a name="10582" class="Symbol">(</a><a name="10583" href="/2016/one-lambda-calculus-many-times/#10513" class="Function">⟹</a><a name="10584"> </a><a name="10585" href="/2016/one-lambda-calculus-many-times/#10571" class="Bound">f</a><a name="10586" class="Symbol">)</a><a name="10587">
    </a><a name="10592" href="/2016/one-lambda-calculus-many-times/#10513" class="Function">⟹</a><a name="10593"> </a><a name="10594" class="Symbol">(</a><a name="10595" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="10597">  </a><a name="10599" href="/2016/one-lambda-calculus-many-times/#10599" class="Bound">f</a><a name="10600"> </a><a name="10601" href="/2016/one-lambda-calculus-many-times/#10601" class="Bound">g</a><a name="10602" class="Symbol">)</a><a name="10603"> </a><a name="10604" class="Symbol">=</a><a name="10605"> </a><a name="10606" href="/2016/one-lambda-calculus-many-times/#9783" class="InductiveConstructor">cut</a><a name="10609"> </a><a name="10610" class="Symbol">(</a><a name="10611" href="/2016/one-lambda-calculus-many-times/#10513" class="Function">⟹</a><a name="10612"> </a><a name="10613" href="/2016/one-lambda-calculus-many-times/#10599" class="Bound">f</a><a name="10614" class="Symbol">)</a><a name="10615"> </a><a name="10616" class="Symbol">(</a><a name="10617" href="/2016/one-lambda-calculus-many-times/#9842" class="InductiveConstructor">⇒l</a><a name="10619"> </a><a name="10620" class="Symbol">(</a><a name="10621" href="/2016/one-lambda-calculus-many-times/#10513" class="Function">⟹</a><a name="10622"> </a><a name="10623" href="/2016/one-lambda-calculus-many-times/#10601" class="Bound">g</a><a name="10624" class="Symbol">)</a><a name="10625"> </a><a name="10626" href="/2016/one-lambda-calculus-many-times/#10153" class="InductiveConstructor">ax₀</a><a name="10629" class="Symbol">)</a><a name="10630">

    </a><a name="10636" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10637"> </a><a name="10638" class="Symbol">:</a><a name="10639"> </a><a name="10648" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="10650"> </a><a name="10651" href="/2016/one-lambda-calculus-many-times/#10643" class="Bound">S</a><a name="10652"> </a><a name="10653" class="Symbol">→</a><a name="10654"> </a><a name="10655" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="10657"> </a><a name="10658" href="/2016/one-lambda-calculus-many-times/#10643" class="Bound">S</a><a name="10659">
    </a><a name="10664" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10665"> </a><a name="10666" class="Symbol">(</a><a name="10667" href="/2016/one-lambda-calculus-many-times/#9742" class="InductiveConstructor">ax</a><a name="10669">  </a><a name="10671" href="/2016/one-lambda-calculus-many-times/#10671" class="Bound">p</a><a name="10672" class="Symbol">)</a><a name="10673">   </a><a name="10676" class="Symbol">=</a><a name="10677"> </a><a name="10678" href="/2016/one-lambda-calculus-many-times/#5324" class="InductiveConstructor">ax</a><a name="10680"> </a><a name="10681" href="/2016/one-lambda-calculus-many-times/#10671" class="Bound">p</a><a name="10682">
    </a><a name="10687" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10688"> </a><a name="10689" class="Symbol">(</a><a name="10690" href="/2016/one-lambda-calculus-many-times/#9783" class="InductiveConstructor">cut</a><a name="10693"> </a><a name="10694" href="/2016/one-lambda-calculus-many-times/#10694" class="Bound">f</a><a name="10695"> </a><a name="10696" href="/2016/one-lambda-calculus-many-times/#10696" class="Bound">g</a><a name="10697" class="Symbol">)</a><a name="10698"> </a><a name="10699" class="Symbol">=</a><a name="10700"> </a><a name="10701" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="10703"> </a><a name="10704" class="Symbol">(</a><a name="10705" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="10707"> </a><a name="10708" class="Symbol">(</a><a name="10709" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10710"> </a><a name="10711" href="/2016/one-lambda-calculus-many-times/#10696" class="Bound">g</a><a name="10712" class="Symbol">))</a><a name="10714"> </a><a name="10715" class="Symbol">(</a><a name="10716" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10717"> </a><a name="10718" href="/2016/one-lambda-calculus-many-times/#10694" class="Bound">f</a><a name="10719" class="Symbol">)</a><a name="10720">
    </a><a name="10725" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10726"> </a><a name="10727" class="Symbol">(</a><a name="10728" href="/2016/one-lambda-calculus-many-times/#9842" class="InductiveConstructor">⇒l</a><a name="10730">  </a><a name="10732" href="/2016/one-lambda-calculus-many-times/#10732" class="Bound">f</a><a name="10733"> </a><a name="10734" href="/2016/one-lambda-calculus-many-times/#10734" class="Bound">g</a><a name="10735" class="Symbol">)</a><a name="10736"> </a><a name="10737" class="Symbol">=</a><a name="10738"> </a><a name="10739" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="10741"> </a><a name="10742" class="Symbol">(</a><a name="10743" href="/2016/one-lambda-calculus-many-times/#8526" class="Function">weak</a><a name="10747"> </a><a name="10748" class="Symbol">(</a><a name="10749" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="10751"> </a><a name="10752" class="Symbol">(</a><a name="10753" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10754"> </a><a name="10755" href="/2016/one-lambda-calculus-many-times/#10734" class="Bound">g</a><a name="10756" class="Symbol">)))</a><a name="10759"> </a><a name="10760" class="Symbol">(</a><a name="10761" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="10763"> </a><a name="10764" href="/2016/one-lambda-calculus-many-times/#10153" class="InductiveConstructor">ax₀</a><a name="10767"> </a><a name="10768" class="Symbol">(</a><a name="10769" href="/2016/one-lambda-calculus-many-times/#8526" class="Function">weak</a><a name="10773"> </a><a name="10774" class="Symbol">(</a><a name="10775" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10776"> </a><a name="10777" href="/2016/one-lambda-calculus-many-times/#10732" class="Bound">f</a><a name="10778" class="Symbol">)))</a><a name="10781">
    </a><a name="10786" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10787"> </a><a name="10788" class="Symbol">(</a><a name="10789" href="/2016/one-lambda-calculus-many-times/#9909" class="InductiveConstructor">⇒r</a><a name="10791">  </a><a name="10793" href="/2016/one-lambda-calculus-many-times/#10793" class="Bound">f</a><a name="10794" class="Symbol">)</a><a name="10795">   </a><a name="10798" class="Symbol">=</a><a name="10799"> </a><a name="10800" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="10802"> </a><a name="10803" class="Symbol">(</a><a name="10804" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">⟸</a><a name="10805"> </a><a name="10806" href="/2016/one-lambda-calculus-many-times/#10793" class="Bound">f</a><a name="10807" class="Symbol">)</a></pre>

The rules for sequent calculus obviously no longer correspond *directly*
to the λ-calculus. However, we've just shown that there is in fact
*some* correspondence between them.
In the λ-calculus, computation is represented by β-reduction, which is
the iterative removal of redexes

$$(\lambda x.M)\; N\mapsto M[x := N]$$

Likewise, sequent calculus comes equipped with its own notion of
computation: cut-elimination. And the beautiful thing about cut
elimination is that it has a *very* concrete normal form. Instead of
faffing about, claiming the structure is free of β-redexes, cut
elimination---as its name implies---allows you to remove the entire
structural rule of $$cut$$. It would be interesting to show exactly
what kind of relation cut elimination has to β-reduction...

*Alas*! It may be too much effort for a single post to implement both of
these logics *and* a procedure for cut elimination. However, there
*is* a much simpler thing we can do. Agda itself has a pretty
servicable implementation of β-reduction for Agda terms, and we can
quite easily piggyback on that mechanism. In fact, most of the
articles I linked to at the beginning do exactly this.


### Interpretations in Agda

As a first step, we write down what an interpretation is---and since
we want to use the intepretation brackets in as many places as
possible, we create a type class for it, and give <a href="#12173"
class="Agda Field Operator">⟦_⟧</a> the least restrictive type
possible:

<div class="hidden">
<pre class="Agda"><a name="12327" class="Keyword">open</a><a name="12331"> </a><a name="12332" class="Keyword">import</a><a name="12338"> </a><a name="12339" href="https://agda.github.io/agda-stdlib/Level.html#1" class="Module" target="_blank">Level</a><a name="12344"> </a><a name="12345" class="Keyword">using</a><a name="12350"> </a><a name="12351" class="Symbol">(</a><a name="12352">_⊔_</a><a name="12355" class="Symbol">)</a></pre>
</div>
<pre class="Agda"><a name="12388" class="Keyword">record</a><a name="12394"> </a><a name="12395" href="/2016/one-lambda-calculus-many-times/#12395" class="Record">Interpret</a><a name="12404"> </a><a name="12413" class="Symbol">(</a><a name="12414" href="/2016/one-lambda-calculus-many-times/#12414" class="Bound">A</a><a name="12415"> </a><a name="12416" class="Symbol">:</a><a name="12417"> </a><a name="12418" class="PrimitiveType">Set</a><a name="12421"> </a><a name="12422" href="/2016/one-lambda-calculus-many-times/#12406" class="Bound">a</a><a name="12423" class="Symbol">)</a><a name="12424"> </a><a name="12425" class="Symbol">(</a><a name="12426" href="/2016/one-lambda-calculus-many-times/#12426" class="Bound">B</a><a name="12427"> </a><a name="12428" class="Symbol">:</a><a name="12429"> </a><a name="12430" class="PrimitiveType">Set</a><a name="12433"> </a><a name="12434" href="/2016/one-lambda-calculus-many-times/#12410" class="Bound">b</a><a name="12435" class="Symbol">)</a><a name="12436"> </a><a name="12437" class="Symbol">:</a><a name="12438"> </a><a name="12439" class="PrimitiveType">Set</a><a name="12442"> </a><a name="12443" class="Symbol">(</a><a name="12444" href="/2016/one-lambda-calculus-many-times/#12406" class="Bound">a</a><a name="12445"> </a><a name="12446" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#626" class="Primitive Operator" target="_blank">⊔</a><a name="12447"> </a><a name="12448" href="/2016/one-lambda-calculus-many-times/#12410" class="Bound">b</a><a name="12449" class="Symbol">)</a><a name="12450"> </a><a name="12451" class="Keyword">where</a><a name="12456">
  </a><a name="12459" class="Keyword">field</a><a name="12464">
    </a><a name="12469" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦_⟧</a><a name="12472"> </a><a name="12473" class="Symbol">:</a><a name="12474"> </a><a name="12475" href="/2016/one-lambda-calculus-many-times/#12414" class="Bound">A</a><a name="12476"> </a><a name="12477" class="Symbol">→</a><a name="12478"> </a><a name="12479" href="/2016/one-lambda-calculus-many-times/#12426" class="Bound">B</a><a name="12480">
</a><a name="12481" class="Keyword">open</a><a name="12485"> </a><a name="12486" href="/2016/one-lambda-calculus-many-times/#12395" class="Module">Interpret</a><a name="12495"> </a><a name="12496" class="Symbol">{{...}}</a></pre>

Now, in order to interpret natural deduction proofs in Agda, we'll
need an interpretation for the atomic types. Below we say as much:

<pre class="Agda"><a name="12664" class="Keyword">module</a><a name="12670"> </a><a name="12671" href="/2016/one-lambda-calculus-many-times/#12671" class="Module">Semantics</a><a name="12680"> </a><a name="12681" class="Symbol">(</a><a name="12682" href="/2016/one-lambda-calculus-many-times/#12682" class="Bound">Atom</a><a name="12686"> </a><a name="12687" class="Symbol">:</a><a name="12688"> </a><a name="12689" class="PrimitiveType">Set</a><a name="12692" class="Symbol">)</a><a name="12693"> </a><a name="12694" class="Symbol">(</a><a name="12695" href="/2016/one-lambda-calculus-many-times/#12695" class="Bound">InterpretAtom</a><a name="12708"> </a><a name="12709" class="Symbol">:</a><a name="12710"> </a><a name="12711" href="/2016/one-lambda-calculus-many-times/#12395" class="Record">Interpret</a><a name="12720"> </a><a name="12721" href="/2016/one-lambda-calculus-many-times/#12682" class="Bound">Atom</a><a name="12725"> </a><a name="12726" class="PrimitiveType">Set</a><a name="12729" class="Symbol">)</a><a name="12730"> </a><a name="12731" class="Keyword">where</a></pre>

<div class="hidden">
<pre class="Agda">  <a name="12785" class="Keyword">open</a><a name="12789"> </a><a name="12790" href="/2016/one-lambda-calculus-many-times/#1489" class="Module">Syntax</a><a name="12796"> </a><a name="12797" href="/2016/one-lambda-calculus-many-times/#12682" class="Bound">Atom</a><a name="12801">
  </a><a name="12804" class="Keyword">open</a><a name="12808"> </a><a name="12809" class="Keyword">import</a><a name="12815"> </a><a name="12816" href="https://agda.github.io/agda-stdlib/Data.Empty.html#1" class="Module" target="_blank">Data.Empty</a><a name="12826">           </a><a name="12837" class="Keyword">using</a><a name="12842"> </a><a name="12843" class="Symbol">(</a><a name="12844">⊥-elim</a><a name="12850" class="Symbol">)</a><a name="12851">
  </a><a name="12854" class="Keyword">open</a><a name="12858"> </a><a name="12859" class="Keyword">import</a><a name="12865"> </a><a name="12866" href="https://agda.github.io/agda-stdlib/Data.List.html#1" class="Module" target="_blank">Data.List</a><a name="12875">            </a><a name="12887" class="Keyword">using</a><a name="12892"> </a><a name="12893" class="Symbol">(</a><a name="12894">List</a><a name="12898" class="Symbol">;</a><a name="12899"> _∷_</a><a name="12903" class="Symbol">;</a><a name="12904"> []</a><a name="12907" class="Symbol">;</a><a name="12908"> map</a><a name="12912" class="Symbol">)</a><a name="12913">
  </a><a name="12916" class="Keyword">open</a><a name="12920"> </a><a name="12921" class="Keyword">import</a><a name="12927"> </a><a name="12928" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1" class="Module" target="_blank">Data.List.Any</a><a name="12941">        </a><a name="12949" class="Keyword">using</a><a name="12954"> </a><a name="12955" class="Symbol">(</a><a name="12956" class="Keyword">module</a><a name="12962"> Membership</a><a name="12973" class="Symbol">;</a><a name="12974"> here</a><a name="12979" class="Symbol">;</a><a name="12980"> there</a><a name="12986" class="Symbol">)</a><a name="12987">
  </a><a name="12990" class="Keyword">open</a><a name="12994"> </a><a name="12995" class="Keyword">import</a><a name="13001"> </a><a name="13002" href="https://agda.github.io/agda-stdlib/Function.html#1" class="Module" target="_blank">Function</a><a name="13010">             </a><a name="13023" class="Keyword">using</a><a name="13028"> </a><a name="13029" class="Symbol">(</a><a name="13030">_∘_</a><a name="13033" class="Symbol">)</a><a name="13034">
  </a><a name="13037" class="Keyword">open</a><a name="13041"> </a><a name="13042" class="Keyword">import</a><a name="13048"> </a><a name="13049" href="https://agda.github.io/agda-stdlib/Function.Equality.html#1" class="Module" target="_blank">Function.Equality</a><a name="13066">    </a><a name="13070" class="Keyword">using</a><a name="13075"> </a><a name="13076" class="Symbol">(</a><a name="13077">_⟨$⟩_</a><a name="13082" class="Symbol">)</a><a name="13083">
  </a><a name="13086" class="Keyword">open</a><a name="13090"> </a><a name="13091" class="Keyword">import</a><a name="13097"> </a><a name="13098" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#1" class="Module" target="_blank">Function.Equivalence</a><a name="13118"> </a><a name="13119" class="Keyword">using</a><a name="13124"> </a><a name="13125" class="Symbol">(</a><a name="13126" class="Keyword">module</a><a name="13132"> Equivalence</a><a name="13144" class="Symbol">)</a><a name="13145">
  </a><a name="13148" class="Keyword">open</a><a name="13152"> </a><a name="13153" class="Keyword">import</a><a name="13159"> </a><a name="13160" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality</a><a name="13197">
  </a><a name="13200" class="Keyword">open</a><a name="13204"> </a><a name="13205" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2298" class="Module" target="_blank">Membership</a><a name="13215"> </a><a name="13216" class="Symbol">(</a><a name="13217" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1526" class="Function" target="_blank">setoid</a><a name="13223"> </a><a name="13224" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="13228" class="Symbol">)</a><a name="13229">    </a><a name="13233" class="Keyword">using</a><a name="13238"> </a><a name="13239" class="Symbol">(</a><a name="13240">_∈_</a><a name="13243" class="Symbol">;</a><a name="13244"> _⊆_</a><a name="13248" class="Symbol">)</a><a name="13249">
  </a><a name="13252" class="Keyword">open</a><a name="13256"> </a><a name="13257" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#488" class="Module" target="_blank">Equivalence</a><a name="13268">                 </a><a name="13285" class="Keyword">using</a><a name="13290"> </a><a name="13291" class="Symbol">(</a><a name="13292">to</a><a name="13294" class="Symbol">;</a><a name="13295"> from</a><a name="13300" class="Symbol">)</a></pre>
</div>

Unsurprisingly, we interpret the implication as Agda's function type:

<pre class="Agda">  <a name="13407" class="Keyword">instance</a><a name="13415">
    </a><a name="13420" href="/2016/one-lambda-calculus-many-times/#13420" class="Function">InterpretType</a><a name="13433"> </a><a name="13434" class="Symbol">:</a><a name="13435"> </a><a name="13436" href="/2016/one-lambda-calculus-many-times/#12395" class="Record">Interpret</a><a name="13445"> </a><a name="13446" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="13450"> </a><a name="13451" class="PrimitiveType">Set</a><a name="13454">
    </a><a name="13459" href="/2016/one-lambda-calculus-many-times/#13420" class="Function">InterpretType</a><a name="13472"> </a><a name="13473" class="Symbol">=</a><a name="13474"> </a><a name="13475" class="Keyword">record</a><a name="13481"> </a><a name="13503" class="Keyword">where</a><a name="13508">
        </a><a name="13517" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟦_⟧′</a><a name="13521">  </a><a name="13523" class="Symbol">:</a><a name="13524"> </a><a name="13525" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="13529"> </a><a name="13530" class="Symbol">→</a><a name="13531"> </a><a name="13532" class="PrimitiveType">Set</a><a name="13535">
        </a><a name="13544" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟦</a><a name="13545"> </a><a name="13546" href="/2016/one-lambda-calculus-many-times/#2593" class="InductiveConstructor">El</a><a name="13548">  </a><a name="13550" href="/2016/one-lambda-calculus-many-times/#13550" class="Bound">A</a><a name="13551"> </a><a name="13552" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟧′</a><a name="13554"> </a><a name="13555" class="Symbol">=</a><a name="13556"> </a><a name="13557" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="13558"> </a><a name="13559" href="/2016/one-lambda-calculus-many-times/#13550" class="Bound">A</a><a name="13560"> </a><a name="13561" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="13562">
        </a><a name="13571" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟦</a><a name="13572"> </a><a name="13573" href="/2016/one-lambda-calculus-many-times/#13573" class="Bound">A</a><a name="13574"> </a><a name="13575" href="/2016/one-lambda-calculus-many-times/#2615" class="InductiveConstructor Operator">⇒</a><a name="13576"> </a><a name="13577" href="/2016/one-lambda-calculus-many-times/#13577" class="Bound">B</a><a name="13578"> </a><a name="13579" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟧′</a><a name="13581"> </a><a name="13582" class="Symbol">=</a><a name="13583"> </a><a name="13584" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟦</a><a name="13585"> </a><a name="13586" href="/2016/one-lambda-calculus-many-times/#13573" class="Bound">A</a><a name="13587"> </a><a name="13588" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟧′</a><a name="13590"> </a><a name="13591" class="Symbol">→</a><a name="13592"> </a><a name="13593" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟦</a><a name="13594"> </a><a name="13595" href="/2016/one-lambda-calculus-many-times/#13577" class="Bound">B</a><a name="13596"> </a><a name="13597" href="/2016/one-lambda-calculus-many-times/#13517" class="Function Operator">⟧′</a></pre>

In order to interpret sequents, we'll need an interpretation for the
antecedent. For this we'll create a type for *environments*, <a
class="Agda Datatype">Env</a>, which is indexed by a list of types, and
which stores values of the *interpretations* of those types:

<pre class="Agda">  <a name="13894" class="Keyword">infixr</a><a name="13900"> </a><a name="13901" class="Number">5</a><a name="13902"> _∷_

  </a><a name="13910" class="Keyword">data</a><a name="13914"> </a><a name="13915" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="13918"> </a><a name="13919" class="Symbol">:</a><a name="13920"> </a><a name="13921" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#669" class="Datatype" target="_blank">List</a><a name="13925"> </a><a name="13926" href="/2016/one-lambda-calculus-many-times/#2572" class="Datatype">Type</a><a name="13930"> </a><a name="13931" class="Symbol">→</a><a name="13932"> </a><a name="13933" class="PrimitiveType">Set</a><a name="13936"> </a><a name="13937" class="Keyword">where</a><a name="13942">
    </a><a name="13947" href="/2016/one-lambda-calculus-many-times/#13947" class="InductiveConstructor">[]</a><a name="13949">  </a><a name="13951" class="Symbol">:</a><a name="13952"> </a><a name="13953" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="13956"> </a><a name="13957" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#706" class="InductiveConstructor" target="_blank">[]</a><a name="13959">
    </a><a name="13964" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">_∷_</a><a name="13967"> </a><a name="13968" class="Symbol">:</a><a name="13969"> </a><a name="13999" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="14000"> </a><a name="14001" href="/2016/one-lambda-calculus-many-times/#13971" class="Bound">A</a><a name="14002"> </a><a name="14003" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="14004"> </a><a name="14005" class="Symbol">→</a><a name="14006"> </a><a name="14007" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="14010"> </a><a name="14011" href="/2016/one-lambda-calculus-many-times/#13982" class="Bound">Γ</a><a name="14012"> </a><a name="14013" class="Symbol">→</a><a name="14014"> </a><a name="14015" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="14018"> </a><a name="14019" class="Symbol">(</a><a name="14020" href="/2016/one-lambda-calculus-many-times/#13971" class="Bound">A</a><a name="14021"> </a><a name="14022" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="14023"> </a><a name="14024" href="/2016/one-lambda-calculus-many-times/#13982" class="Bound">Γ</a><a name="14025" class="Symbol">)</a></pre>

Using this, we can interpret sequents as functions from environments
to values:

<pre class="Agda">  <a name="14135" class="Keyword">instance</a><a name="14143">
    </a><a name="14148" href="/2016/one-lambda-calculus-many-times/#14148" class="Function">InterpretSequent</a><a name="14164"> </a><a name="14165" class="Symbol">:</a><a name="14166"> </a><a name="14167" href="/2016/one-lambda-calculus-many-times/#12395" class="Record">Interpret</a><a name="14176"> </a><a name="14177" href="/2016/one-lambda-calculus-many-times/#3878" class="Datatype">Sequent</a><a name="14184"> </a><a name="14185" class="PrimitiveType">Set</a><a name="14188">
    </a><a name="14193" href="/2016/one-lambda-calculus-many-times/#14148" class="Function">InterpretSequent</a><a name="14209"> </a><a name="14210" class="Symbol">=</a><a name="14211"> </a><a name="14212" class="Keyword">record</a><a name="14218"> </a><a name="14240" class="Keyword">where</a><a name="14245">
        </a><a name="14254" href="/2016/one-lambda-calculus-many-times/#14254" class="Function Operator">⟦_⟧′</a><a name="14258"> </a><a name="14259" class="Symbol">:</a><a name="14260"> </a><a name="14261" href="/2016/one-lambda-calculus-many-times/#3878" class="Datatype">Sequent</a><a name="14268"> </a><a name="14269" class="Symbol">→</a><a name="14270"> </a><a name="14271" class="PrimitiveType">Set</a><a name="14274">
        </a><a name="14283" href="/2016/one-lambda-calculus-many-times/#14254" class="Function Operator">⟦</a><a name="14284"> </a><a name="14285" href="/2016/one-lambda-calculus-many-times/#14285" class="Bound">Γ</a><a name="14286"> </a><a name="14287" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="14288"> </a><a name="14289" href="/2016/one-lambda-calculus-many-times/#14289" class="Bound">A</a><a name="14290"> </a><a name="14291" href="/2016/one-lambda-calculus-many-times/#14254" class="Function Operator">⟧′</a><a name="14293"> </a><a name="14294" class="Symbol">=</a><a name="14295"> </a><a name="14296" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="14299"> </a><a name="14300" href="/2016/one-lambda-calculus-many-times/#14285" class="Bound">Γ</a><a name="14301"> </a><a name="14302" class="Symbol">→</a><a name="14303"> </a><a name="14304" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="14305"> </a><a name="14306" href="/2016/one-lambda-calculus-many-times/#14289" class="Bound">A</a><a name="14307"> </a><a name="14308" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a></pre>

Let's get to interpreting terms! First off, variables. We can
interpret variables simply by looking them up in the environment:

<pre class="Agda">  <a name="14466" href="/2016/one-lambda-calculus-many-times/#14466" class="Function">lookup</a><a name="14472"> </a><a name="14473" class="Symbol">:</a><a name="14474"> </a><a name="14485" href="/2016/one-lambda-calculus-many-times/#14478" class="Bound">A</a><a name="14486"> </a><a name="14487" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="14488"> </a><a name="14489" href="/2016/one-lambda-calculus-many-times/#14480" class="Bound">Γ</a><a name="14490"> </a><a name="14491" class="Symbol">→</a><a name="14492"> </a><a name="14493" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="14496"> </a><a name="14497" href="/2016/one-lambda-calculus-many-times/#14480" class="Bound">Γ</a><a name="14498"> </a><a name="14499" class="Symbol">→</a><a name="14500"> </a><a name="14501" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="14502"> </a><a name="14503" href="/2016/one-lambda-calculus-many-times/#14478" class="Bound">A</a><a name="14504"> </a><a name="14505" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="14506">
  </a><a name="14509" href="/2016/one-lambda-calculus-many-times/#14466" class="Function">lookup</a><a name="14515"> </a><a name="14516" class="Symbol">(</a><a name="14517" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="14521">  </a><a name="14523" href="/2016/one-lambda-calculus-many-times/#14523" class="Bound">p</a><a name="14524" class="Symbol">)</a><a name="14525"> </a><a name="14526" class="Symbol">(</a><a name="14527" href="/2016/one-lambda-calculus-many-times/#14527" class="Bound">x</a><a name="14528"> </a><a name="14529" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="14530"> </a><a name="14531" class="Symbol">_)</a><a name="14533"> </a><a name="14534" class="Keyword">rewrite</a><a name="14541"> </a><a name="14542" href="/2016/one-lambda-calculus-many-times/#14523" class="Bound">p</a><a name="14543"> </a><a name="14544" class="Symbol">=</a><a name="14545"> </a><a name="14546" href="/2016/one-lambda-calculus-many-times/#14527" class="Bound">x</a><a name="14547">
  </a><a name="14550" href="/2016/one-lambda-calculus-many-times/#14466" class="Function">lookup</a><a name="14556"> </a><a name="14557" class="Symbol">(</a><a name="14558" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="14563"> </a><a name="14564" href="/2016/one-lambda-calculus-many-times/#14564" class="Bound">p</a><a name="14565" class="Symbol">)</a><a name="14566"> </a><a name="14567" class="Symbol">(_</a><a name="14569"> </a><a name="14570" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="14571"> </a><a name="14572" href="/2016/one-lambda-calculus-many-times/#14572" class="Bound">e</a><a name="14573" class="Symbol">)</a><a name="14574"> </a><a name="14575" class="Symbol">=</a><a name="14576"> </a><a name="14577" href="/2016/one-lambda-calculus-many-times/#14466" class="Function">lookup</a><a name="14583"> </a><a name="14584" href="/2016/one-lambda-calculus-many-times/#14564" class="Bound">p</a><a name="14585"> </a><a name="14586" href="/2016/one-lambda-calculus-many-times/#14572" class="Bound">e</a></pre>


(If you're wondering what we're rewriting by: the <a class="Agda
InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174">here</a>
constructor carries a small proof that the element at the top of the
list is *really* the element you were looking for.)

The translation for natural deduction proofs is, of course, completely
routine---we translate variables withs lookups, introductions by
abstractions and eliminations by applications:

<pre class="Agda">  <a name="15100" class="Keyword">instance</a><a name="15108">
    </a><a name="15113" href="/2016/one-lambda-calculus-many-times/#15113" class="Function">InterpretND</a><a name="15124"> </a><a name="15125" class="Symbol">:</a><a name="15126"> </a><a name="15135" href="/2016/one-lambda-calculus-many-times/#12395" class="Record">Interpret</a><a name="15144"> </a><a name="15145" class="Symbol">(</a><a name="15146" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="15148"> </a><a name="15149" href="/2016/one-lambda-calculus-many-times/#15130" class="Bound">S</a><a name="15150" class="Symbol">)</a><a name="15151"> </a><a name="15152" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="15153"> </a><a name="15154" href="/2016/one-lambda-calculus-many-times/#15130" class="Bound">S</a><a name="15155"> </a><a name="15156" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="15157">
    </a><a name="15162" href="/2016/one-lambda-calculus-many-times/#15113" class="Function">InterpretND</a><a name="15173"> </a><a name="15174" class="Symbol">=</a><a name="15175"> </a><a name="15176" class="Keyword">record</a><a name="15182"> </a><a name="15204" class="Keyword">where</a><a name="15209">
        </a><a name="15218" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟦_⟧′</a><a name="15222"> </a><a name="15223" class="Symbol">:</a><a name="15224"> </a><a name="15233" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="15235"> </a><a name="15236" href="/2016/one-lambda-calculus-many-times/#15228" class="Bound">S</a><a name="15237"> </a><a name="15238" class="Symbol">→</a><a name="15239"> </a><a name="15240" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="15241"> </a><a name="15242" href="/2016/one-lambda-calculus-many-times/#15228" class="Bound">S</a><a name="15243"> </a><a name="15244" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="15245">
        </a><a name="15254" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟦</a><a name="15255"> </a><a name="15256" href="/2016/one-lambda-calculus-many-times/#5324" class="InductiveConstructor">ax</a><a name="15258"> </a><a name="15259" href="/2016/one-lambda-calculus-many-times/#15259" class="Bound">p</a><a name="15260">   </a><a name="15263" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟧′</a><a name="15265"> </a><a name="15266" href="/2016/one-lambda-calculus-many-times/#15266" class="Bound">e</a><a name="15267"> </a><a name="15268" class="Symbol">=</a><a name="15269"> </a><a name="15270" href="/2016/one-lambda-calculus-many-times/#14466" class="Function">lookup</a><a name="15276"> </a><a name="15277" href="/2016/one-lambda-calculus-many-times/#15259" class="Bound">p</a><a name="15278"> </a><a name="15279" href="/2016/one-lambda-calculus-many-times/#15266" class="Bound">e</a><a name="15280">
        </a><a name="15289" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟦</a><a name="15290"> </a><a name="15291" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="15293"> </a><a name="15294" href="/2016/one-lambda-calculus-many-times/#15294" class="Bound">f</a><a name="15295">   </a><a name="15298" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟧′</a><a name="15300"> </a><a name="15301" href="/2016/one-lambda-calculus-many-times/#15301" class="Bound">e</a><a name="15302"> </a><a name="15303" class="Symbol">=</a><a name="15304"> </a><a name="15305" class="Symbol">λ</a><a name="15306"> </a><a name="15307" href="/2016/one-lambda-calculus-many-times/#15307" class="Bound">x</a><a name="15308"> </a><a name="15309" class="Symbol">→</a><a name="15310"> </a><a name="15311" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟦</a><a name="15312"> </a><a name="15313" href="/2016/one-lambda-calculus-many-times/#15294" class="Bound">f</a><a name="15314"> </a><a name="15315" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟧′</a><a name="15317"> </a><a name="15318" class="Symbol">(</a><a name="15319" href="/2016/one-lambda-calculus-many-times/#15307" class="Bound">x</a><a name="15320"> </a><a name="15321" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="15322"> </a><a name="15323" href="/2016/one-lambda-calculus-many-times/#15301" class="Bound">e</a><a name="15324" class="Symbol">)</a><a name="15325">
        </a><a name="15334" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟦</a><a name="15335"> </a><a name="15336" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="15338"> </a><a name="15339" href="/2016/one-lambda-calculus-many-times/#15339" class="Bound">f</a><a name="15340"> </a><a name="15341" href="/2016/one-lambda-calculus-many-times/#15341" class="Bound">g</a><a name="15342"> </a><a name="15343" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟧′</a><a name="15345"> </a><a name="15346" href="/2016/one-lambda-calculus-many-times/#15346" class="Bound">e</a><a name="15347"> </a><a name="15348" class="Symbol">=</a><a name="15349"> </a><a name="15350" class="Symbol">(</a><a name="15351" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟦</a><a name="15352"> </a><a name="15353" href="/2016/one-lambda-calculus-many-times/#15339" class="Bound">f</a><a name="15354"> </a><a name="15355" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟧′</a><a name="15357"> </a><a name="15358" href="/2016/one-lambda-calculus-many-times/#15346" class="Bound">e</a><a name="15359" class="Symbol">)</a><a name="15360"> </a><a name="15361" class="Symbol">(</a><a name="15362" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟦</a><a name="15363"> </a><a name="15364" href="/2016/one-lambda-calculus-many-times/#15341" class="Bound">g</a><a name="15365"> </a><a name="15366" href="/2016/one-lambda-calculus-many-times/#15218" class="Function Operator">⟧′</a><a name="15368"> </a><a name="15369" href="/2016/one-lambda-calculus-many-times/#15346" class="Bound">e</a><a name="15370" class="Symbol">)</a></pre>

Hooray! And even better,  as a corollary, we immediately obtain a
translation from sequent calculus into Agda:

<pre class="Agda">  <a name="15511" class="Keyword">instance</a><a name="15519">
    </a><a name="15524" href="/2016/one-lambda-calculus-many-times/#15524" class="Function">InterpretSC</a><a name="15535"> </a><a name="15536" class="Symbol">:</a><a name="15537"> </a><a name="15546" href="/2016/one-lambda-calculus-many-times/#12395" class="Record">Interpret</a><a name="15555"> </a><a name="15556" class="Symbol">(</a><a name="15557" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="15559"> </a><a name="15560" href="/2016/one-lambda-calculus-many-times/#15541" class="Bound">S</a><a name="15561" class="Symbol">)</a><a name="15562"> </a><a name="15563" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="15564"> </a><a name="15565" href="/2016/one-lambda-calculus-many-times/#15541" class="Bound">S</a><a name="15566"> </a><a name="15567" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="15568">
    </a><a name="15573" href="/2016/one-lambda-calculus-many-times/#15524" class="Function">InterpretSC</a><a name="15584"> </a><a name="15585" class="Symbol">=</a><a name="15586"> </a><a name="15587" class="Keyword">record</a><a name="15593"> </a></pre>

Which means that we've now implemented the following functions:

$$
    \begin{array}{ccc}
    ND & \rightarrow & Agda \\
                            \\
    \updownarrow            \\
                            \\
    SC                      \\
    \end{array}
$$



If you are looking for more reading on this topic, I can recommend the
highly readible *[Lambda terms for natural deduction, sequent calculus
and cut elimination][barendregt]* by Henk Barendregt and Silvia Ghilezan.

Next time, I'll talk about Gentzen's LJ, which has explicit structural
rules, and variations which use other, non-list structures as the
antecedent.

---

[agdatutorial]: http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
[noshortcuts]: https://gergo.erdi.hu/blog/2013-05-01-simply_typed_lambda_calculus_in_agda,_without_shortcuts/
[byexample]: http://mazzo.li/posts/Lambda.html
[barendregt]: http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=44279#

[^imports]: This is a good time to note that I'm not showing any of
    the import statements. If you wish to see them, they're there in
    the HTML source. However, it may be much easier to click the
    symbol that confuses you---that should take you directly to its
    definition in the standard library.


<div class="hidden">
### BONUS!
### The Limit of Intensional Type Theory

Boop.

<pre class="Agda">  <a name="17005" href="/2016/one-lambda-calculus-many-times/#17005" class="Function">ax₀′</a><a name="17009"> </a><a name="17010" class="Symbol">:</a><a name="17011"> </a><a name="17022" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="17025"> </a><a name="17026" class="Symbol">(</a><a name="17027" href="/2016/one-lambda-calculus-many-times/#17015" class="Bound">A</a><a name="17028"> </a><a name="17029" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="17030"> </a><a name="17031" href="/2016/one-lambda-calculus-many-times/#17017" class="Bound">Γ</a><a name="17032" class="Symbol">)</a><a name="17033"> </a><a name="17034" class="Symbol">→</a><a name="17035"> </a><a name="17036" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="17037"> </a><a name="17038" href="/2016/one-lambda-calculus-many-times/#17015" class="Bound">A</a><a name="17039"> </a><a name="17040" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="17041">
  </a><a name="17044" href="/2016/one-lambda-calculus-many-times/#17005" class="Function">ax₀′</a><a name="17048"> </a><a name="17049" class="Symbol">=</a><a name="17050"> </a><a name="17051" href="/2016/one-lambda-calculus-many-times/#14466" class="Function">lookup</a><a name="17057"> </a><a name="17058" class="Symbol">(</a><a name="17059" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="17063"> </a><a name="17064" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="17068" class="Symbol">)</a><a name="17069">

  </a><a name="17073" href="/2016/one-lambda-calculus-many-times/#17073" class="Function">⇒i′</a><a name="17076"> </a><a name="17077" class="Symbol">:</a><a name="17078"> </a><a name="17099" class="Symbol">(</a><a name="17100" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="17103"> </a><a name="17104" class="Symbol">(</a><a name="17105" href="/2016/one-lambda-calculus-many-times/#17082" class="Bound">A</a><a name="17106"> </a><a name="17107" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="17108"> </a><a name="17109" href="/2016/one-lambda-calculus-many-times/#17084" class="Bound">Γ</a><a name="17110" class="Symbol">)</a><a name="17111"> </a><a name="17112" class="Symbol">→</a><a name="17113"> </a><a name="17114" href="/2016/one-lambda-calculus-many-times/#17088" class="Bound">B</a><a name="17115" class="Symbol">)</a><a name="17116"> </a><a name="17117" class="Symbol">→</a><a name="17118"> </a><a name="17119" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="17122"> </a><a name="17123" href="/2016/one-lambda-calculus-many-times/#17084" class="Bound">Γ</a><a name="17124"> </a><a name="17125" class="Symbol">→</a><a name="17126"> </a><a name="17127" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="17128"> </a><a name="17129" href="/2016/one-lambda-calculus-many-times/#17082" class="Bound">A</a><a name="17130"> </a><a name="17131" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="17132"> </a><a name="17133" class="Symbol">→</a><a name="17134"> </a><a name="17135" href="/2016/one-lambda-calculus-many-times/#17088" class="Bound">B</a><a name="17136">
  </a><a name="17139" href="/2016/one-lambda-calculus-many-times/#17073" class="Function">⇒i′</a><a name="17142"> </a><a name="17143" href="/2016/one-lambda-calculus-many-times/#17143" class="Bound">f</a><a name="17144"> </a><a name="17145" href="/2016/one-lambda-calculus-many-times/#17145" class="Bound">e</a><a name="17146"> </a><a name="17147" href="/2016/one-lambda-calculus-many-times/#17147" class="Bound">x</a><a name="17148"> </a><a name="17149" class="Symbol">=</a><a name="17150"> </a><a name="17151" href="/2016/one-lambda-calculus-many-times/#17143" class="Bound">f</a><a name="17152"> </a><a name="17153" class="Symbol">(</a><a name="17154" href="/2016/one-lambda-calculus-many-times/#17147" class="Bound">x</a><a name="17155"> </a><a name="17156" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="17157"> </a><a name="17158" href="/2016/one-lambda-calculus-many-times/#17145" class="Bound">e</a><a name="17159" class="Symbol">)</a><a name="17160">

  </a><a name="17164" href="/2016/one-lambda-calculus-many-times/#17164" class="Function">weak′</a><a name="17169"> </a><a name="17170" class="Symbol">:</a><a name="17171"> </a><a name="17192" class="Symbol">(</a><a name="17193" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="17196"> </a><a name="17197" href="/2016/one-lambda-calculus-many-times/#17177" class="Bound">Γ</a><a name="17198"> </a><a name="17199" class="Symbol">→</a><a name="17200"> </a><a name="17201" href="/2016/one-lambda-calculus-many-times/#17181" class="Bound">B</a><a name="17202" class="Symbol">)</a><a name="17203"> </a><a name="17204" class="Symbol">→</a><a name="17205"> </a><a name="17206" href="/2016/one-lambda-calculus-many-times/#13915" class="Datatype">Env</a><a name="17209"> </a><a name="17210" class="Symbol">(</a><a name="17211" href="/2016/one-lambda-calculus-many-times/#17175" class="Bound">A</a><a name="17212"> </a><a name="17213" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="17214"> </a><a name="17215" href="/2016/one-lambda-calculus-many-times/#17177" class="Bound">Γ</a><a name="17216" class="Symbol">)</a><a name="17217"> </a><a name="17218" class="Symbol">→</a><a name="17219"> </a><a name="17220" href="/2016/one-lambda-calculus-many-times/#17181" class="Bound">B</a><a name="17221">
  </a><a name="17224" href="/2016/one-lambda-calculus-many-times/#17164" class="Function">weak′</a><a name="17229"> </a><a name="17230" href="/2016/one-lambda-calculus-many-times/#17230" class="Bound">f</a><a name="17231"> </a><a name="17232" class="Symbol">(</a><a name="17233" href="/2016/one-lambda-calculus-many-times/#17233" class="Bound">x</a><a name="17234"> </a><a name="17235" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="17236"> </a><a name="17237" href="/2016/one-lambda-calculus-many-times/#17237" class="Bound">e</a><a name="17238" class="Symbol">)</a><a name="17239"> </a><a name="17240" class="Symbol">=</a><a name="17241"> </a><a name="17242" href="/2016/one-lambda-calculus-many-times/#17230" class="Bound">f</a><a name="17243"> </a><a name="17244" href="/2016/one-lambda-calculus-many-times/#17237" class="Bound">e</a></pre>

Boop.

<pre class="Agda">  <a name="17280" class="Keyword">instance</a><a name="17288">
    </a><a name="17293" href="/2016/one-lambda-calculus-many-times/#17293" class="Function">InterpretSC′</a><a name="17305"> </a><a name="17306" class="Symbol">:</a><a name="17307"> </a><a name="17316" href="/2016/one-lambda-calculus-many-times/#12395" class="Record">Interpret</a><a name="17325"> </a><a name="17326" class="Symbol">(</a><a name="17327" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="17329"> </a><a name="17330" href="/2016/one-lambda-calculus-many-times/#17311" class="Bound">S</a><a name="17331" class="Symbol">)</a><a name="17332"> </a><a name="17333" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="17334"> </a><a name="17335" href="/2016/one-lambda-calculus-many-times/#17311" class="Bound">S</a><a name="17336"> </a><a name="17337" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="17338">
    </a><a name="17343" href="/2016/one-lambda-calculus-many-times/#17293" class="Function">InterpretSC′</a><a name="17355"> </a><a name="17356" class="Symbol">=</a><a name="17357"> </a><a name="17358" class="Keyword">record</a><a name="17364"> </a><a name="17386" class="Keyword">where</a><a name="17391">
        </a><a name="17400" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦_⟧′</a><a name="17404"> </a><a name="17405" class="Symbol">:</a><a name="17406"> </a><a name="17415" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="17417"> </a><a name="17418" href="/2016/one-lambda-calculus-many-times/#17410" class="Bound">S</a><a name="17419"> </a><a name="17420" class="Symbol">→</a><a name="17421"> </a><a name="17422" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="17423"> </a><a name="17424" href="/2016/one-lambda-calculus-many-times/#17410" class="Bound">S</a><a name="17425"> </a><a name="17426" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="17427">
        </a><a name="17436" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17437"> </a><a name="17438" href="/2016/one-lambda-calculus-many-times/#9742" class="InductiveConstructor">ax</a><a name="17440">  </a><a name="17442" href="/2016/one-lambda-calculus-many-times/#17442" class="Bound">p</a><a name="17443">   </a><a name="17446" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17448"> </a><a name="17449" href="/2016/one-lambda-calculus-many-times/#17449" class="Bound">e</a><a name="17450"> </a><a name="17451" class="Symbol">=</a><a name="17452"> </a><a name="17453" href="/2016/one-lambda-calculus-many-times/#14466" class="Function">lookup</a><a name="17459"> </a><a name="17460" href="/2016/one-lambda-calculus-many-times/#17442" class="Bound">p</a><a name="17461"> </a><a name="17462" href="/2016/one-lambda-calculus-many-times/#17449" class="Bound">e</a><a name="17463">
        </a><a name="17472" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17473"> </a><a name="17474" href="/2016/one-lambda-calculus-many-times/#9783" class="InductiveConstructor">cut</a><a name="17477"> </a><a name="17478" href="/2016/one-lambda-calculus-many-times/#17478" class="Bound">f</a><a name="17479"> </a><a name="17480" href="/2016/one-lambda-calculus-many-times/#17480" class="Bound">g</a><a name="17481"> </a><a name="17482" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17484"> </a><a name="17485" href="/2016/one-lambda-calculus-many-times/#17485" class="Bound">e</a><a name="17486"> </a><a name="17487" class="Symbol">=</a><a name="17488"> </a><a name="17489" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17490"> </a><a name="17491" href="/2016/one-lambda-calculus-many-times/#17480" class="Bound">g</a><a name="17492"> </a><a name="17493" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17495"> </a><a name="17496" class="Symbol">(</a><a name="17497" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17498"> </a><a name="17499" href="/2016/one-lambda-calculus-many-times/#17478" class="Bound">f</a><a name="17500"> </a><a name="17501" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17503"> </a><a name="17504" href="/2016/one-lambda-calculus-many-times/#17485" class="Bound">e</a><a name="17505"> </a><a name="17506" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="17507"> </a><a name="17508" href="/2016/one-lambda-calculus-many-times/#17485" class="Bound">e</a><a name="17509" class="Symbol">)</a><a name="17510">
        </a><a name="17519" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17520"> </a><a name="17521" href="/2016/one-lambda-calculus-many-times/#9842" class="InductiveConstructor">⇒l</a><a name="17523">  </a><a name="17525" href="/2016/one-lambda-calculus-many-times/#17525" class="Bound">f</a><a name="17526"> </a><a name="17527" href="/2016/one-lambda-calculus-many-times/#17527" class="Bound">g</a><a name="17528"> </a><a name="17529" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17531"> </a><a name="17532" href="/2016/one-lambda-calculus-many-times/#17532" class="Bound">e</a><a name="17533"> </a><a name="17534" class="Symbol">=</a><a name="17535"> </a><a name="17536" class="Symbol">(</a><a name="17537" href="/2016/one-lambda-calculus-many-times/#17164" class="Function">weak′</a><a name="17542"> </a><a name="17543" class="Symbol">(</a><a name="17544" href="/2016/one-lambda-calculus-many-times/#17073" class="Function">⇒i′</a><a name="17547"> </a><a name="17548" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17549"> </a><a name="17550" href="/2016/one-lambda-calculus-many-times/#17527" class="Bound">g</a><a name="17551"> </a><a name="17552" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17554" class="Symbol">))</a><a name="17556"> </a><a name="17557" href="/2016/one-lambda-calculus-many-times/#17532" class="Bound">e</a><a name="17558"> </a><a name="17559" class="Symbol">((</a><a name="17561" href="/2016/one-lambda-calculus-many-times/#17005" class="Function">ax₀′</a><a name="17565"> </a><a name="17566" href="/2016/one-lambda-calculus-many-times/#17532" class="Bound">e</a><a name="17567" class="Symbol">)</a><a name="17568"> </a><a name="17569" class="Symbol">(</a><a name="17570" href="/2016/one-lambda-calculus-many-times/#17164" class="Function">weak′</a><a name="17575"> </a><a name="17576" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17577"> </a><a name="17578" href="/2016/one-lambda-calculus-many-times/#17525" class="Bound">f</a><a name="17579"> </a><a name="17580" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17582"> </a><a name="17583" href="/2016/one-lambda-calculus-many-times/#17532" class="Bound">e</a><a name="17584" class="Symbol">))</a><a name="17586">
        </a><a name="17595" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17596"> </a><a name="17597" href="/2016/one-lambda-calculus-many-times/#9909" class="InductiveConstructor">⇒r</a><a name="17599">  </a><a name="17601" href="/2016/one-lambda-calculus-many-times/#17601" class="Bound">f</a><a name="17602">   </a><a name="17605" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17607"> </a><a name="17608" href="/2016/one-lambda-calculus-many-times/#17608" class="Bound">e</a><a name="17609"> </a><a name="17610" class="Symbol">=</a><a name="17611"> </a><a name="17612" class="Symbol">λ</a><a name="17613"> </a><a name="17614" href="/2016/one-lambda-calculus-many-times/#17614" class="Bound">x</a><a name="17615"> </a><a name="17616" class="Symbol">→</a><a name="17617"> </a><a name="17618" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟦</a><a name="17619"> </a><a name="17620" href="/2016/one-lambda-calculus-many-times/#17601" class="Bound">f</a><a name="17621"> </a><a name="17622" href="/2016/one-lambda-calculus-many-times/#17400" class="Function Operator">⟧′</a><a name="17624"> </a><a name="17625" class="Symbol">(</a><a name="17626" href="/2016/one-lambda-calculus-many-times/#17614" class="Bound">x</a><a name="17627"> </a><a name="17628" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="17629"> </a><a name="17630" href="/2016/one-lambda-calculus-many-times/#17608" class="Bound">e</a><a name="17631" class="Symbol">)</a></pre>

Boop.

<pre class="Agda">  <a name="17667" class="Keyword">module</a><a name="17673"> </a><a name="17674" href="/2016/one-lambda-calculus-many-times/#17674" class="Module">⟦ND⟧⇔⟦SC⟧</a><a name="17683"> </a><a name="17684" class="Keyword">where</a><a name="17689">

    </a><a name="17695" href="/2016/one-lambda-calculus-many-times/#17695" class="Function">⟹</a><a name="17696"> </a><a name="17697" class="Symbol">:</a><a name="17698"> </a><a name="17705" class="Symbol">(</a><a name="17706" href="/2016/one-lambda-calculus-many-times/#17706" class="Bound">f</a><a name="17707"> </a><a name="17708" class="Symbol">:</a><a name="17709"> </a><a name="17710" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="17712"> </a><a name="17713" href="/2016/one-lambda-calculus-many-times/#17702" class="Bound">S</a><a name="17714" class="Symbol">)</a><a name="17715"> </a><a name="17716" class="Symbol">→</a><a name="17717"> </a><a name="17718" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="17719"> </a><a name="17720" href="/2016/one-lambda-calculus-many-times/#17706" class="Bound">f</a><a name="17721"> </a><a name="17722" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="17723"> </a><a name="17724" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="17725"> </a><a name="17726" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="17727"> </a><a name="17728" href="/2016/one-lambda-calculus-many-times/#10513" class="Function">ND⇔SC.⟹</a><a name="17735"> </a><a name="17736" href="/2016/one-lambda-calculus-many-times/#17706" class="Bound">f</a><a name="17737"> </a><a name="17738" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="17739">
    </a><a name="17744" href="/2016/one-lambda-calculus-many-times/#17695" class="Function">⟹</a><a name="17745"> </a><a name="17746" class="Symbol">(</a><a name="17747" href="/2016/one-lambda-calculus-many-times/#5324" class="InductiveConstructor">ax</a><a name="17749"> </a><a name="17750" class="Symbol">_)</a><a name="17752">   </a><a name="17755" class="Symbol">=</a><a name="17756"> </a><a name="17757" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="17761">
    </a><a name="17766" href="/2016/one-lambda-calculus-many-times/#17695" class="Function">⟹</a><a name="17767"> </a><a name="17768" class="Symbol">(</a><a name="17769" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="17771"> </a><a name="17772" href="/2016/one-lambda-calculus-many-times/#17772" class="Bound">f</a><a name="17773" class="Symbol">)</a><a name="17774">   </a><a name="17777" class="Symbol">=</a><a name="17778"> </a><a name="17779" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1036" class="Function" target="_blank">cong</a><a name="17783">  </a><a name="17785" class="Symbol">(λ</a><a name="17787"> </a><a name="17788" href="/2016/one-lambda-calculus-many-times/#17788" class="Bound">f</a><a name="17789"> </a><a name="17790" href="/2016/one-lambda-calculus-many-times/#17790" class="Bound">e</a><a name="17791"> </a><a name="17792" href="/2016/one-lambda-calculus-many-times/#17792" class="Bound">x</a><a name="17793"> </a><a name="17794" class="Symbol">→</a><a name="17795"> </a><a name="17796" href="/2016/one-lambda-calculus-many-times/#17788" class="Bound">f</a><a name="17797"> </a><a name="17798" class="Symbol">(</a><a name="17799" href="/2016/one-lambda-calculus-many-times/#17792" class="Bound">x</a><a name="17800"> </a><a name="17801" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="17802"> </a><a name="17803" href="/2016/one-lambda-calculus-many-times/#17790" class="Bound">e</a><a name="17804" class="Symbol">))</a><a name="17806"> </a><a name="17807" class="Symbol">(</a><a name="17808" href="/2016/one-lambda-calculus-many-times/#17695" class="Function">⟹</a><a name="17809"> </a><a name="17810" href="/2016/one-lambda-calculus-many-times/#17772" class="Bound">f</a><a name="17811" class="Symbol">)</a><a name="17812">
    </a><a name="17817" href="/2016/one-lambda-calculus-many-times/#17695" class="Function">⟹</a><a name="17818"> </a><a name="17819" class="Symbol">(</a><a name="17820" href="/2016/one-lambda-calculus-many-times/#5411" class="InductiveConstructor">⇒e</a><a name="17822"> </a><a name="17823" href="/2016/one-lambda-calculus-many-times/#17823" class="Bound">f</a><a name="17824"> </a><a name="17825" href="/2016/one-lambda-calculus-many-times/#17825" class="Bound">g</a><a name="17826" class="Symbol">)</a><a name="17827"> </a><a name="17828" class="Symbol">=</a><a name="17829"> </a><a name="17830" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1274" class="Function" target="_blank">cong₂</a><a name="17835"> </a><a name="17836" class="Symbol">(λ</a><a name="17838"> </a><a name="17839" href="/2016/one-lambda-calculus-many-times/#17839" class="Bound">f</a><a name="17840"> </a><a name="17841" href="/2016/one-lambda-calculus-many-times/#17841" class="Bound">g</a><a name="17842"> </a><a name="17843" href="/2016/one-lambda-calculus-many-times/#17843" class="Bound">e</a><a name="17844"> </a><a name="17845" class="Symbol">→</a><a name="17846"> </a><a name="17847" href="/2016/one-lambda-calculus-many-times/#17839" class="Bound">f</a><a name="17848"> </a><a name="17849" href="/2016/one-lambda-calculus-many-times/#17843" class="Bound">e</a><a name="17850"> </a><a name="17851" class="Symbol">(</a><a name="17852" href="/2016/one-lambda-calculus-many-times/#17841" class="Bound">g</a><a name="17853"> </a><a name="17854" href="/2016/one-lambda-calculus-many-times/#17843" class="Bound">e</a><a name="17855" class="Symbol">))</a><a name="17857"> </a><a name="17858" class="Symbol">(</a><a name="17859" href="/2016/one-lambda-calculus-many-times/#17695" class="Function">⟹</a><a name="17860"> </a><a name="17861" href="/2016/one-lambda-calculus-many-times/#17823" class="Bound">f</a><a name="17862" class="Symbol">)</a><a name="17863"> </a><a name="17864" class="Symbol">(</a><a name="17865" href="/2016/one-lambda-calculus-many-times/#17695" class="Function">⟹</a><a name="17866"> </a><a name="17867" href="/2016/one-lambda-calculus-many-times/#17825" class="Bound">g</a><a name="17868" class="Symbol">)</a></pre>

Boop.

<pre class="Agda">    <a name="17906" class="Keyword">open</a><a name="17910"> </a><a name="17911" class="Keyword">import</a><a name="17917"> </a><a name="17918" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.TrustMe.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality.TrustMe</a><a name="17963"> </a><a name="17964" class="Keyword">renaming</a><a name="17972"> </a><a name="17973" class="Symbol">(</a><a name="17974">trustMe </a><a name="17982" class="Symbol">to</a><a name="17984"> ???</a><a name="17988" class="Symbol">)</a></pre>

<pre class="Agda">    <a name="18019" href="/2016/one-lambda-calculus-many-times/#18019" class="Function">⟸</a><a name="18020"> </a><a name="18021" class="Symbol">:</a><a name="18022"> </a><a name="18029" class="Symbol">(</a><a name="18030" href="/2016/one-lambda-calculus-many-times/#18030" class="Bound">f</a><a name="18031"> </a><a name="18032" class="Symbol">:</a><a name="18033"> </a><a name="18034" href="/2016/one-lambda-calculus-many-times/#9712" class="Datatype Operator">SC</a><a name="18036"> </a><a name="18037" href="/2016/one-lambda-calculus-many-times/#18026" class="Bound">S</a><a name="18038" class="Symbol">)</a><a name="18039"> </a><a name="18040" class="Symbol">→</a><a name="18041"> </a><a name="18042" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18043"> </a><a name="18044" href="/2016/one-lambda-calculus-many-times/#18030" class="Bound">f</a><a name="18045"> </a><a name="18046" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="18047"> </a><a name="18048" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="18049"> </a><a name="18050" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18051"> </a><a name="18052" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">ND⇔SC.⟸</a><a name="18059"> </a><a name="18060" href="/2016/one-lambda-calculus-many-times/#18030" class="Bound">f</a><a name="18061"> </a><a name="18062" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="18063">
    </a><a name="18068" href="/2016/one-lambda-calculus-many-times/#18019" class="Function">⟸</a><a name="18069"> </a><a name="18070" class="Symbol">(</a><a name="18071" href="/2016/one-lambda-calculus-many-times/#9742" class="InductiveConstructor">ax</a><a name="18073">  </a><a name="18075" class="Symbol">_)</a><a name="18077">   </a><a name="18080" class="Symbol">=</a><a name="18081"> </a><a name="18082" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="18086">
    </a><a name="18091" href="/2016/one-lambda-calculus-many-times/#18019" class="Function">⟸</a><a name="18092"> </a><a name="18093" class="Symbol">(</a><a name="18094" href="/2016/one-lambda-calculus-many-times/#9783" class="InductiveConstructor">cut</a><a name="18097"> </a><a name="18098" href="/2016/one-lambda-calculus-many-times/#18098" class="Bound">f</a><a name="18099"> </a><a name="18100" href="/2016/one-lambda-calculus-many-times/#18100" class="Bound">g</a><a name="18101" class="Symbol">)</a><a name="18102"> </a><a name="18103" class="Symbol">=</a><a name="18104"> </a><a name="18105" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1274" class="Function" target="_blank">cong₂</a><a name="18110"> </a><a name="18111" class="Symbol">(λ</a><a name="18113"> </a><a name="18114" href="/2016/one-lambda-calculus-many-times/#18114" class="Bound">f</a><a name="18115"> </a><a name="18116" href="/2016/one-lambda-calculus-many-times/#18116" class="Bound">g</a><a name="18117"> </a><a name="18118" href="/2016/one-lambda-calculus-many-times/#18118" class="Bound">e</a><a name="18119"> </a><a name="18120" class="Symbol">→</a><a name="18121"> </a><a name="18122" href="/2016/one-lambda-calculus-many-times/#18116" class="Bound">g</a><a name="18123"> </a><a name="18124" class="Symbol">(</a><a name="18125" href="/2016/one-lambda-calculus-many-times/#18114" class="Bound">f</a><a name="18126"> </a><a name="18127" href="/2016/one-lambda-calculus-many-times/#18118" class="Bound">e</a><a name="18128"> </a><a name="18129" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="18130"> </a><a name="18131" href="/2016/one-lambda-calculus-many-times/#18118" class="Bound">e</a><a name="18132" class="Symbol">))</a><a name="18134"> </a><a name="18135" class="Symbol">(</a><a name="18136" href="/2016/one-lambda-calculus-many-times/#18019" class="Function">⟸</a><a name="18137"> </a><a name="18138" href="/2016/one-lambda-calculus-many-times/#18098" class="Bound">f</a><a name="18139" class="Symbol">)</a><a name="18140"> </a><a name="18141" class="Symbol">(</a><a name="18142" href="/2016/one-lambda-calculus-many-times/#18019" class="Function">⟸</a><a name="18143"> </a><a name="18144" href="/2016/one-lambda-calculus-many-times/#18100" class="Bound">g</a><a name="18145" class="Symbol">)</a><a name="18146">
    </a><a name="18151" href="/2016/one-lambda-calculus-many-times/#18019" class="Function">⟸</a><a name="18152"> </a><a name="18153" class="Symbol">(</a><a name="18154" href="/2016/one-lambda-calculus-many-times/#9842" class="InductiveConstructor">⇒l</a><a name="18156">  </a><a name="18158" href="/2016/one-lambda-calculus-many-times/#18158" class="Bound">f</a><a name="18159"> </a><a name="18160" href="/2016/one-lambda-calculus-many-times/#18160" class="Bound">g</a><a name="18161" class="Symbol">)</a><a name="18162"> </a><a name="18163" class="Symbol">=</a><a name="18164"> </a><a name="18165" href="/2016/one-lambda-calculus-many-times/#18188" class="Function">lem</a><a name="18168">
      </a><a name="18175" class="Keyword">where</a><a name="18180">

      </a><a name="18188" href="/2016/one-lambda-calculus-many-times/#18188" class="Function">lem</a><a name="18191"> </a><a name="18192" class="Symbol">:</a><a name="18193"> </a><a name="18194" class="Symbol">(λ</a><a name="18196"> </a><a name="18197" href="/2016/one-lambda-calculus-many-times/#18197" class="Bound">e</a><a name="18198"> </a><a name="18199" class="Symbol">→</a><a name="18200"> </a><a name="18201" class="Symbol">(</a><a name="18202"> </a><a name="18203" href="/2016/one-lambda-calculus-many-times/#17164" class="Function">weak′</a><a name="18208"> </a><a name="18209" class="Symbol">(</a><a name="18210" href="/2016/one-lambda-calculus-many-times/#17073" class="Function">⇒i′</a><a name="18213"> </a><a name="18214" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18215"> </a><a name="18216" href="/2016/one-lambda-calculus-many-times/#18160" class="Bound">g</a><a name="18217"> </a><a name="18218" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="18219"> </a><a name="18220" class="Symbol">))</a><a name="18222"> </a><a name="18223" href="/2016/one-lambda-calculus-many-times/#18197" class="Bound">e</a><a name="18224">
                       </a><a name="18248" class="Symbol">(</a><a name="18249" href="/2016/one-lambda-calculus-many-times/#17005" class="Function">ax₀′</a><a name="18253"> </a><a name="18254" href="/2016/one-lambda-calculus-many-times/#18197" class="Bound">e</a><a name="18255"> </a><a name="18256" class="Symbol">(</a><a name="18257" href="/2016/one-lambda-calculus-many-times/#17164" class="Function">weak′</a><a name="18262"> </a><a name="18263" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18264"> </a><a name="18265" href="/2016/one-lambda-calculus-many-times/#18158" class="Bound">f</a><a name="18266"> </a><a name="18267" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="18268"> </a><a name="18269" href="/2016/one-lambda-calculus-many-times/#18197" class="Bound">e</a><a name="18270" class="Symbol">)))</a><a name="18273">

          </a><a name="18285" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="18286"> </a><a name="18287" class="Symbol">(λ</a><a name="18289"> </a><a name="18290" href="/2016/one-lambda-calculus-many-times/#18290" class="Bound">e</a><a name="18291"> </a><a name="18292" class="Symbol">→</a><a name="18293"> </a><a name="18294" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18295"> </a><a name="18296" href="/2016/one-lambda-calculus-many-times/#8526" class="Function">weak</a><a name="18300"> </a><a name="18301" class="Symbol">(</a><a name="18302" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="18304"> </a><a name="18305" class="Symbol">(</a><a name="18306" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">ND⇔SC.⟸</a><a name="18313"> </a><a name="18314" href="/2016/one-lambda-calculus-many-times/#18160" class="Bound">g</a><a name="18315" class="Symbol">))</a><a name="18317"> </a><a name="18318" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="18319"> </a><a name="18320" href="/2016/one-lambda-calculus-many-times/#18290" class="Bound">e</a><a name="18321">
                       </a><a name="18345" class="Symbol">(</a><a name="18346" href="/2016/one-lambda-calculus-many-times/#17005" class="Function">ax₀′</a><a name="18350"> </a><a name="18351" href="/2016/one-lambda-calculus-many-times/#18290" class="Bound">e</a><a name="18352"> </a><a name="18353" class="Symbol">(</a><a name="18354" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18355"> </a><a name="18356" href="/2016/one-lambda-calculus-many-times/#8526" class="Function">weak</a><a name="18360"> </a><a name="18361" class="Symbol">(</a><a name="18362" href="/2016/one-lambda-calculus-many-times/#10636" class="Function">ND⇔SC.⟸</a><a name="18369"> </a><a name="18370" href="/2016/one-lambda-calculus-many-times/#18158" class="Bound">f</a><a name="18371" class="Symbol">)</a><a name="18372"> </a><a name="18373" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="18374"> </a><a name="18375" href="/2016/one-lambda-calculus-many-times/#18290" class="Bound">e</a><a name="18376" class="Symbol">)))</a><a name="18379">
      </a><a name="18386" href="/2016/one-lambda-calculus-many-times/#18188" class="Function">lem</a><a name="18389"> </a><a name="18390" class="Symbol">=</a><a name="18391"> </a><a name="18392" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.TrustMe.html#551" class="Function" target="_blank">???</a><a name="18395">

    </a><a name="18401" href="/2016/one-lambda-calculus-many-times/#18019" class="Function">⟸</a><a name="18402"> </a><a name="18403" class="Symbol">(</a><a name="18404" href="/2016/one-lambda-calculus-many-times/#9909" class="InductiveConstructor">⇒r</a><a name="18406">  </a><a name="18408" href="/2016/one-lambda-calculus-many-times/#18408" class="Bound">f</a><a name="18409" class="Symbol">)</a><a name="18410">   </a><a name="18413" class="Symbol">=</a><a name="18414"> </a><a name="18415" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1036" class="Function" target="_blank">cong</a><a name="18419">  </a><a name="18421" class="Symbol">(λ</a><a name="18423"> </a><a name="18424" href="/2016/one-lambda-calculus-many-times/#18424" class="Bound">f</a><a name="18425"> </a><a name="18426" href="/2016/one-lambda-calculus-many-times/#18426" class="Bound">e</a><a name="18427"> </a><a name="18428" href="/2016/one-lambda-calculus-many-times/#18428" class="Bound">x</a><a name="18429"> </a><a name="18430" class="Symbol">→</a><a name="18431"> </a><a name="18432" href="/2016/one-lambda-calculus-many-times/#18424" class="Bound">f</a><a name="18433"> </a><a name="18434" class="Symbol">(</a><a name="18435" href="/2016/one-lambda-calculus-many-times/#18428" class="Bound">x</a><a name="18436"> </a><a name="18437" href="/2016/one-lambda-calculus-many-times/#13964" class="InductiveConstructor Operator">∷</a><a name="18438"> </a><a name="18439" href="/2016/one-lambda-calculus-many-times/#18426" class="Bound">e</a><a name="18440" class="Symbol">))</a><a name="18442"> </a><a name="18443" class="Symbol">(</a><a name="18444" href="/2016/one-lambda-calculus-many-times/#18019" class="Function">⟸</a><a name="18445"> </a><a name="18446" href="/2016/one-lambda-calculus-many-times/#18408" class="Bound">f</a><a name="18447" class="Symbol">)</a></pre>

Boop.

<pre class="Agda">    <a name="18485" class="Keyword">postulate</a><a name="18494">
      </a><a name="18501" href="/2016/one-lambda-calculus-many-times/#18501" class="Postulate">i⇒≡i⇒′</a><a name="18507">
        </a><a name="18516" class="Symbol">:</a><a name="18517"> </a><a name="18528" class="Symbol">(</a><a name="18529" href="/2016/one-lambda-calculus-many-times/#18529" class="Bound">f</a><a name="18530"> </a><a name="18531" class="Symbol">:</a><a name="18532"> </a><a name="18533" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="18535"> </a><a name="18536" href="/2016/one-lambda-calculus-many-times/#18521" class="Bound">A</a><a name="18537"> </a><a name="18538" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="18539"> </a><a name="18540" href="/2016/one-lambda-calculus-many-times/#18525" class="Bound">Γ</a><a name="18541"> </a><a name="18542" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="18543"> </a><a name="18544" href="/2016/one-lambda-calculus-many-times/#18523" class="Bound">B</a><a name="18545" class="Symbol">)</a><a name="18546">
          </a><a name="18557" class="Symbol">→</a><a name="18558"> </a><a name="18559" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18560"> </a><a name="18561" href="/2016/one-lambda-calculus-many-times/#5362" class="InductiveConstructor">⇒i</a><a name="18563"> </a><a name="18564" href="/2016/one-lambda-calculus-many-times/#18529" class="Bound">f</a><a name="18565"> </a><a name="18566" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="18567"> </a><a name="18568" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="18569"> </a><a name="18570" href="/2016/one-lambda-calculus-many-times/#17073" class="Function">⇒i′</a><a name="18573"> </a><a name="18578" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18579"> </a><a name="18580" href="/2016/one-lambda-calculus-many-times/#18529" class="Bound">f</a><a name="18581"> </a><a name="18582" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a><a name="18583">

      </a><a name="18591" href="/2016/one-lambda-calculus-many-times/#18591" class="Postulate">weak≡weak′</a><a name="18601">
        </a><a name="18610" class="Symbol">:</a><a name="18611"> </a><a name="18622" class="Symbol">(</a><a name="18623" href="/2016/one-lambda-calculus-many-times/#18623" class="Bound">f</a><a name="18624"> </a><a name="18625" class="Symbol">:</a><a name="18626"> </a><a name="18627" href="/2016/one-lambda-calculus-many-times/#5294" class="Datatype Operator">ND</a><a name="18629"> </a><a name="18630" href="/2016/one-lambda-calculus-many-times/#18619" class="Bound">Γ</a><a name="18631"> </a><a name="18632" href="/2016/one-lambda-calculus-many-times/#3902" class="InductiveConstructor Operator">⊢</a><a name="18633"> </a><a name="18634" href="/2016/one-lambda-calculus-many-times/#18617" class="Bound">B</a><a name="18635" class="Symbol">)</a><a name="18636">
          </a><a name="18647" class="Symbol">→</a><a name="18648"> </a><a name="18649" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18650"> </a><a name="18651" href="/2016/one-lambda-calculus-many-times/#8526" class="Function">weak</a><a name="18655"> </a><a name="18676" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟦</a><a name="18677"> </a><a name="18678" href="/2016/one-lambda-calculus-many-times/#18623" class="Bound">f</a><a name="18679"> </a><a name="18680" href="/2016/one-lambda-calculus-many-times/#12469" class="Field Operator">⟧</a></pre>
</div>
