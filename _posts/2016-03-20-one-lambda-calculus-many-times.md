---
title         : One λ-calculus, many times...
date          : 2016-03-20 12:00:00
categories    : [compsci]
tags          : [agda]
hide-implicit : true
extra-script  : agda-extra-script.html
extra-style   : agda-extra-style.html
---

Previously, I mentioned that one of the most common posts on Agda blogs
is implementing the simply-typed λ-calculus. [Gergő Érdi][noshortcuts]
even goes as far as to call it the FizzBuzz of dependently-typed
programming, and rightfully so: If you do a quick search, you'll find
dozens of examples.

In *[Dependently-Typed Programming with Agda][agdatutorial]*, Ulf Norell
implements a type checker the simply-typed λ-calculus;
[Francesco Mazzoli][byexample] more or less follows Ulf, but extends
his λ-calculus with a primitive operator for addition; and,
[Gergő Érdi][noshortcuts] extends Ulf's approach with a checker for
scope and binding.

I figured it would be more fun if, instead of rewriting the type
checker example, I would do something a little bit different. So for
my λ-calculus post, I'll have a look at kinds of different ways of
implementing the simply-typed λ-calculus. Today, natural deduction and
the sequent calculus.

<div class="hidden">
<pre class="Agda"><a name="1212" class="Keyword">module</a><a name="1218"> </a><a name="1219" href="/2016/one-lambda-calculus-many-times/#1" class="Module">2016-03-20-one-lambda-calculus-many-times</a><a name="1260"> </a><a name="1261" class="Keyword">where</a></pre>
</div>

### Natural Deduction and the λ-Calculus

We'll start our discussion with the syntax of types. Usually, types
are defined inductively over some set of atomic types. We don't really
care what these atomic types will be, so we might as well abstract
over them:

<pre class="Agda"><a name="1559" class="Keyword">module</a><a name="1565"> </a><a name="1566" href="/2016/one-lambda-calculus-many-times/#1566" class="Module">Syntax</a><a name="1572"> </a><a name="1573" class="Symbol">(</a><a name="1574" href="/2016/one-lambda-calculus-many-times/#1574" class="Bound">Atom</a><a name="1578"> </a><a name="1579" class="Symbol">:</a><a name="1580"> </a><a name="1581" class="PrimitiveType">Set</a><a name="1584" class="Symbol">)</a><a name="1585"> </a><a name="1586" class="Keyword">where</a></pre>

But, if it makes you feel better, we can pretend that they'll be some
like this:

<pre class="Agda Spec">  <a name="511" class="Keyword">data</a><a name="515"> </a><a name="516" href="#289" class="Module">Atom</a><a name="521"> </a><a name="522" class="Symbol">:</a><a name="523"> </a><a name="524" class="PrimitiveType">Set</a><a name="527"> </a><a name="528" class="Keyword">where</a><a name="533"><br />    </a><a name="538" href="#538" class="InductiveConstructor">Int</a><a name="542">    </a><a name="543" class="Symbol">:</a><a name="544"> </a><a name="545" href="#516" class="Datatype">Atom</a><a name="550"><br />    </a><a name="555" href="#555" class="InductiveConstructor">String</a><a name="562"> </a><a name="563" class="Symbol">:</a><a name="564"> </a><a name="565" href="#516" class="Datatype">Atom</a></pre>

Next, we defined our types. Since we're talking about minimal
propositional logic, a type is either atomic (marked by <a class="Agda
InductiveConstructor">El</a>) or an implication:

<pre class="Agda">  <a name="2628" class="Keyword">infixr</a><a name="2634"> </a><a name="2635" class="Number">6</a><a name="2636"> _⇒_

  </a><a name="2644" class="Keyword">data</a><a name="2648"> </a><a name="2649" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="2653"> </a><a name="2654" class="Symbol">:</a><a name="2655"> </a><a name="2656" class="PrimitiveType">Set</a><a name="2659"> </a><a name="2660" class="Keyword">where</a><a name="2665">
    </a><a name="2670" href="/2016/one-lambda-calculus-many-times/#2670" class="InductiveConstructor">El</a><a name="2672">  </a><a name="2674" class="Symbol">:</a><a name="2675"> </a><a name="2676" href="/2016/one-lambda-calculus-many-times/#1574" class="Bound">Atom</a><a name="2680"> </a><a name="2681" class="Symbol">→</a><a name="2682"> </a><a name="2683" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="2687">
    </a><a name="2692" href="/2016/one-lambda-calculus-many-times/#2692" class="InductiveConstructor Operator">_⇒_</a><a name="2695"> </a><a name="2696" class="Symbol">:</a><a name="2697"> </a><a name="2698" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="2702"> </a><a name="2703" class="Symbol">→</a><a name="2704"> </a><a name="2705" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="2709"> </a><a name="2710" class="Symbol">→</a><a name="2711"> </a><a name="2712" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a></pre>

Now we'll define sequents. Even though this is just a tiny piece of
syntax, we should put some thought behind it...

Traditionally, the antecedent of some sequent would be a *set* of
formulas. However, we're looking at this from the perspective of
λ-calculus, and there may well be a difference between two terms of
the same type. This is usually solved by changing the antecedent to a
set of *type assignments*, which means $$x : A$$ and $$y : A$$ are now
distinct. From the logical perspective, this is the same as using a
*bag* or *multiset* antecedent. If we were doing mathematics, we'd be
done, but implementation-wise a bag is actually a rather complex
beast. For this reason, we'll use a *list*:[^imports]

<div class="hidden">
<pre class="Agda">  <a name="3480" class="Keyword">open</a><a name="3484"> </a><a name="3485" class="Keyword">import</a><a name="3491"> </a><a name="3492" href="https://agda.github.io/agda-stdlib/Data.Nat.html#1" class="Module" target="_blank">Data.Nat</a><a name="3500">             </a><a name="3513" class="Keyword">using</a><a name="3518"> </a><a name="3519" class="Symbol">(</a><a name="3520" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#69" class="Datatype" target="_blank">ℕ</a><a name="3521" class="Symbol">;</a><a name="3522"> </a><a name="3523" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#100" class="InductiveConstructor" target="_blank">suc</a><a name="3526" class="Symbol">;</a><a name="3527"> </a><a name="3528" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#87" class="InductiveConstructor" target="_blank">zero</a><a name="3532" class="Symbol">)</a><a name="3533">
  </a><a name="3536" class="Keyword">open</a><a name="3540"> </a><a name="3541" class="Keyword">import</a><a name="3547"> </a><a name="3548" href="https://agda.github.io/agda-stdlib/Data.Fin.html#1" class="Module" target="_blank">Data.Fin</a><a name="3556">             </a><a name="3569" class="Keyword">using</a><a name="3574"> </a><a name="3575" class="Symbol">(</a><a name="3576" href="https://agda.github.io/agda-stdlib/Data.Fin.html#842" class="Datatype" target="_blank">Fin</a><a name="3579" class="Symbol">;</a><a name="3580"> </a><a name="3581" href="https://agda.github.io/agda-stdlib/Data.Fin.html#895" class="InductiveConstructor" target="_blank">suc</a><a name="3584" class="Symbol">;</a><a name="3585"> </a><a name="3586" href="https://agda.github.io/agda-stdlib/Data.Fin.html#864" class="InductiveConstructor" target="_blank">zero</a><a name="3590" class="Symbol">)</a><a name="3591">
  </a><a name="3594" class="Keyword">open</a><a name="3598"> </a><a name="3599" class="Keyword">import</a><a name="3605"> </a><a name="3606" href="https://agda.github.io/agda-stdlib/Data.List.html#1" class="Module" target="_blank">Data.List</a><a name="3615">            </a><a name="3627" class="Keyword">using</a><a name="3632"> </a><a name="3633" class="Symbol">(</a><a name="3634" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#52" class="Datatype" target="_blank">List</a><a name="3638" class="Symbol">;</a><a name="3639"> </a><a name="3640" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">_∷_</a><a name="3643" class="Symbol">;</a><a name="3644"> </a><a name="3645" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#5519" class="InductiveConstructor" target="_blank">[]</a><a name="3647" class="Symbol">;</a><a name="3648"> </a><a name="3649" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#895" class="Function Operator" target="_blank">_++_</a><a name="3653" class="Symbol">)</a><a name="3654">
  </a><a name="3657" class="Keyword">open</a><a name="3661"> </a><a name="3662" class="Keyword">import</a><a name="3668"> </a><a name="3669" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1" class="Module" target="_blank">Data.List.Any</a><a name="3682">        </a><a name="3690" class="Keyword">using</a><a name="3695"> </a><a name="3696" class="Symbol">(</a><a name="3697" class="Keyword">module</a><a name="3703"> </a><a name="3704" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#250" class="Module" target="_blank">Membership</a><a name="3714" class="Symbol">;</a><a name="3715"> </a><a name="3716" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="3720" class="Symbol">;</a><a name="3721"> </a><a name="3722" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="3727" class="Symbol">)</a><a name="3728">
  </a><a name="3731" class="Keyword">open</a><a name="3735"> </a><a name="3736" class="Keyword">import</a><a name="3742"> </a><a name="3743" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#1" class="Module" target="_blank">Function.Equivalence</a><a name="3763"> </a><a name="3764" class="Keyword">using</a><a name="3769"> </a><a name="3770" class="Symbol">(</a><a name="3771" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#711" class="Function Operator" target="_blank">_⇔_</a><a name="3774" class="Symbol">;</a><a name="3775"> </a><a name="3776" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#2131" class="Function" target="_blank">id</a><a name="3778" class="Symbol">;</a><a name="3779"> </a><a name="3780" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#1070" class="Function" target="_blank">map</a><a name="3783" class="Symbol">;</a><a name="3784"> </a><a name="3785" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#804" class="Function" target="_blank">equivalence</a><a name="3796" class="Symbol">)</a><a name="3797">
  </a><a name="3800" class="Keyword">open</a><a name="3804"> </a><a name="3805" class="Keyword">import</a><a name="3811"> </a><a name="3812" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality</a><a name="3849">
  </a><a name="3852" class="Keyword">open</a><a name="3856"> </a><a name="3857" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2298" class="Module" target="_blank">Membership</a><a name="3867"> </a><a name="3868" class="Symbol">(</a><a name="3869" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1526" class="Function" target="_blank">setoid</a><a name="3875"> </a><a name="3876" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="3880" class="Symbol">)</a><a name="3881">    </a><a name="3885" class="Keyword">using</a><a name="3890"> </a><a name="3891" class="Symbol">(</a><a name="3892">_∈_</a><a name="3895" class="Symbol">;</a><a name="3896"> _⊆_</a><a name="3900" class="Symbol">)</a></pre>
</div>
<pre class="Agda">  <a name="3935" class="Keyword">infix</a><a name="3940"> </a><a name="3941" class="Number">4</a><a name="3942"> _⊢_

  </a><a name="3950" class="Keyword">data</a><a name="3954"> </a><a name="3955" href="/2016/one-lambda-calculus-many-times/#3955" class="Datatype">Sequent</a><a name="3962"> </a><a name="3963" class="Symbol">:</a><a name="3964"> </a><a name="3965" class="PrimitiveType">Set</a><a name="3968"> </a><a name="3969" class="Keyword">where</a><a name="3974">
    </a><a name="3979" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">_⊢_</a><a name="3982"> </a><a name="3983" class="Symbol">:</a><a name="3984"> </a><a name="3985" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#52" class="Datatype" target="_blank">List</a><a name="3989"> </a><a name="3990" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="3994"> </a><a name="3995" class="Symbol">→</a><a name="3996"> </a><a name="3997" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="4001"> </a><a name="4002" class="Symbol">→</a><a name="4003"> </a><a name="4004" href="/2016/one-lambda-calculus-many-times/#3955" class="Datatype">Sequent</a></pre>

So what does a *proof* of a sequent look like? The logical system that
is most familiar to a computer scientist is probably *natural
deduction*. The natural deduction system for minimal propositional
logic has *three* rules:

$$
    \frac{A \in \Gamma}{\Gamma \vdash A}{\small ax}
    \quad
    \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!i}
    \quad
    \frac{\Gamma \vdash A \Rightarrow B \quad \Gamma \vdash A}{\Gamma \vdash B}{\small{\Rightarrow}\!e}
$$

Recall that λ-terms are constructed in one of three ways: a λ-term is
either a *variable*, an *abstraction* or an *application*:

$$
    M, N ::= x \mid (\lambda x . M) \mid (M\;N)
$$

These correspond exactly to the rules of natural deduction. In fact,
in type systems they are usually presented together:

$$
    \frac{(x : A) \in \Gamma}{\Gamma \vdash x : A}
    \quad
    \frac{x : A , \Gamma \vdash M : B}{\Gamma \vdash (\lambda x. M) : A \Rightarrow B}
    \quad
    \frac{\Gamma \vdash M : A \Rightarrow B \quad \Gamma \vdash N : A}{\Gamma \vdash (M\;N) : B}
$$

However, I like the clean look of the logical notation, so in the
interest of keeping things simple I will use that.
We encode the natural deduction system as a datatype, with each rule
corresponding to a *constructor*, and each proof a *value*:

<pre class="Agda">  <a name="5351" class="Keyword">infix</a><a name="5356"> </a><a name="5357" class="Number">3</a><a name="5358"> ND_

  </a><a name="5366" class="Keyword">data</a><a name="5370"> </a><a name="5371" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND_</a><a name="5374"> </a><a name="5375" class="Symbol">:</a><a name="5376"> </a><a name="5377" href="/2016/one-lambda-calculus-many-times/#3955" class="Datatype">Sequent</a><a name="5384"> </a><a name="5385" class="Symbol">→</a><a name="5386"> </a><a name="5387" class="PrimitiveType">Set</a><a name="5390"> </a><a name="5391" class="Keyword">where</a><a name="5396">
    </a><a name="5401" href="/2016/one-lambda-calculus-many-times/#5401" class="InductiveConstructor">ax</a><a name="5403"> </a><a name="5404" class="Symbol">:</a><a name="5405"> </a><a name="5418" href="/2016/one-lambda-calculus-many-times/#5409" class="Bound">A</a><a name="5419"> </a><a name="5420" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="5421"> </a><a name="5422" href="/2016/one-lambda-calculus-many-times/#5413" class="Bound">Γ</a><a name="5423"> </a><a name="5424" class="Symbol">→</a><a name="5425"> </a><a name="5426" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="5428"> </a><a name="5429" href="/2016/one-lambda-calculus-many-times/#5413" class="Bound">Γ</a><a name="5430"> </a><a name="5431" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="5432"> </a><a name="5433" href="/2016/one-lambda-calculus-many-times/#5409" class="Bound">A</a><a name="5434">
    </a><a name="5439" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="5441"> </a><a name="5442" class="Symbol">:</a><a name="5443"> </a><a name="5456" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="5458"> </a><a name="5459" href="/2016/one-lambda-calculus-many-times/#5447" class="Bound">A</a><a name="5460"> </a><a name="5461" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="5462"> </a><a name="5463" href="/2016/one-lambda-calculus-many-times/#5451" class="Bound">Γ</a><a name="5464"> </a><a name="5465" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="5466"> </a><a name="5467" href="/2016/one-lambda-calculus-many-times/#5449" class="Bound">B</a><a name="5468"> </a><a name="5469" class="Symbol">→</a><a name="5470"> </a><a name="5471" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="5473"> </a><a name="5474" href="/2016/one-lambda-calculus-many-times/#5451" class="Bound">Γ</a><a name="5475"> </a><a name="5476" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="5477"> </a><a name="5478" href="/2016/one-lambda-calculus-many-times/#5447" class="Bound">A</a><a name="5479"> </a><a name="5480" href="/2016/one-lambda-calculus-many-times/#2692" class="InductiveConstructor Operator">⇒</a><a name="5481"> </a><a name="5482" href="/2016/one-lambda-calculus-many-times/#5449" class="Bound">B</a><a name="5483">
    </a><a name="5488" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="5490"> </a><a name="5491" class="Symbol">:</a><a name="5492"> </a><a name="5505" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="5507"> </a><a name="5508" href="/2016/one-lambda-calculus-many-times/#5500" class="Bound">Γ</a><a name="5509"> </a><a name="5510" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="5511"> </a><a name="5512" href="/2016/one-lambda-calculus-many-times/#5496" class="Bound">A</a><a name="5513"> </a><a name="5514" href="/2016/one-lambda-calculus-many-times/#2692" class="InductiveConstructor Operator">⇒</a><a name="5515"> </a><a name="5516" href="/2016/one-lambda-calculus-many-times/#5498" class="Bound">B</a><a name="5517"> </a><a name="5518" class="Symbol">→</a><a name="5519"> </a><a name="5520" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="5522"> </a><a name="5523" href="/2016/one-lambda-calculus-many-times/#5500" class="Bound">Γ</a><a name="5524"> </a><a name="5525" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="5526"> </a><a name="5527" href="/2016/one-lambda-calculus-many-times/#5496" class="Bound">A</a><a name="5528"> </a><a name="5529" class="Symbol">→</a><a name="5530"> </a><a name="5531" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="5533"> </a><a name="5534" href="/2016/one-lambda-calculus-many-times/#5500" class="Bound">Γ</a><a name="5535"> </a><a name="5536" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="5537"> </a><a name="5538" href="/2016/one-lambda-calculus-many-times/#5498" class="Bound">B</a></pre>

Note: for the sake of brevity, I'm using an Agda notation in which
implicit arguments are hidden. That means that any unbound
variable---such as the As, Bs and Γs above---is implicitly universally
quantified.

I prefer to think of things of the type <a class="Agda Datatype
Operator">ND</a> as proofs made up of rules, but if you prefer to
think of them as programs made up of the constructors of lambda terms,
just use the following syntax:

<pre class="Agda">  <a name="6010" class="Keyword">pattern</a><a name="6017"> </a><a name="6018" href="/2016/one-lambda-calculus-many-times/#6018" class="InductiveConstructor">var</a><a name="6021">   </a><a name="6024" href="/2016/one-lambda-calculus-many-times/#6033" class="Bound">x</a><a name="6025"> </a><a name="6026" class="Symbol">=</a><a name="6027"> </a><a name="6028" href="/2016/one-lambda-calculus-many-times/#5401" class="InductiveConstructor">ax</a><a name="6030">   </a><a name="6033" href="/2016/one-lambda-calculus-many-times/#6033" class="Bound">x</a><a name="6034">
  </a><a name="6037" class="Keyword">pattern</a><a name="6044"> </a><a name="6045" href="/2016/one-lambda-calculus-many-times/#6045" class="InductiveConstructor">lam</a><a name="6048">   </a><a name="6051" href="/2016/one-lambda-calculus-many-times/#6060" class="Bound">x</a><a name="6052"> </a><a name="6053" class="Symbol">=</a><a name="6054"> </a><a name="6055" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="6057">   </a><a name="6060" href="/2016/one-lambda-calculus-many-times/#6060" class="Bound">x</a><a name="6061">
  </a><a name="6064" class="Keyword">pattern</a><a name="6071"> </a><a name="6072" href="/2016/one-lambda-calculus-many-times/#6072" class="InductiveConstructor Operator">_∙_</a><a name="6075"> </a><a name="6076" href="/2016/one-lambda-calculus-many-times/#6085" class="Bound">f</a><a name="6077"> </a><a name="6078" href="/2016/one-lambda-calculus-many-times/#6087" class="Bound">x</a><a name="6079"> </a><a name="6080" class="Symbol">=</a><a name="6081"> </a><a name="6082" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="6084"> </a><a name="6085" href="/2016/one-lambda-calculus-many-times/#6085" class="Bound">f</a><a name="6086"> </a><a name="6087" href="/2016/one-lambda-calculus-many-times/#6087" class="Bound">x</a></pre>

Earlier, we made the conscious choice to use *lists* to represent the
antecedent. However, this introduced a minor problem: while two
programs of the same type may not do the same thing, they *should* be
equivalent, as far as the type system is concerned, and so it *should*
be possible to rewrite a program which needs *two* values of type
$$A$$ to a program which needs only *one*.

Similarily, by using lists, we have introduced a fixed order in our
antecedent which isn't exactly desirable. While they may be different
programs, we *should* be able to rewrite the program $$f : A\to B\to C$$
to receive its arguments in the different order, i.e. to a program
$$f\prime : B\to A\to C$$.

Collectively, such properties are known as *structural* properties,
and for this particular logic we can summarise them neatly as follows:

> If $$\Gamma \subseteq \Gamma\prime$$ and $$\Gamma \vdash A$$, then
> $$\Gamma\prime \vdash A$$.

We can give a proof of this theorem by induction on the structure of
natural deduction proofs. Note that we represent the subset relation
as a *function*, that is to say $$\Gamma \subseteq \Gamma\prime$$ is
the *function* $$A\in\Gamma\to A\in\Gamma\prime$$:

<pre class="Agda">  <a name="7305" href="/2016/one-lambda-calculus-many-times/#7305" class="Function">struct</a><a name="7311"> </a><a name="7312" class="Symbol">:</a><a name="7313"> </a><a name="7327" href="/2016/one-lambda-calculus-many-times/#7319" class="Bound">Γ</a><a name="7328"> </a><a name="7329" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7330"> </a><a name="7331" href="/2016/one-lambda-calculus-many-times/#7321" class="Bound">Γ′</a><a name="7333"> </a><a name="7334" class="Symbol">→</a><a name="7335"> </a><a name="7336" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="7338"> </a><a name="7339" href="/2016/one-lambda-calculus-many-times/#7319" class="Bound">Γ</a><a name="7340"> </a><a name="7341" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="7342"> </a><a name="7343" href="/2016/one-lambda-calculus-many-times/#7317" class="Bound">A</a><a name="7344"> </a><a name="7345" class="Symbol">→</a><a name="7346"> </a><a name="7347" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="7349"> </a><a name="7350" href="/2016/one-lambda-calculus-many-times/#7321" class="Bound">Γ′</a><a name="7352"> </a><a name="7353" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="7354"> </a><a name="7355" href="/2016/one-lambda-calculus-many-times/#7317" class="Bound">A</a><a name="7356">
  </a><a name="7359" href="/2016/one-lambda-calculus-many-times/#7305" class="Function">struct</a><a name="7365"> </a><a name="7366" href="/2016/one-lambda-calculus-many-times/#7366" class="Bound">Γ⊆Γ′</a><a name="7370"> </a><a name="7371" class="Symbol">(</a><a name="7372" href="/2016/one-lambda-calculus-many-times/#5401" class="InductiveConstructor">ax</a><a name="7374"> </a><a name="7375" href="/2016/one-lambda-calculus-many-times/#7375" class="Bound">x</a><a name="7376" class="Symbol">)</a><a name="7377">   </a><a name="7380" class="Symbol">=</a><a name="7381"> </a><a name="7382" href="/2016/one-lambda-calculus-many-times/#5401" class="InductiveConstructor">ax</a><a name="7384"> </a><a name="7385" class="Symbol">(</a><a name="7386" href="/2016/one-lambda-calculus-many-times/#7366" class="Bound">Γ⊆Γ′</a><a name="7390"> </a><a name="7391" href="/2016/one-lambda-calculus-many-times/#7375" class="Bound">x</a><a name="7392" class="Symbol">)</a><a name="7393">
  </a><a name="7396" href="/2016/one-lambda-calculus-many-times/#7305" class="Function">struct</a><a name="7402"> </a><a name="7403" href="/2016/one-lambda-calculus-many-times/#7403" class="Bound">Γ⊆Γ′</a><a name="7407"> </a><a name="7408" class="Symbol">(</a><a name="7409" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="7411"> </a><a name="7412" href="/2016/one-lambda-calculus-many-times/#7412" class="Bound">f</a><a name="7413" class="Symbol">)</a><a name="7414">   </a><a name="7417" class="Symbol">=</a><a name="7418"> </a><a name="7419" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="7421"> </a><a name="7422" class="Symbol">(</a><a name="7423" href="/2016/one-lambda-calculus-many-times/#7305" class="Function">struct</a><a name="7429"> </a><a name="7430" class="Symbol">(</a><a name="7431" href="/2016/one-lambda-calculus-many-times/#7466" class="Function">∷-resp-⊆</a><a name="7439"> </a><a name="7440" href="/2016/one-lambda-calculus-many-times/#7403" class="Bound">Γ⊆Γ′</a><a name="7444" class="Symbol">)</a><a name="7445"> </a><a name="7446" href="/2016/one-lambda-calculus-many-times/#7412" class="Bound">f</a><a name="7447" class="Symbol">)</a><a name="7448">
    </a><a name="7453" class="Keyword">where</a><a name="7458">

      </a><a name="7466" href="/2016/one-lambda-calculus-many-times/#7466" class="Function">∷-resp-⊆</a><a name="7474"> </a><a name="7475" class="Symbol">:</a><a name="7476"> </a><a name="7490" href="/2016/one-lambda-calculus-many-times/#7482" class="Bound">Γ</a><a name="7491"> </a><a name="7492" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7493"> </a><a name="7494" href="/2016/one-lambda-calculus-many-times/#7484" class="Bound">Γ′</a><a name="7496"> </a><a name="7497" class="Symbol">→</a><a name="7498"> </a><a name="7499" href="/2016/one-lambda-calculus-many-times/#7480" class="Bound">A</a><a name="7500"> </a><a name="7501" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="7502"> </a><a name="7503" href="/2016/one-lambda-calculus-many-times/#7482" class="Bound">Γ</a><a name="7504"> </a><a name="7505" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7506"> </a><a name="7507" href="/2016/one-lambda-calculus-many-times/#7480" class="Bound">A</a><a name="7508"> </a><a name="7509" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="7510"> </a><a name="7511" href="/2016/one-lambda-calculus-many-times/#7484" class="Bound">Γ′</a><a name="7513">
      </a><a name="7520" href="/2016/one-lambda-calculus-many-times/#7466" class="Function">∷-resp-⊆</a><a name="7528"> </a><a name="7529" href="/2016/one-lambda-calculus-many-times/#7529" class="Bound">Γ⊆Γ′</a><a name="7533"> </a><a name="7534" class="Symbol">(</a><a name="7535" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="7539">  </a><a name="7541" href="/2016/one-lambda-calculus-many-times/#7541" class="Bound">x</a><a name="7542" class="Symbol">)</a><a name="7543"> </a><a name="7544" class="Symbol">=</a><a name="7545"> </a><a name="7546" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="7550"> </a><a name="7551" href="/2016/one-lambda-calculus-many-times/#7541" class="Bound">x</a><a name="7552">
      </a><a name="7559" href="/2016/one-lambda-calculus-many-times/#7466" class="Function">∷-resp-⊆</a><a name="7567"> </a><a name="7568" href="/2016/one-lambda-calculus-many-times/#7568" class="Bound">Γ⊆Γ′</a><a name="7572"> </a><a name="7573" class="Symbol">(</a><a name="7574" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="7579"> </a><a name="7580" href="/2016/one-lambda-calculus-many-times/#7580" class="Bound">x</a><a name="7581" class="Symbol">)</a><a name="7582"> </a><a name="7583" class="Symbol">=</a><a name="7584"> </a><a name="7585" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="7590"> </a><a name="7591" class="Symbol">(</a><a name="7592" href="/2016/one-lambda-calculus-many-times/#7568" class="Bound">Γ⊆Γ′</a><a name="7596"> </a><a name="7597" href="/2016/one-lambda-calculus-many-times/#7580" class="Bound">x</a><a name="7598" class="Symbol">)</a><a name="7599">

  </a><a name="7603" href="/2016/one-lambda-calculus-many-times/#7305" class="Function">struct</a><a name="7609"> </a><a name="7610" href="/2016/one-lambda-calculus-many-times/#7610" class="Bound">Γ⊆Γ′</a><a name="7614"> </a><a name="7615" class="Symbol">(</a><a name="7616" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="7618"> </a><a name="7619" href="/2016/one-lambda-calculus-many-times/#7619" class="Bound">f</a><a name="7620"> </a><a name="7621" href="/2016/one-lambda-calculus-many-times/#7621" class="Bound">g</a><a name="7622" class="Symbol">)</a><a name="7623"> </a><a name="7624" class="Symbol">=</a><a name="7625"> </a><a name="7626" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="7628"> </a><a name="7629" class="Symbol">(</a><a name="7630" href="/2016/one-lambda-calculus-many-times/#7305" class="Function">struct</a><a name="7636"> </a><a name="7637" href="/2016/one-lambda-calculus-many-times/#7610" class="Bound">Γ⊆Γ′</a><a name="7641"> </a><a name="7642" href="/2016/one-lambda-calculus-many-times/#7619" class="Bound">f</a><a name="7643" class="Symbol">)</a><a name="7644"> </a><a name="7645" class="Symbol">(</a><a name="7646" href="/2016/one-lambda-calculus-many-times/#7305" class="Function">struct</a><a name="7652"> </a><a name="7653" href="/2016/one-lambda-calculus-many-times/#7610" class="Bound">Γ⊆Γ′</a><a name="7657"> </a><a name="7658" href="/2016/one-lambda-calculus-many-times/#7621" class="Bound">g</a><a name="7659" class="Symbol">)</a></pre>

Note that values of type $$A\in\Gamma$$ are constructed using <a
class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174">here</a>
and <a class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227">there</a>,
which makes them more or less just numbers, i.e. "first value",
"second value", etc...

I mentioned two uses of this structural rule: contracting two
different variables of the *same* type into one, and exchanging the
order of the types in the antecedent. There is one more canonical use:
*weakning*.
Weakening is so obvious to programmers that they don't really think of
it, but what it says is that if you can run a program in *some*
environment, then you should *certainly* be able to run that program
in that enviroment with some irrelevant stuff added to it. Formally,
we write it as:

<pre class="Agda">  <a name="8603" href="/2016/one-lambda-calculus-many-times/#8603" class="Function">w′</a><a name="8605"> </a><a name="8606" class="Symbol">:</a><a name="8607"> </a><a name="8620" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="8622"> </a><a name="8623" href="/2016/one-lambda-calculus-many-times/#8615" class="Bound">Γ</a><a name="8624"> </a><a name="8625" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="8626"> </a><a name="8627" href="/2016/one-lambda-calculus-many-times/#8613" class="Bound">B</a><a name="8628"> </a><a name="8629" class="Symbol">→</a><a name="8630"> </a><a name="8631" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="8633"> </a><a name="8634" href="/2016/one-lambda-calculus-many-times/#8611" class="Bound">A</a><a name="8635"> </a><a name="8636" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="8637"> </a><a name="8638" href="/2016/one-lambda-calculus-many-times/#8615" class="Bound">Γ</a><a name="8639"> </a><a name="8640" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="8641"> </a><a name="8642" href="/2016/one-lambda-calculus-many-times/#8613" class="Bound">B</a><a name="8643">
  </a><a name="8646" href="/2016/one-lambda-calculus-many-times/#8603" class="Function">w′</a><a name="8648"> </a><a name="8649" class="Symbol">=</a><a name="8650"> </a><a name="8651" href="/2016/one-lambda-calculus-many-times/#7305" class="Function">struct</a><a name="8657"> </a><a name="8658" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a></pre>

Passing <a class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227">there</a>
to <a href="#6956" class="Agda Function">struct</a> simply
moves every value by one: the first value becomes the second, the
second becomes the third, etc... In the new antecedent, the first
value will be our "irrelevant stuff".


### Sequent Calculus and Natural Deduction

We've got enough to start talking about the sequent calculus now. The
sequent calculus is a different way of writing down logical systems,
and it has some pros and cons when compared to natural deduction.
It's usual presentation is as follows:

$$
    \frac{A \in \Gamma}{\Gamma \vdash A}{\small ax}
    \quad
    \frac{\Gamma \vdash A \quad A , \Gamma \vdash B}{\Gamma \vdash B}{\small cut}
    \quad
    \frac{\Gamma \vdash A \quad B , \Gamma \vdash C}{A \Rightarrow  B , \Gamma \vdash C}{\small{\Rightarrow}\!l}
    \quad
    \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!r}
$$

We can encode these rules in Agda as follows:

<pre class="Agda">  <a name="9765" class="Keyword">infix</a><a name="9770"> </a><a name="9771" class="Number">3</a><a name="9772"> SC_

  </a><a name="9780" class="Keyword">data</a><a name="9784"> </a><a name="9785" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC_</a><a name="9788"> </a><a name="9789" class="Symbol">:</a><a name="9790"> </a><a name="9791" href="/2016/one-lambda-calculus-many-times/#3955" class="Datatype">Sequent</a><a name="9798"> </a><a name="9799" class="Symbol">→</a><a name="9800"> </a><a name="9801" class="PrimitiveType">Set</a><a name="9804"> </a><a name="9805" class="Keyword">where</a><a name="9810">
    </a><a name="9815" href="/2016/one-lambda-calculus-many-times/#9815" class="InductiveConstructor">ax</a><a name="9817">  </a><a name="9819" class="Symbol">:</a><a name="9820"> </a><a name="9835" href="/2016/one-lambda-calculus-many-times/#9824" class="Bound">A</a><a name="9836"> </a><a name="9837" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="9838"> </a><a name="9839" href="/2016/one-lambda-calculus-many-times/#9830" class="Bound">Γ</a><a name="9840"> </a><a name="9841" class="Symbol">→</a><a name="9842"> </a><a name="9843" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="9845"> </a><a name="9846" href="/2016/one-lambda-calculus-many-times/#9830" class="Bound">Γ</a><a name="9847"> </a><a name="9848" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="9849"> </a><a name="9850" href="/2016/one-lambda-calculus-many-times/#9824" class="Bound">A</a><a name="9851">
    </a><a name="9856" href="/2016/one-lambda-calculus-many-times/#9856" class="InductiveConstructor">cut</a><a name="9859"> </a><a name="9860" class="Symbol">:</a><a name="9861"> </a><a name="9876" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="9878"> </a><a name="9879" href="/2016/one-lambda-calculus-many-times/#9871" class="Bound">Γ</a><a name="9880"> </a><a name="9881" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="9882"> </a><a name="9883" href="/2016/one-lambda-calculus-many-times/#9865" class="Bound">A</a><a name="9884"> </a><a name="9885" class="Symbol">→</a><a name="9886"> </a><a name="9887" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="9889"> </a><a name="9890" href="/2016/one-lambda-calculus-many-times/#9865" class="Bound">A</a><a name="9891"> </a><a name="9892" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9893"> </a><a name="9894" href="/2016/one-lambda-calculus-many-times/#9871" class="Bound">Γ</a><a name="9895"> </a><a name="9896" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="9897"> </a><a name="9898" href="/2016/one-lambda-calculus-many-times/#9867" class="Bound">B</a><a name="9899"> </a><a name="9900" class="Symbol">→</a><a name="9901"> </a><a name="9902" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="9904"> </a><a name="9905" href="/2016/one-lambda-calculus-many-times/#9871" class="Bound">Γ</a><a name="9906"> </a><a name="9907" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="9908"> </a><a name="9909" href="/2016/one-lambda-calculus-many-times/#9867" class="Bound">B</a><a name="9910">
    </a><a name="9915" href="/2016/one-lambda-calculus-many-times/#9915" class="InductiveConstructor">⇒l</a><a name="9917">  </a><a name="9919" class="Symbol">:</a><a name="9920"> </a><a name="9935" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="9937"> </a><a name="9938" href="/2016/one-lambda-calculus-many-times/#9930" class="Bound">Γ</a><a name="9939"> </a><a name="9940" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="9941"> </a><a name="9942" href="/2016/one-lambda-calculus-many-times/#9924" class="Bound">A</a><a name="9943"> </a><a name="9944" class="Symbol">→</a><a name="9945"> </a><a name="9946" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="9948"> </a><a name="9949" href="/2016/one-lambda-calculus-many-times/#9926" class="Bound">B</a><a name="9950"> </a><a name="9951" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9952"> </a><a name="9953" href="/2016/one-lambda-calculus-many-times/#9930" class="Bound">Γ</a><a name="9954"> </a><a name="9955" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="9956"> </a><a name="9957" href="/2016/one-lambda-calculus-many-times/#9928" class="Bound">C</a><a name="9958"> </a><a name="9959" class="Symbol">→</a><a name="9960"> </a><a name="9961" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="9963"> </a><a name="9964" href="/2016/one-lambda-calculus-many-times/#9924" class="Bound">A</a><a name="9965"> </a><a name="9966" href="/2016/one-lambda-calculus-many-times/#2692" class="InductiveConstructor Operator">⇒</a><a name="9967"> </a><a name="9968" href="/2016/one-lambda-calculus-many-times/#9926" class="Bound">B</a><a name="9969"> </a><a name="9970" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9971"> </a><a name="9972" href="/2016/one-lambda-calculus-many-times/#9930" class="Bound">Γ</a><a name="9973"> </a><a name="9974" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="9975"> </a><a name="9976" href="/2016/one-lambda-calculus-many-times/#9928" class="Bound">C</a><a name="9977">
    </a><a name="9982" href="/2016/one-lambda-calculus-many-times/#9982" class="InductiveConstructor">⇒r</a><a name="9984">  </a><a name="9986" class="Symbol">:</a><a name="9987"> </a><a name="10002" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="10004"> </a><a name="10005" href="/2016/one-lambda-calculus-many-times/#9991" class="Bound">A</a><a name="10006"> </a><a name="10007" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="10008"> </a><a name="10009" href="/2016/one-lambda-calculus-many-times/#9997" class="Bound">Γ</a><a name="10010"> </a><a name="10011" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="10012"> </a><a name="10013" href="/2016/one-lambda-calculus-many-times/#9993" class="Bound">B</a><a name="10014"> </a><a name="10015" class="Symbol">→</a><a name="10016"> </a><a name="10017" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="10019"> </a><a name="10020" href="/2016/one-lambda-calculus-many-times/#9997" class="Bound">Γ</a><a name="10021"> </a><a name="10022" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="10023"> </a><a name="10024" href="/2016/one-lambda-calculus-many-times/#9991" class="Bound">A</a><a name="10025"> </a><a name="10026" href="/2016/one-lambda-calculus-many-times/#2692" class="InductiveConstructor Operator">⇒</a><a name="10027"> </a><a name="10028" href="/2016/one-lambda-calculus-many-times/#9993" class="Bound">B</a></pre>

We will define a few patterns that we'd otherwise have to write out,
over and over again. Namely, names for the first, second, and third
variable in a context:

<pre class="Agda">  <a name="10218" class="Keyword">pattern</a><a name="10225"> </a><a name="10226" href="/2016/one-lambda-calculus-many-times/#10226" class="InductiveConstructor">ax₀</a><a name="10229"> </a><a name="10230" class="Symbol">=</a><a name="10231"> </a><a name="10232" class="InductiveConstructor">ax</a><a name="10234"> </a><a name="10235" class="Symbol">(</a><a name="10236" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10240"> </a><a name="10241" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#112" class="InductiveConstructor" target="_blank">refl</a><a name="10245" class="Symbol">)</a><a name="10246">
  </a><a name="10249" class="Keyword">pattern</a><a name="10256"> </a><a name="10257" href="/2016/one-lambda-calculus-many-times/#10257" class="InductiveConstructor">ax₁</a><a name="10260"> </a><a name="10261" class="Symbol">=</a><a name="10262"> </a><a name="10263" class="InductiveConstructor">ax</a><a name="10265"> </a><a name="10266" class="Symbol">(</a><a name="10267" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10272"> </a><a name="10273" class="Symbol">(</a><a name="10274" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10278"> </a><a name="10279" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#112" class="InductiveConstructor" target="_blank">refl</a><a name="10283" class="Symbol">))</a><a name="10285">
  </a><a name="10288" class="Keyword">pattern</a><a name="10295"> </a><a name="10296" href="/2016/one-lambda-calculus-many-times/#10296" class="InductiveConstructor">ax₂</a><a name="10299"> </a><a name="10300" class="Symbol">=</a><a name="10301"> </a><a name="10302" class="InductiveConstructor">ax</a><a name="10304"> </a><a name="10305" class="Symbol">(</a><a name="10306" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10311"> </a><a name="10312" class="Symbol">(</a><a name="10313" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10318"> </a><a name="10319" class="Symbol">(</a><a name="10320" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10324"> </a><a name="10325" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#112" class="InductiveConstructor" target="_blank">refl</a><a name="10329" class="Symbol">)))</a></pre>

It's a little bit of a puzzle, but given <a href="#8254" class="Agda
Function">w′</a> it becomes quite easy to show that the two logics
are in fact equivalent---that they derive the *same sequents*:

<pre class="Agda">  <a name="10560" class="Keyword">module</a><a name="10566"> </a><a name="10567" href="/2016/one-lambda-calculus-many-times/#10567" class="Module">ND⇔SC</a><a name="10572"> </a><a name="10573" class="Keyword">where</a><a name="10578">

    </a><a name="10584" href="/2016/one-lambda-calculus-many-times/#10584" class="Function">⟹</a><a name="10585"> </a><a name="10586" class="Symbol">:</a><a name="10587"> </a><a name="10596" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="10598"> </a><a name="10599" href="/2016/one-lambda-calculus-many-times/#10591" class="Bound">S</a><a name="10600"> </a><a name="10601" class="Symbol">→</a><a name="10602"> </a><a name="10603" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="10605"> </a><a name="10606" href="/2016/one-lambda-calculus-many-times/#10591" class="Bound">S</a><a name="10607">
    </a><a name="10612" href="/2016/one-lambda-calculus-many-times/#10584" class="Function">⟹</a><a name="10613"> </a><a name="10614" class="Symbol">(</a><a name="10615" href="/2016/one-lambda-calculus-many-times/#5401" class="InductiveConstructor">ax</a><a name="10617">  </a><a name="10619" href="/2016/one-lambda-calculus-many-times/#10619" class="Bound">x</a><a name="10620" class="Symbol">)</a><a name="10621">   </a><a name="10624" class="Symbol">=</a><a name="10625"> </a><a name="10626" href="/2016/one-lambda-calculus-many-times/#9815" class="InductiveConstructor">ax</a><a name="10628"> </a><a name="10629" href="/2016/one-lambda-calculus-many-times/#10619" class="Bound">x</a><a name="10630">
    </a><a name="10635" href="/2016/one-lambda-calculus-many-times/#10584" class="Function">⟹</a><a name="10636"> </a><a name="10637" class="Symbol">(</a><a name="10638" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="10640">  </a><a name="10642" href="/2016/one-lambda-calculus-many-times/#10642" class="Bound">f</a><a name="10643" class="Symbol">)</a><a name="10644">   </a><a name="10647" class="Symbol">=</a><a name="10648"> </a><a name="10649" href="/2016/one-lambda-calculus-many-times/#9982" class="InductiveConstructor">⇒r</a><a name="10651">  </a><a name="10653" class="Symbol">(</a><a name="10654" href="/2016/one-lambda-calculus-many-times/#10584" class="Function">⟹</a><a name="10655"> </a><a name="10656" href="/2016/one-lambda-calculus-many-times/#10642" class="Bound">f</a><a name="10657" class="Symbol">)</a><a name="10658">
    </a><a name="10663" href="/2016/one-lambda-calculus-many-times/#10584" class="Function">⟹</a><a name="10664"> </a><a name="10665" class="Symbol">(</a><a name="10666" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="10668">  </a><a name="10670" href="/2016/one-lambda-calculus-many-times/#10670" class="Bound">f</a><a name="10671"> </a><a name="10672" href="/2016/one-lambda-calculus-many-times/#10672" class="Bound">g</a><a name="10673" class="Symbol">)</a><a name="10674"> </a><a name="10675" class="Symbol">=</a><a name="10676"> </a><a name="10677" href="/2016/one-lambda-calculus-many-times/#9856" class="InductiveConstructor">cut</a><a name="10680"> </a><a name="10681" class="Symbol">(</a><a name="10682" href="/2016/one-lambda-calculus-many-times/#10584" class="Function">⟹</a><a name="10683"> </a><a name="10684" href="/2016/one-lambda-calculus-many-times/#10670" class="Bound">f</a><a name="10685" class="Symbol">)</a><a name="10686"> </a><a name="10687" class="Symbol">(</a><a name="10688" href="/2016/one-lambda-calculus-many-times/#9915" class="InductiveConstructor">⇒l</a><a name="10690"> </a><a name="10691" class="Symbol">(</a><a name="10692" href="/2016/one-lambda-calculus-many-times/#10584" class="Function">⟹</a><a name="10693"> </a><a name="10694" href="/2016/one-lambda-calculus-many-times/#10672" class="Bound">g</a><a name="10695" class="Symbol">)</a><a name="10696"> </a><a name="10697" href="/2016/one-lambda-calculus-many-times/#10226" class="InductiveConstructor">ax₀</a><a name="10700" class="Symbol">)</a><a name="10701">

    </a><a name="10707" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10708"> </a><a name="10709" class="Symbol">:</a><a name="10710"> </a><a name="10719" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="10721"> </a><a name="10722" href="/2016/one-lambda-calculus-many-times/#10714" class="Bound">S</a><a name="10723"> </a><a name="10724" class="Symbol">→</a><a name="10725"> </a><a name="10726" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="10728"> </a><a name="10729" href="/2016/one-lambda-calculus-many-times/#10714" class="Bound">S</a><a name="10730">
    </a><a name="10735" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10736"> </a><a name="10737" class="Symbol">(</a><a name="10738" href="/2016/one-lambda-calculus-many-times/#9815" class="InductiveConstructor">ax</a><a name="10740">  </a><a name="10742" href="/2016/one-lambda-calculus-many-times/#10742" class="Bound">p</a><a name="10743" class="Symbol">)</a><a name="10744">   </a><a name="10747" class="Symbol">=</a><a name="10748"> </a><a name="10749" href="/2016/one-lambda-calculus-many-times/#5401" class="InductiveConstructor">ax</a><a name="10751"> </a><a name="10752" href="/2016/one-lambda-calculus-many-times/#10742" class="Bound">p</a><a name="10753">
    </a><a name="10758" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10759"> </a><a name="10760" class="Symbol">(</a><a name="10761" href="/2016/one-lambda-calculus-many-times/#9856" class="InductiveConstructor">cut</a><a name="10764"> </a><a name="10765" href="/2016/one-lambda-calculus-many-times/#10765" class="Bound">f</a><a name="10766"> </a><a name="10767" href="/2016/one-lambda-calculus-many-times/#10767" class="Bound">g</a><a name="10768" class="Symbol">)</a><a name="10769"> </a><a name="10770" class="Symbol">=</a><a name="10771"> </a><a name="10772" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="10774"> </a><a name="10775" class="Symbol">(</a><a name="10776" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="10778"> </a><a name="10779" class="Symbol">(</a><a name="10780" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10781"> </a><a name="10782" href="/2016/one-lambda-calculus-many-times/#10767" class="Bound">g</a><a name="10783" class="Symbol">))</a><a name="10785"> </a><a name="10786" class="Symbol">(</a><a name="10787" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10788"> </a><a name="10789" href="/2016/one-lambda-calculus-many-times/#10765" class="Bound">f</a><a name="10790" class="Symbol">)</a><a name="10791">
    </a><a name="10796" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10797"> </a><a name="10798" class="Symbol">(</a><a name="10799" href="/2016/one-lambda-calculus-many-times/#9915" class="InductiveConstructor">⇒l</a><a name="10801">  </a><a name="10803" href="/2016/one-lambda-calculus-many-times/#10803" class="Bound">f</a><a name="10804"> </a><a name="10805" href="/2016/one-lambda-calculus-many-times/#10805" class="Bound">g</a><a name="10806" class="Symbol">)</a><a name="10807"> </a><a name="10808" class="Symbol">=</a><a name="10809"> </a><a name="10810" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="10812"> </a><a name="10813" class="Symbol">(</a><a name="10814" href="/2016/one-lambda-calculus-many-times/#8603" class="Function">w′</a><a name="10816"> </a><a name="10817" class="Symbol">(</a><a name="10818" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="10820"> </a><a name="10821" class="Symbol">(</a><a name="10822" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10823"> </a><a name="10824" href="/2016/one-lambda-calculus-many-times/#10805" class="Bound">g</a><a name="10825" class="Symbol">)))</a><a name="10828"> </a><a name="10829" class="Symbol">(</a><a name="10830" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="10832"> </a><a name="10833" href="/2016/one-lambda-calculus-many-times/#10226" class="InductiveConstructor">ax₀</a><a name="10836"> </a><a name="10837" class="Symbol">(</a><a name="10838" href="/2016/one-lambda-calculus-many-times/#8603" class="Function">w′</a><a name="10840"> </a><a name="10841" class="Symbol">(</a><a name="10842" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10843"> </a><a name="10844" href="/2016/one-lambda-calculus-many-times/#10803" class="Bound">f</a><a name="10845" class="Symbol">)))</a><a name="10848">
    </a><a name="10853" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10854"> </a><a name="10855" class="Symbol">(</a><a name="10856" href="/2016/one-lambda-calculus-many-times/#9982" class="InductiveConstructor">⇒r</a><a name="10858">  </a><a name="10860" href="/2016/one-lambda-calculus-many-times/#10860" class="Bound">f</a><a name="10861" class="Symbol">)</a><a name="10862">   </a><a name="10865" class="Symbol">=</a><a name="10866"> </a><a name="10867" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="10869"> </a><a name="10870" class="Symbol">(</a><a name="10871" href="/2016/one-lambda-calculus-many-times/#10707" class="Function">⟸</a><a name="10872"> </a><a name="10873" href="/2016/one-lambda-calculus-many-times/#10860" class="Bound">f</a><a name="10874" class="Symbol">)</a></pre>

The rules for sequent calculus obviously no longer correspond *directly*
to the λ-calculus. However, we've just shown that there is in fact
*some* correspondence between them.
In the λ-calculus, computation is represented by β-reduction, which is
the iterative removal of redexes

$$(\lambda x.M)\; N\mapsto M[x := N]$$

Likewise, sequent calculus comes equipped with its own notion of
computation: cut-elimination. And the beautiful thing about cut
elimination is that it has a *very* concrete normal form. Instead of
faffing about, claiming the structure is free of β-redexes, cut
elimination---as its name implies---allows you to remove the entire
structural rule of $$cut$$. It would be interesting to show exactly
what kind of relation cut elimination has to β-reduction...

*Alas*! It may be too much effort for a single post to implement both of
these logics *and* a procedure for cut elimination. However, there
*is* a much simpler thing we can do. Agda itself has a pretty
servicable implementation of β-reduction for Agda terms, and we can
quite easily piggyback on that mechanism. In fact, most of the
articles I linked to at the beginning do exactly this.


### Interpretations in Agda

As a first step, we write down what an interpretation is---and since
we want to use the intepretation brackets in as many places as
possible, we create a type class for it, and give <a href="#12173"
class="Agda Field Operator">⟦_⟧</a> the least restrictive type
possible:

<div class="hidden">
<pre class="Agda"><a name="12394" class="Keyword">open</a><a name="12398"> </a><a name="12399" class="Keyword">import</a><a name="12405"> </a><a name="12406" href="https://agda.github.io/agda-stdlib/Level.html#1" class="Module" target="_blank">Level</a><a name="12411"> </a><a name="12412" class="Keyword">using</a><a name="12417"> </a><a name="12418" class="Symbol">(</a><a name="12419" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#626" class="Primitive Operator" target="_blank">_⊔_</a><a name="12422" class="Symbol">)</a></pre>
</div>
<pre class="Agda"><a name="12455" class="Keyword">record</a><a name="12461"> </a><a name="12462" href="/2016/one-lambda-calculus-many-times/#12462" class="Record">Interpret</a><a name="12471"> </a><a name="12480" class="Symbol">(</a><a name="12481" href="/2016/one-lambda-calculus-many-times/#12481" class="Bound">A</a><a name="12482"> </a><a name="12483" class="Symbol">:</a><a name="12484"> </a><a name="12485" class="PrimitiveType">Set</a><a name="12488"> </a><a name="12489" href="/2016/one-lambda-calculus-many-times/#12473" class="Bound">a</a><a name="12490" class="Symbol">)</a><a name="12491"> </a><a name="12492" class="Symbol">(</a><a name="12493" href="/2016/one-lambda-calculus-many-times/#12493" class="Bound">B</a><a name="12494"> </a><a name="12495" class="Symbol">:</a><a name="12496"> </a><a name="12497" class="PrimitiveType">Set</a><a name="12500"> </a><a name="12501" href="/2016/one-lambda-calculus-many-times/#12477" class="Bound">b</a><a name="12502" class="Symbol">)</a><a name="12503"> </a><a name="12504" class="Symbol">:</a><a name="12505"> </a><a name="12506" class="PrimitiveType">Set</a><a name="12509"> </a><a name="12510" class="Symbol">(</a><a name="12511" href="/2016/one-lambda-calculus-many-times/#12473" class="Bound">a</a><a name="12512"> </a><a name="12513" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#626" class="Primitive Operator" target="_blank">⊔</a><a name="12514"> </a><a name="12515" href="/2016/one-lambda-calculus-many-times/#12477" class="Bound">b</a><a name="12516" class="Symbol">)</a><a name="12517"> </a><a name="12518" class="Keyword">where</a><a name="12523">
  </a><a name="12526" class="Keyword">field</a><a name="12531">
    </a><a name="12536" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟦_⟧</a><a name="12539"> </a><a name="12540" class="Symbol">:</a><a name="12541"> </a><a name="12542" href="/2016/one-lambda-calculus-many-times/#12481" class="Bound">A</a><a name="12543"> </a><a name="12544" class="Symbol">→</a><a name="12545"> </a><a name="12546" href="/2016/one-lambda-calculus-many-times/#12493" class="Bound">B</a><a name="12547">
</a><a name="12548" class="Keyword">open</a><a name="12552"> </a><a name="12553" href="/2016/one-lambda-calculus-many-times/#12462" class="Module">Interpret</a><a name="12562"> </a><a name="12563" class="Symbol">&#123;&#123;...&#125;&#125;</a></pre>

Now, in order to interpret natural deduction proofs in Agda, we'll
need an interpretation for the atomic types. Below we say as much:

<pre class="Agda"><a name="12731" class="Keyword">module</a><a name="12737"> </a><a name="12738" href="/2016/one-lambda-calculus-many-times/#12738" class="Module">Semantics</a><a name="12747"> </a><a name="12748" class="Symbol">(</a><a name="12749" href="/2016/one-lambda-calculus-many-times/#12749" class="Bound">Atom</a><a name="12753"> </a><a name="12754" class="Symbol">:</a><a name="12755"> </a><a name="12756" class="PrimitiveType">Set</a><a name="12759" class="Symbol">)</a><a name="12760"> </a><a name="12761" class="Symbol">&#123;&#123;</a><a name="12763" href="/2016/one-lambda-calculus-many-times/#12763" class="Bound">InterpretAtom</a><a name="12776"> </a><a name="12777" class="Symbol">:</a><a name="12778"> </a><a name="12779" href="/2016/one-lambda-calculus-many-times/#12462" class="Record">Interpret</a><a name="12788"> </a><a name="12789" href="/2016/one-lambda-calculus-many-times/#12749" class="Bound">Atom</a><a name="12793"> </a><a name="12794" class="PrimitiveType">Set</a><a name="12797" class="Symbol">&#125;&#125;</a><a name="12799"> </a><a name="12800" class="Keyword">where</a></pre>

<div class="hidden">
<pre class="Agda">  <a name="12854" class="Keyword">open</a><a name="12858"> </a><a name="12859" href="/2016/one-lambda-calculus-many-times/#1566" class="Module">Syntax</a><a name="12865"> </a><a name="12866" href="/2016/one-lambda-calculus-many-times/#12749" class="Bound">Atom</a><a name="12870">
  </a><a name="12873" class="Keyword">open</a><a name="12877"> </a><a name="12878" class="Keyword">import</a><a name="12884"> </a><a name="12885" href="https://agda.github.io/agda-stdlib/Data.Empty.html#1" class="Module" target="_blank">Data.Empty</a><a name="12895">           </a><a name="12906" class="Keyword">using</a><a name="12911"> </a><a name="12912" class="Symbol">(</a><a name="12913" href="https://agda.github.io/agda-stdlib/Data.Empty.html#348" class="Function" target="_blank">⊥-elim</a><a name="12919" class="Symbol">)</a><a name="12920">
  </a><a name="12923" class="Keyword">open</a><a name="12927"> </a><a name="12928" class="Keyword">import</a><a name="12934"> </a><a name="12935" href="https://agda.github.io/agda-stdlib/Data.List.html#1" class="Module" target="_blank">Data.List</a><a name="12944">            </a><a name="12956" class="Keyword">using</a><a name="12961"> </a><a name="12962" class="Symbol">(</a><a name="12963" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#52" class="Datatype" target="_blank">List</a><a name="12967" class="Symbol">;</a><a name="12968"> </a><a name="12969" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">_∷_</a><a name="12972" class="Symbol">;</a><a name="12973"> </a><a name="12974" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#5519" class="InductiveConstructor" target="_blank">[]</a><a name="12976" class="Symbol">;</a><a name="12977"> </a><a name="12978" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#1207" class="Function" target="_blank">map</a><a name="12981" class="Symbol">)</a><a name="12982">
  </a><a name="12985" class="Keyword">open</a><a name="12989"> </a><a name="12990" class="Keyword">import</a><a name="12996"> </a><a name="12997" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1" class="Module" target="_blank">Data.List.Any</a><a name="13010">        </a><a name="13018" class="Keyword">using</a><a name="13023"> </a><a name="13024" class="Symbol">(</a><a name="13025" class="Keyword">module</a><a name="13031"> </a><a name="13032" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#250" class="Module" target="_blank">Membership</a><a name="13042" class="Symbol">;</a><a name="13043"> </a><a name="13044" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="13048" class="Symbol">;</a><a name="13049"> </a><a name="13050" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="13055" class="Symbol">)</a><a name="13056">
  </a><a name="13059" class="Keyword">open</a><a name="13063"> </a><a name="13064" class="Keyword">import</a><a name="13070"> </a><a name="13071" href="https://agda.github.io/agda-stdlib/Function.html#1" class="Module" target="_blank">Function</a><a name="13079">             </a><a name="13092" class="Keyword">using</a><a name="13097"> </a><a name="13098" class="Symbol">(</a><a name="13099" href="https://agda.github.io/agda-stdlib/Function.html#713" class="Function Operator" target="_blank">_∘_</a><a name="13102" class="Symbol">)</a><a name="13103">
  </a><a name="13106" class="Keyword">open</a><a name="13110"> </a><a name="13111" class="Keyword">import</a><a name="13117"> </a><a name="13118" href="https://agda.github.io/agda-stdlib/Function.Equality.html#1" class="Module" target="_blank">Function.Equality</a><a name="13135">    </a><a name="13139" class="Keyword">using</a><a name="13144"> </a><a name="13145" class="Symbol">(</a><a name="13146" href="https://agda.github.io/agda-stdlib/Function.Equality.html#681" class="Field Operator" target="_blank">_⟨$⟩_</a><a name="13151" class="Symbol">)</a><a name="13152">
  </a><a name="13155" class="Keyword">open</a><a name="13159"> </a><a name="13160" class="Keyword">import</a><a name="13166"> </a><a name="13167" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#1" class="Module" target="_blank">Function.Equivalence</a><a name="13187"> </a><a name="13188" class="Keyword">using</a><a name="13193"> </a><a name="13194" class="Symbol">(</a><a name="13195" class="Keyword">module</a><a name="13201"> </a><a name="13202" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#218" class="Module" target="_blank">Equivalence</a><a name="13213" class="Symbol">)</a><a name="13214">
  </a><a name="13217" class="Keyword">open</a><a name="13221"> </a><a name="13222" class="Keyword">import</a><a name="13228"> </a><a name="13229" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality</a><a name="13266">
  </a><a name="13269" class="Keyword">open</a><a name="13273"> </a><a name="13274" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2298" class="Module" target="_blank">Membership</a><a name="13284"> </a><a name="13285" class="Symbol">(</a><a name="13286" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1526" class="Function" target="_blank">setoid</a><a name="13292"> </a><a name="13293" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="13297" class="Symbol">)</a><a name="13298">    </a><a name="13302" class="Keyword">using</a><a name="13307"> </a><a name="13308" class="Symbol">(</a><a name="13309">_∈_</a><a name="13312" class="Symbol">;</a><a name="13313"> _⊆_</a><a name="13317" class="Symbol">)</a><a name="13318">
  </a><a name="13321" class="Keyword">open</a><a name="13325"> </a><a name="13326" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#488" class="Module" target="_blank">Equivalence</a><a name="13337">                 </a><a name="13354" class="Keyword">using</a><a name="13359"> </a><a name="13360" class="Symbol">(</a><a name="13361" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#638" class="Field" target="_blank">to</a><a name="13363" class="Symbol">;</a><a name="13364"> </a><a name="13365" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#659" class="Field" target="_blank">from</a><a name="13369" class="Symbol">)</a></pre>
</div>

Unsurprisingly, we interpret the implication as Agda's function type:

<pre class="Agda">  <a name="13476" class="Keyword">instance</a><a name="13484">
    </a><a name="13489" href="/2016/one-lambda-calculus-many-times/#13489" class="Function">InterpretType</a><a name="13502"> </a><a name="13503" class="Symbol">:</a><a name="13504"> </a><a name="13505" href="/2016/one-lambda-calculus-many-times/#12462" class="Record">Interpret</a><a name="13514"> </a><a name="13515" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="13519"> </a><a name="13520" class="PrimitiveType">Set</a><a name="13523">
    </a><a name="13528" href="/2016/one-lambda-calculus-many-times/#13489" class="Function">InterpretType</a><a name="13541"> </a><a name="13542" class="Symbol">=</a><a name="13543"> </a><a name="13544" class="Keyword">record</a><a name="13550"> </a><a name="13572" class="Keyword">where</a><a name="13577">
        </a><a name="13586" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟦_⟧′</a><a name="13590">  </a><a name="13592" class="Symbol">:</a><a name="13593"> </a><a name="13594" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="13598"> </a><a name="13599" class="Symbol">→</a><a name="13600"> </a><a name="13601" class="PrimitiveType">Set</a><a name="13604">
        </a><a name="13613" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟦</a><a name="13614"> </a><a name="13615" href="/2016/one-lambda-calculus-many-times/#2670" class="InductiveConstructor">El</a><a name="13617">  </a><a name="13619" href="/2016/one-lambda-calculus-many-times/#13619" class="Bound">A</a><a name="13620"> </a><a name="13621" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟧′</a><a name="13623"> </a><a name="13624" class="Symbol">=</a><a name="13625"> </a><a name="13626" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟦</a><a name="13627"> </a><a name="13628" href="/2016/one-lambda-calculus-many-times/#13619" class="Bound">A</a><a name="13629"> </a><a name="13630" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟧</a><a name="13631">
        </a><a name="13640" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟦</a><a name="13641"> </a><a name="13642" href="/2016/one-lambda-calculus-many-times/#13642" class="Bound">A</a><a name="13643"> </a><a name="13644" href="/2016/one-lambda-calculus-many-times/#2692" class="InductiveConstructor Operator">⇒</a><a name="13645"> </a><a name="13646" href="/2016/one-lambda-calculus-many-times/#13646" class="Bound">B</a><a name="13647"> </a><a name="13648" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟧′</a><a name="13650"> </a><a name="13651" class="Symbol">=</a><a name="13652"> </a><a name="13653" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟦</a><a name="13654"> </a><a name="13655" href="/2016/one-lambda-calculus-many-times/#13642" class="Bound">A</a><a name="13656"> </a><a name="13657" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟧′</a><a name="13659"> </a><a name="13660" class="Symbol">→</a><a name="13661"> </a><a name="13662" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟦</a><a name="13663"> </a><a name="13664" href="/2016/one-lambda-calculus-many-times/#13646" class="Bound">B</a><a name="13665"> </a><a name="13666" href="/2016/one-lambda-calculus-many-times/#13586" class="Function Operator">⟧′</a></pre>

In order to interpret sequents, we'll need an interpretation for the
antecedent. For this we'll create a type for *environments*, <a
class="Agda Datatype">Env</a>, which is indexed by a list of types, and
which stores values of the *interpretations* of those types:

<pre class="Agda">  <a name="13963" class="Keyword">infixr</a><a name="13969"> </a><a name="13970" class="Number">5</a><a name="13971"> _∷_

  </a><a name="13979" class="Keyword">data</a><a name="13983"> </a><a name="13984" href="/2016/one-lambda-calculus-many-times/#13984" class="Datatype">Env</a><a name="13987"> </a><a name="13988" class="Symbol">:</a><a name="13989"> </a><a name="13990" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#52" class="Datatype" target="_blank">List</a><a name="13994"> </a><a name="13995" href="/2016/one-lambda-calculus-many-times/#2649" class="Datatype">Type</a><a name="13999"> </a><a name="14000" class="Symbol">→</a><a name="14001"> </a><a name="14002" class="PrimitiveType">Set</a><a name="14005"> </a><a name="14006" class="Keyword">where</a><a name="14011">
    </a><a name="14016" href="/2016/one-lambda-calculus-many-times/#14016" class="InductiveConstructor">[]</a><a name="14018">  </a><a name="14020" class="Symbol">:</a><a name="14021"> </a><a name="14022" href="/2016/one-lambda-calculus-many-times/#13984" class="Datatype">Env</a><a name="14025"> </a><a name="14026" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#89" class="InductiveConstructor" target="_blank">[]</a><a name="14028">
    </a><a name="14033" href="/2016/one-lambda-calculus-many-times/#14033" class="InductiveConstructor Operator">_∷_</a><a name="14036"> </a><a name="14037" class="Symbol">:</a><a name="14038"> </a><a name="14068" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟦</a><a name="14069"> </a><a name="14070" href="/2016/one-lambda-calculus-many-times/#14040" class="Bound">A</a><a name="14071"> </a><a name="14072" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟧</a><a name="14073"> </a><a name="14074" class="Symbol">→</a><a name="14075"> </a><a name="14076" href="/2016/one-lambda-calculus-many-times/#13984" class="Datatype">Env</a><a name="14079"> </a><a name="14080" href="/2016/one-lambda-calculus-many-times/#14051" class="Bound">Γ</a><a name="14081"> </a><a name="14082" class="Symbol">→</a><a name="14083"> </a><a name="14084" href="/2016/one-lambda-calculus-many-times/#13984" class="Datatype">Env</a><a name="14087"> </a><a name="14088" class="Symbol">(</a><a name="14089" href="/2016/one-lambda-calculus-many-times/#14040" class="Bound">A</a><a name="14090"> </a><a name="14091" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#104" class="InductiveConstructor Operator" target="_blank">∷</a><a name="14092"> </a><a name="14093" href="/2016/one-lambda-calculus-many-times/#14051" class="Bound">Γ</a><a name="14094" class="Symbol">)</a></pre>

Using this, we can interpret sequents as functions from environments
to values:

<pre class="Agda">  <a name="14204" class="Keyword">instance</a><a name="14212">
    </a><a name="14217" href="/2016/one-lambda-calculus-many-times/#14217" class="Function">InterpretSequent</a><a name="14233"> </a><a name="14234" class="Symbol">:</a><a name="14235"> </a><a name="14236" href="/2016/one-lambda-calculus-many-times/#12462" class="Record">Interpret</a><a name="14245"> </a><a name="14246" href="/2016/one-lambda-calculus-many-times/#3955" class="Datatype">Sequent</a><a name="14253"> </a><a name="14254" class="PrimitiveType">Set</a><a name="14257">
    </a><a name="14262" href="/2016/one-lambda-calculus-many-times/#14217" class="Function">InterpretSequent</a><a name="14278"> </a><a name="14279" class="Symbol">=</a><a name="14280"> </a><a name="14281" class="Keyword">record</a><a name="14287"> </a><a name="14309" class="Keyword">where</a><a name="14314">
        </a><a name="14323" href="/2016/one-lambda-calculus-many-times/#14323" class="Function Operator">⟦_⟧′</a><a name="14327"> </a><a name="14328" class="Symbol">:</a><a name="14329"> </a><a name="14330" href="/2016/one-lambda-calculus-many-times/#3955" class="Datatype">Sequent</a><a name="14337"> </a><a name="14338" class="Symbol">→</a><a name="14339"> </a><a name="14340" class="PrimitiveType">Set</a><a name="14343">
        </a><a name="14352" href="/2016/one-lambda-calculus-many-times/#14323" class="Function Operator">⟦</a><a name="14353"> </a><a name="14354" href="/2016/one-lambda-calculus-many-times/#14354" class="Bound">Γ</a><a name="14355"> </a><a name="14356" href="/2016/one-lambda-calculus-many-times/#3979" class="InductiveConstructor Operator">⊢</a><a name="14357"> </a><a name="14358" href="/2016/one-lambda-calculus-many-times/#14358" class="Bound">A</a><a name="14359"> </a><a name="14360" href="/2016/one-lambda-calculus-many-times/#14323" class="Function Operator">⟧′</a><a name="14362"> </a><a name="14363" class="Symbol">=</a><a name="14364"> </a><a name="14365" href="/2016/one-lambda-calculus-many-times/#13984" class="Datatype">Env</a><a name="14368"> </a><a name="14369" href="/2016/one-lambda-calculus-many-times/#14354" class="Bound">Γ</a><a name="14370"> </a><a name="14371" class="Symbol">→</a><a name="14372"> </a><a name="14373" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟦</a><a name="14374"> </a><a name="14375" href="/2016/one-lambda-calculus-many-times/#14358" class="Bound">A</a><a name="14376"> </a><a name="14377" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟧</a></pre>

Let's get to interpreting terms! First off, variables. We can
interpret variables simply by looking them up in the environment:

<pre class="Agda">  <a name="14535" href="/2016/one-lambda-calculus-many-times/#14535" class="Function">lookup</a><a name="14541"> </a><a name="14542" class="Symbol">:</a><a name="14543"> </a><a name="14554" href="/2016/one-lambda-calculus-many-times/#14547" class="Bound">A</a><a name="14555"> </a><a name="14556" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="14557"> </a><a name="14558" href="/2016/one-lambda-calculus-many-times/#14549" class="Bound">Γ</a><a name="14559"> </a><a name="14560" class="Symbol">→</a><a name="14561"> </a><a name="14562" href="/2016/one-lambda-calculus-many-times/#13984" class="Datatype">Env</a><a name="14565"> </a><a name="14566" href="/2016/one-lambda-calculus-many-times/#14549" class="Bound">Γ</a><a name="14567"> </a><a name="14568" class="Symbol">→</a><a name="14569"> </a><a name="14570" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟦</a><a name="14571"> </a><a name="14572" href="/2016/one-lambda-calculus-many-times/#14547" class="Bound">A</a><a name="14573"> </a><a name="14574" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟧</a><a name="14575">
  </a><a name="14578" href="/2016/one-lambda-calculus-many-times/#14535" class="Function">lookup</a><a name="14584"> </a><a name="14585" class="Symbol">(</a><a name="14586" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="14590">  </a><a name="14592" href="/2016/one-lambda-calculus-many-times/#14592" class="Bound">p</a><a name="14593" class="Symbol">)</a><a name="14594"> </a><a name="14595" class="Symbol">(</a><a name="14596" href="/2016/one-lambda-calculus-many-times/#14596" class="Bound">x</a><a name="14597"> </a><a name="14598" href="/2016/one-lambda-calculus-many-times/#14033" class="InductiveConstructor Operator">∷</a><a name="14599"> </a><a name="14600" class="Symbol">_)</a><a name="14602"> </a><a name="14603" class="Keyword">rewrite</a><a name="14610"> </a><a name="14611" href="/2016/one-lambda-calculus-many-times/#14592" class="Bound">p</a><a name="14612"> </a><a name="14613" class="Symbol">=</a><a name="14614"> </a><a name="14615" href="/2016/one-lambda-calculus-many-times/#14596" class="Bound">x</a><a name="14616">
  </a><a name="14619" href="/2016/one-lambda-calculus-many-times/#14535" class="Function">lookup</a><a name="14625"> </a><a name="14626" class="Symbol">(</a><a name="14627" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="14632"> </a><a name="14633" href="/2016/one-lambda-calculus-many-times/#14633" class="Bound">p</a><a name="14634" class="Symbol">)</a><a name="14635"> </a><a name="14636" class="Symbol">(_</a><a name="14638"> </a><a name="14639" href="/2016/one-lambda-calculus-many-times/#14033" class="InductiveConstructor Operator">∷</a><a name="14640"> </a><a name="14641" href="/2016/one-lambda-calculus-many-times/#14641" class="Bound">e</a><a name="14642" class="Symbol">)</a><a name="14643"> </a><a name="14644" class="Symbol">=</a><a name="14645"> </a><a name="14646" href="/2016/one-lambda-calculus-many-times/#14535" class="Function">lookup</a><a name="14652"> </a><a name="14653" href="/2016/one-lambda-calculus-many-times/#14633" class="Bound">p</a><a name="14654"> </a><a name="14655" href="/2016/one-lambda-calculus-many-times/#14641" class="Bound">e</a></pre>


(If you're wondering what we're rewriting by: the <a class="Agda
InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174">here</a>
constructor carries a small proof that the element at the top of the
list is *really* the element you were looking for.)

The translation for natural deduction proofs is, of course, completely
routine---we translate variables withs lookups, introductions by
abstractions and eliminations by applications:

<pre class="Agda">  <a name="15169" class="Keyword">instance</a><a name="15177">
    </a><a name="15182" href="/2016/one-lambda-calculus-many-times/#15182" class="Function">InterpretND</a><a name="15193"> </a><a name="15194" class="Symbol">:</a><a name="15195"> </a><a name="15204" href="/2016/one-lambda-calculus-many-times/#12462" class="Record">Interpret</a><a name="15213"> </a><a name="15214" class="Symbol">(</a><a name="15215" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="15217"> </a><a name="15218" href="/2016/one-lambda-calculus-many-times/#15199" class="Bound">S</a><a name="15219" class="Symbol">)</a><a name="15220"> </a><a name="15221" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟦</a><a name="15222"> </a><a name="15223" href="/2016/one-lambda-calculus-many-times/#15199" class="Bound">S</a><a name="15224"> </a><a name="15225" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟧</a><a name="15226">
    </a><a name="15231" href="/2016/one-lambda-calculus-many-times/#15182" class="Function">InterpretND</a><a name="15242"> </a><a name="15243" class="Symbol">=</a><a name="15244"> </a><a name="15245" class="Keyword">record</a><a name="15251"> </a><a name="15273" class="Keyword">where</a><a name="15278">
        </a><a name="15287" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟦_⟧′</a><a name="15291"> </a><a name="15292" class="Symbol">:</a><a name="15293"> </a><a name="15302" href="/2016/one-lambda-calculus-many-times/#5371" class="Datatype Operator">ND</a><a name="15304"> </a><a name="15305" href="/2016/one-lambda-calculus-many-times/#15297" class="Bound">S</a><a name="15306"> </a><a name="15307" class="Symbol">→</a><a name="15308"> </a><a name="15309" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟦</a><a name="15310"> </a><a name="15311" href="/2016/one-lambda-calculus-many-times/#15297" class="Bound">S</a><a name="15312"> </a><a name="15313" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟧</a><a name="15314">
        </a><a name="15323" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟦</a><a name="15324"> </a><a name="15325" href="/2016/one-lambda-calculus-many-times/#5401" class="InductiveConstructor">ax</a><a name="15327"> </a><a name="15328" href="/2016/one-lambda-calculus-many-times/#15328" class="Bound">p</a><a name="15329">   </a><a name="15332" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟧′</a><a name="15334"> </a><a name="15335" href="/2016/one-lambda-calculus-many-times/#15335" class="Bound">e</a><a name="15336"> </a><a name="15337" class="Symbol">=</a><a name="15338"> </a><a name="15339" href="/2016/one-lambda-calculus-many-times/#14535" class="Function">lookup</a><a name="15345"> </a><a name="15346" href="/2016/one-lambda-calculus-many-times/#15328" class="Bound">p</a><a name="15347"> </a><a name="15348" href="/2016/one-lambda-calculus-many-times/#15335" class="Bound">e</a><a name="15349">
        </a><a name="15358" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟦</a><a name="15359"> </a><a name="15360" href="/2016/one-lambda-calculus-many-times/#5439" class="InductiveConstructor">⇒i</a><a name="15362"> </a><a name="15363" href="/2016/one-lambda-calculus-many-times/#15363" class="Bound">f</a><a name="15364">   </a><a name="15367" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟧′</a><a name="15369"> </a><a name="15370" href="/2016/one-lambda-calculus-many-times/#15370" class="Bound">e</a><a name="15371"> </a><a name="15372" class="Symbol">=</a><a name="15373"> </a><a name="15374" class="Symbol">λ</a><a name="15375"> </a><a name="15376" href="/2016/one-lambda-calculus-many-times/#15376" class="Bound">x</a><a name="15377"> </a><a name="15378" class="Symbol">→</a><a name="15379"> </a><a name="15380" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟦</a><a name="15381"> </a><a name="15382" href="/2016/one-lambda-calculus-many-times/#15363" class="Bound">f</a><a name="15383"> </a><a name="15384" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟧′</a><a name="15386"> </a><a name="15387" class="Symbol">(</a><a name="15388" href="/2016/one-lambda-calculus-many-times/#15376" class="Bound">x</a><a name="15389"> </a><a name="15390" href="/2016/one-lambda-calculus-many-times/#14033" class="InductiveConstructor Operator">∷</a><a name="15391"> </a><a name="15392" href="/2016/one-lambda-calculus-many-times/#15370" class="Bound">e</a><a name="15393" class="Symbol">)</a><a name="15394">
        </a><a name="15403" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟦</a><a name="15404"> </a><a name="15405" href="/2016/one-lambda-calculus-many-times/#5488" class="InductiveConstructor">⇒e</a><a name="15407"> </a><a name="15408" href="/2016/one-lambda-calculus-many-times/#15408" class="Bound">f</a><a name="15409"> </a><a name="15410" href="/2016/one-lambda-calculus-many-times/#15410" class="Bound">g</a><a name="15411"> </a><a name="15412" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟧′</a><a name="15414"> </a><a name="15415" href="/2016/one-lambda-calculus-many-times/#15415" class="Bound">e</a><a name="15416"> </a><a name="15417" class="Symbol">=</a><a name="15418"> </a><a name="15419" class="Symbol">(</a><a name="15420" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟦</a><a name="15421"> </a><a name="15422" href="/2016/one-lambda-calculus-many-times/#15408" class="Bound">f</a><a name="15423"> </a><a name="15424" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟧′</a><a name="15426"> </a><a name="15427" href="/2016/one-lambda-calculus-many-times/#15415" class="Bound">e</a><a name="15428" class="Symbol">)</a><a name="15429"> </a><a name="15430" class="Symbol">(</a><a name="15431" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟦</a><a name="15432"> </a><a name="15433" href="/2016/one-lambda-calculus-many-times/#15410" class="Bound">g</a><a name="15434"> </a><a name="15435" href="/2016/one-lambda-calculus-many-times/#15287" class="Function Operator">⟧′</a><a name="15437"> </a><a name="15438" href="/2016/one-lambda-calculus-many-times/#15415" class="Bound">e</a><a name="15439" class="Symbol">)</a></pre>

Hooray! And even better,  as a corollary, we immediately obtain a
translation from sequent calculus into Agda:

<pre class="Agda">  <a name="15580" class="Keyword">instance</a><a name="15588">
    </a><a name="15593" href="/2016/one-lambda-calculus-many-times/#15593" class="Function">InterpretSC</a><a name="15604"> </a><a name="15605" class="Symbol">:</a><a name="15606"> </a><a name="15615" href="/2016/one-lambda-calculus-many-times/#12462" class="Record">Interpret</a><a name="15624"> </a><a name="15625" class="Symbol">(</a><a name="15626" href="/2016/one-lambda-calculus-many-times/#9785" class="Datatype Operator">SC</a><a name="15628"> </a><a name="15629" href="/2016/one-lambda-calculus-many-times/#15610" class="Bound">S</a><a name="15630" class="Symbol">)</a><a name="15631"> </a><a name="15632" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟦</a><a name="15633"> </a><a name="15634" href="/2016/one-lambda-calculus-many-times/#15610" class="Bound">S</a><a name="15635"> </a><a name="15636" href="/2016/one-lambda-calculus-many-times/#12536" class="Field Operator">⟧</a><a name="15637">
    </a><a name="15642" href="/2016/one-lambda-calculus-many-times/#15593" class="Function">InterpretSC</a><a name="15653"> </a><a name="15654" class="Symbol">=</a><a name="15655"> </a><a name="15656" class="Keyword">record</a><a name="15662"> </a></pre>

Which means that we've now implemented the following functions:

$$
    \begin{array}{ccc}
    ND & \rightarrow & Agda \\
                            \\
    \updownarrow            \\
                            \\
    SC                      \\
    \end{array}
$$



If you are looking for more reading on this topic, I can recommend the
highly readible *[Lambda terms for natural deduction, sequent calculus
and cut elimination][barendregt]* by Henk Barendregt and Silvia Ghilezan.

Next time, I'll talk about Gentzen's LJ, which has explicit structural
rules, and variations which use other, non-list structures as the
antecedent.

---

[agdatutorial]: http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
[noshortcuts]: https://gergo.erdi.hu/blog/2013-05-01-simply_typed_lambda_calculus_in_agda,_without_shortcuts/
[byexample]: http://mazzo.li/posts/Lambda.html
[barendregt]: http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=44279#

[^imports]: This is a good time to note that I'm not showing any of
    the import statements. If you wish to see them, they're there in
    the HTML source. However, it may be much easier to click the
    symbol that confuses you---that should take you directly to its
    definition in the standard library.
