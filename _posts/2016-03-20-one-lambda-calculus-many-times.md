---
title         : One λ-calculus, many times...
date          : 2016-03-20 12:00:00
categories    : [agda, compsci]
tags          : [agda, compsci]
hide_implicit : true
---

Previously, I mentioned that one of the most common posts on Agda blogs
is implementing the simply-typed λ-calculus. [Gergő Érdi][noshortcuts]
even goes as far as to call it the FizzBuzz of dependently-typed
programming, and rightfully so: If you do a quick search, you'll find
dozens of examples.

In *[Dependently-Typed Programming with Agda][agdatutorial]*, Ulf Norell
implements a type checker the simply-typed λ-calculus;
[Francesco Mazzoli][byexample] more or less follows Ulf, but extends
his λ-calculus with a primitive operator for addition; and,
[Gergő Érdi][noshortcuts] extends Ulf's approach with a checker for
scope and binding.

I figured it would be more fun if, instead of rewriting the type
checker example, I would do something a little bit different. So for
my λ-calculus post, I'll have a look at kinds of different ways of
implementing the simply-typed λ-calculus. Today, natural deduction and
the sequent calculus.

<div class="hidden">
<pre class="Agda"><a name="1150" class="Keyword">module</a><a name="1156"> </a><a name="1157" href="/2016/one-lambda-calculus-many-times/#1" class="Module">2016-03-20-one-lambda-calculus-many-times</a><a name="1198"> </a><a name="1199" class="Keyword">where</a></pre>
</div>

### Natural Deduction and the λ-Calculus

We'll start our discussion with the syntax of types. Usually, types
are defined inductively over some set of atomic types. We don't really
care what these atomic types will be, so we might as well abstract
over them:

<pre class="Agda"><a name="1497" class="Keyword">module</a><a name="1503"> </a><a name="1504" href="/2016/one-lambda-calculus-many-times/#1504" class="Module">Syntax</a><a name="1510"> </a><a name="1511" class="Symbol">(</a><a name="1512" href="/2016/one-lambda-calculus-many-times/#1512" class="Bound">Atom</a><a name="1516"> </a><a name="1517" class="Symbol">:</a><a name="1518"> </a><a name="1519" class="PrimitiveType">Set</a><a name="1522" class="Symbol">)</a><a name="1523"> </a><a name="1524" class="Keyword">where</a></pre>

But, if it makes you feel better, we can pretend that they'll be some
like this:

<pre class="Agda Spec">  <a name="511" class="Keyword">data</a><a name="515"> </a><a name="516" href="#289" class="Module">Atom</a><a name="521"> </a><a name="522" class="Symbol">:</a><a name="523"> </a><a name="524" class="PrimitiveType">Set</a><a name="527"> </a><a name="528" class="Keyword">where</a><a name="533"><br />    </a><a name="538" href="#538" class="InductiveConstructor">Int</a><a name="542">    </a><a name="543" class="Symbol">:</a><a name="544"> </a><a name="545" href="#516" class="Datatype">Atom</a><a name="550"><br />    </a><a name="555" href="#555" class="InductiveConstructor">String</a><a name="562"> </a><a name="563" class="Symbol">:</a><a name="564"> </a><a name="565" href="#516" class="Datatype">Atom</a></pre>

Next, we defined our types. Since we're talking about minimal
propositional logic, a type is either atomic (marked by <a class="Agda
InductiveConstructor">El</a>) or an implication:

<pre class="Agda">  <a name="2566" class="Keyword">infixr</a><a name="2572"> </a><a name="2573" class="Number">6</a><a name="2574"> _⇒_

  </a><a name="2582" class="Keyword">data</a><a name="2586"> </a><a name="2587" href="/2016/one-lambda-calculus-many-times/#1157" class="Module">Type</a><a name="2591"> </a><a name="2592" class="Symbol">:</a><a name="2593"> </a><a name="2594" class="PrimitiveType">Set</a><a name="2597"> </a><a name="2598" class="Keyword">where</a><a name="2603">
    </a><a name="2608" href="/2016/one-lambda-calculus-many-times/#2608" class="InductiveConstructor">El</a><a name="2610">  </a><a name="2612" class="Symbol">:</a><a name="2613"> </a><a name="2614" href="/2016/one-lambda-calculus-many-times/#1512" class="Bound">Atom</a><a name="2618"> </a><a name="2619" class="Symbol">→</a><a name="2620"> </a><a name="2621" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="2625">
    </a><a name="2630" href="/2016/one-lambda-calculus-many-times/#2630" class="InductiveConstructor Operator">_⇒_</a><a name="2633"> </a><a name="2634" class="Symbol">:</a><a name="2635"> </a><a name="2636" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="2640"> </a><a name="2641" class="Symbol">→</a><a name="2642"> </a><a name="2643" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="2647"> </a><a name="2648" class="Symbol">→</a><a name="2649"> </a><a name="2650" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a></pre>

Now we'll define sequents. Even though this is just a tiny piece of
syntax, we should put some thought behind it...

Traditionally, the antecedent of some sequent would be a *set* of
formulas. However, we're looking at this from the perspective of
λ-calculus, and there may well be a difference between two terms of
the same type. This is usually solved by changing the antecedent to a
set of *type assignments*, which means $$x : A$$ and $$y : A$$ are now
distinct. From the logical perspective, this is the same as using a
*bag* or *multiset* antecedent. If we were doing mathematics, we'd be
done, but implementation-wise a bag is actually a rather complex
beast. For this reason, we'll use a *list*:[^imports]

<div class="hidden">
<pre class="Agda">  <a name="3418" class="Keyword">open</a><a name="3422"> </a><a name="3423" class="Keyword">import</a><a name="3429"> </a><a name="3430" href="https://agda.github.io/agda-stdlib/Data.Nat.html#1" class="Module" target="_blank">Data.Nat</a><a name="3438">             </a><a name="3451" class="Keyword">using</a><a name="3456"> </a><a name="3457" class="Symbol">(</a><a name="3458">ℕ</a><a name="3459" class="Symbol">;</a><a name="3460"> suc</a><a name="3464" class="Symbol">;</a><a name="3465"> zero</a><a name="3470" class="Symbol">)</a><a name="3471">
  </a><a name="3474" class="Keyword">open</a><a name="3478"> </a><a name="3479" class="Keyword">import</a><a name="3485"> </a><a name="3486" href="https://agda.github.io/agda-stdlib/Data.Fin.html#1" class="Module" target="_blank">Data.Fin</a><a name="3494">             </a><a name="3507" class="Keyword">using</a><a name="3512"> </a><a name="3513" class="Symbol">(</a><a name="3514">Fin</a><a name="3517" class="Symbol">;</a><a name="3518"> suc</a><a name="3522" class="Symbol">;</a><a name="3523"> zero</a><a name="3528" class="Symbol">)</a><a name="3529">
  </a><a name="3532" class="Keyword">open</a><a name="3536"> </a><a name="3537" class="Keyword">import</a><a name="3543"> </a><a name="3544" href="https://agda.github.io/agda-stdlib/Data.List.html#1" class="Module" target="_blank">Data.List</a><a name="3553">            </a><a name="3565" class="Keyword">using</a><a name="3570"> </a><a name="3571" class="Symbol">(</a><a name="3572">List</a><a name="3576" class="Symbol">;</a><a name="3577"> _∷_</a><a name="3581" class="Symbol">;</a><a name="3582"> []</a><a name="3585" class="Symbol">;</a><a name="3586"> _++_</a><a name="3591" class="Symbol">)</a><a name="3592">
  </a><a name="3595" class="Keyword">open</a><a name="3599"> </a><a name="3600" class="Keyword">import</a><a name="3606"> </a><a name="3607" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1" class="Module" target="_blank">Data.List.Any</a><a name="3620">        </a><a name="3628" class="Keyword">using</a><a name="3633"> </a><a name="3634" class="Symbol">(</a><a name="3635" class="Keyword">module</a><a name="3641"> Membership</a><a name="3652" class="Symbol">;</a><a name="3653"> here</a><a name="3658" class="Symbol">;</a><a name="3659"> there</a><a name="3665" class="Symbol">)</a><a name="3666">
  </a><a name="3669" class="Keyword">open</a><a name="3673"> </a><a name="3674" class="Keyword">import</a><a name="3680"> </a><a name="3681" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#1" class="Module" target="_blank">Function.Equivalence</a><a name="3701"> </a><a name="3702" class="Keyword">using</a><a name="3707"> </a><a name="3708" class="Symbol">(</a><a name="3709">_⇔_</a><a name="3712" class="Symbol">;</a><a name="3713"> id</a><a name="3716" class="Symbol">;</a><a name="3717"> map</a><a name="3721" class="Symbol">;</a><a name="3722"> equivalence</a><a name="3734" class="Symbol">)</a><a name="3735">
  </a><a name="3738" class="Keyword">open</a><a name="3742"> </a><a name="3743" class="Keyword">import</a><a name="3749"> </a><a name="3750" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality</a><a name="3787">
  </a><a name="3790" class="Keyword">open</a><a name="3794"> </a><a name="3795" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2298" class="Module" target="_blank">Membership</a><a name="3805"> </a><a name="3806" class="Symbol">(</a><a name="3807" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1526" class="Function" target="_blank">setoid</a><a name="3813"> </a><a name="3814" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="3818" class="Symbol">)</a><a name="3819">    </a><a name="3823" class="Keyword">using</a><a name="3828"> </a><a name="3829" class="Symbol">(</a><a name="3830">_∈_</a><a name="3833" class="Symbol">;</a><a name="3834"> _⊆_</a><a name="3838" class="Symbol">)</a></pre>
</div>
<pre class="Agda">  <a name="3873" class="Keyword">infix</a><a name="3878"> </a><a name="3879" class="Number">4</a><a name="3880"> _⊢_

  </a><a name="3888" class="Keyword">data</a><a name="3892"> </a><a name="3893" href="/2016/one-lambda-calculus-many-times/#1157" class="Module">Sequent</a><a name="3900"> </a><a name="3901" class="Symbol">:</a><a name="3902"> </a><a name="3903" class="PrimitiveType">Set</a><a name="3906"> </a><a name="3907" class="Keyword">where</a><a name="3912">
    </a><a name="3917" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">_⊢_</a><a name="3920"> </a><a name="3921" class="Symbol">:</a><a name="3922"> </a><a name="3923" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#669" class="Datatype" target="_blank">List</a><a name="3927"> </a><a name="3928" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="3932"> </a><a name="3933" class="Symbol">→</a><a name="3934"> </a><a name="3935" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="3939"> </a><a name="3940" class="Symbol">→</a><a name="3941"> </a><a name="3942" href="/2016/one-lambda-calculus-many-times/#3893" class="Datatype">Sequent</a></pre>

So what does a *proof* of a sequent look like? The logical system that
is most familiar to a computer scientist is probably *natural
deduction*. The natural deduction system for minimal propositional
logic has *three* rules:

$$
    \frac{A \in \Gamma}{\Gamma \vdash A}{\small ax}
    \quad
    \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!i}
    \quad
    \frac{\Gamma \vdash A \Rightarrow B \quad \Gamma \vdash A}{\Gamma \vdash B}{\small{\Rightarrow}\!e}
$$

Recall that λ-terms are constructed in one of three ways: a λ-term is
either a *variable*, an *abstraction* or an *application*:

$$
    M, N ::= x \mid (\lambda x . M) \mid (M\;N)
$$

These correspond exactly to the rules of natural deduction. In fact,
in type systems they are usually presented together:

$$
    \frac{(x : A) \in \Gamma}{\Gamma \vdash x : A}
    \quad
    \frac{x : A , \Gamma \vdash M : B}{\Gamma \vdash (\lambda x. M) : A \Rightarrow B}
    \quad
    \frac{\Gamma \vdash M : A \Rightarrow B \quad \Gamma \vdash N : A}{\Gamma \vdash (M\;N) : B}
$$

However, I like the clean look of the logical notation, so in the
interest of keeping things simple I will use that.
We encode the natural deduction system as a datatype, with each rule
corresponding to a *constructor*, and each proof a *value*:

<pre class="Agda">  <a name="5289" class="Keyword">infix</a><a name="5294"> </a><a name="5295" class="Number">3</a><a name="5296"> ND_

  </a><a name="5304" class="Keyword">data</a><a name="5308"> </a><a name="5309" href="/2016/one-lambda-calculus-many-times/#1157" class="Module">ND_</a><a name="5312"> </a><a name="5313" class="Symbol">:</a><a name="5314"> </a><a name="5315" href="/2016/one-lambda-calculus-many-times/#3893" class="Datatype">Sequent</a><a name="5322"> </a><a name="5323" class="Symbol">→</a><a name="5324"> </a><a name="5325" class="PrimitiveType">Set</a><a name="5328"> </a><a name="5329" class="Keyword">where</a><a name="5334">
    </a><a name="5339" href="/2016/one-lambda-calculus-many-times/#5339" class="InductiveConstructor">ax</a><a name="5341"> </a><a name="5342" class="Symbol">:</a><a name="5343"> </a><a name="5356" href="/2016/one-lambda-calculus-many-times/#5347" class="Bound">A</a><a name="5357"> </a><a name="5358" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="5359"> </a><a name="5360" href="/2016/one-lambda-calculus-many-times/#5351" class="Bound">Γ</a><a name="5361"> </a><a name="5362" class="Symbol">→</a><a name="5363"> </a><a name="5364" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="5366"> </a><a name="5367" href="/2016/one-lambda-calculus-many-times/#5351" class="Bound">Γ</a><a name="5368"> </a><a name="5369" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="5370"> </a><a name="5371" href="/2016/one-lambda-calculus-many-times/#5347" class="Bound">A</a><a name="5372">
    </a><a name="5377" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="5379"> </a><a name="5380" class="Symbol">:</a><a name="5381"> </a><a name="5394" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="5396"> </a><a name="5397" href="/2016/one-lambda-calculus-many-times/#5385" class="Bound">A</a><a name="5398"> </a><a name="5399" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="5400"> </a><a name="5401" href="/2016/one-lambda-calculus-many-times/#5389" class="Bound">Γ</a><a name="5402"> </a><a name="5403" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="5404"> </a><a name="5405" href="/2016/one-lambda-calculus-many-times/#5387" class="Bound">B</a><a name="5406"> </a><a name="5407" class="Symbol">→</a><a name="5408"> </a><a name="5409" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="5411"> </a><a name="5412" href="/2016/one-lambda-calculus-many-times/#5389" class="Bound">Γ</a><a name="5413"> </a><a name="5414" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="5415"> </a><a name="5416" href="/2016/one-lambda-calculus-many-times/#5385" class="Bound">A</a><a name="5417"> </a><a name="5418" href="/2016/one-lambda-calculus-many-times/#2630" class="InductiveConstructor Operator">⇒</a><a name="5419"> </a><a name="5420" href="/2016/one-lambda-calculus-many-times/#5387" class="Bound">B</a><a name="5421">
    </a><a name="5426" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="5428"> </a><a name="5429" class="Symbol">:</a><a name="5430"> </a><a name="5443" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="5445"> </a><a name="5446" href="/2016/one-lambda-calculus-many-times/#5438" class="Bound">Γ</a><a name="5447"> </a><a name="5448" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="5449"> </a><a name="5450" href="/2016/one-lambda-calculus-many-times/#5434" class="Bound">A</a><a name="5451"> </a><a name="5452" href="/2016/one-lambda-calculus-many-times/#2630" class="InductiveConstructor Operator">⇒</a><a name="5453"> </a><a name="5454" href="/2016/one-lambda-calculus-many-times/#5436" class="Bound">B</a><a name="5455"> </a><a name="5456" class="Symbol">→</a><a name="5457"> </a><a name="5458" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="5460"> </a><a name="5461" href="/2016/one-lambda-calculus-many-times/#5438" class="Bound">Γ</a><a name="5462"> </a><a name="5463" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="5464"> </a><a name="5465" href="/2016/one-lambda-calculus-many-times/#5434" class="Bound">A</a><a name="5466"> </a><a name="5467" class="Symbol">→</a><a name="5468"> </a><a name="5469" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="5471"> </a><a name="5472" href="/2016/one-lambda-calculus-many-times/#5438" class="Bound">Γ</a><a name="5473"> </a><a name="5474" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="5475"> </a><a name="5476" href="/2016/one-lambda-calculus-many-times/#5436" class="Bound">B</a></pre>

Note: for the sake of brevity, I'm using an Agda notation in which
implicit arguments are hidden. That means that any unbound
variable---such as the As, Bs and Γs above---is implicitly universally
quantified.

I prefer to think of things of the type <a class="Agda Datatype
Operator">ND</a> as proofs made up of rules, but if you prefer to
think of them as programs made up of the constructors of lambda terms,
just use the following syntax:

<pre class="Agda">  <a name="5948" class="Keyword">pattern</a><a name="5955"> </a><a name="5956" href="/2016/one-lambda-calculus-many-times/#5956" class="InductiveConstructor">var</a><a name="5959">   </a><a name="5962" href="/2016/one-lambda-calculus-many-times/#5971" class="Bound">x</a><a name="5963"> </a><a name="5964" class="Symbol">=</a><a name="5965"> </a><a name="5966" href="/2016/one-lambda-calculus-many-times/#5339" class="InductiveConstructor">ax</a><a name="5968">   </a><a name="5971" href="/2016/one-lambda-calculus-many-times/#5971" class="Bound">x</a><a name="5972">
  </a><a name="5975" class="Keyword">pattern</a><a name="5982"> </a><a name="5983" href="/2016/one-lambda-calculus-many-times/#5983" class="InductiveConstructor">lam</a><a name="5986">   </a><a name="5989" href="/2016/one-lambda-calculus-many-times/#5998" class="Bound">x</a><a name="5990"> </a><a name="5991" class="Symbol">=</a><a name="5992"> </a><a name="5993" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="5995">   </a><a name="5998" href="/2016/one-lambda-calculus-many-times/#5998" class="Bound">x</a><a name="5999">
  </a><a name="6002" class="Keyword">pattern</a><a name="6009"> </a><a name="6010" href="/2016/one-lambda-calculus-many-times/#6010" class="InductiveConstructor Operator">_∙_</a><a name="6013"> </a><a name="6014" href="/2016/one-lambda-calculus-many-times/#6023" class="Bound">f</a><a name="6015"> </a><a name="6016" href="/2016/one-lambda-calculus-many-times/#6025" class="Bound">x</a><a name="6017"> </a><a name="6018" class="Symbol">=</a><a name="6019"> </a><a name="6020" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="6022"> </a><a name="6023" href="/2016/one-lambda-calculus-many-times/#6023" class="Bound">f</a><a name="6024"> </a><a name="6025" href="/2016/one-lambda-calculus-many-times/#6025" class="Bound">x</a></pre>

Earlier, we made the conscious choice to use *lists* to represent the
antecedent. However, this introduced a minor problem: while two
programs of the same type may not do the same thing, they *should* be
equivalent, as far as the type system is concerned, and so it *should*
be possible to rewrite a program which needs *two* values of type
$$A$$ to a program which needs only *one*.

Similarily, by using lists, we have introduced a fixed order in our
antecedent which isn't exactly desirable. While they may be different
programs, we *should* be able to rewrite the program $$f : A\to B\to C$$
to receive its arguments in the different order, i.e. to a program
$$f\prime : B\to A\to C$$.

Collectively, such properties are known as *structural* properties,
and for this particular logic we can summarise them neatly as follows:

> If $$\Gamma \subseteq \Gamma\prime$$ and $$\Gamma \vdash A$$, then
> $$\Gamma\prime \vdash A$$.

We can give a proof of this theorem by induction on the structure of
natural deduction proofs. Note that we represent the subset relation
as a *function*, that is to say $$\Gamma \subseteq \Gamma\prime$$ is
the *function* $$A\in\Gamma\to A\in\Gamma\prime$$:

<pre class="Agda">  <a name="7243" href="/2016/one-lambda-calculus-many-times/#7243" class="Function">struct</a><a name="7249"> </a><a name="7250" class="Symbol">:</a><a name="7251"> </a><a name="7265" href="/2016/one-lambda-calculus-many-times/#7257" class="Bound">Γ</a><a name="7266"> </a><a name="7267" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7268"> </a><a name="7269" href="/2016/one-lambda-calculus-many-times/#7259" class="Bound">Γ′</a><a name="7271"> </a><a name="7272" class="Symbol">→</a><a name="7273"> </a><a name="7274" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="7276"> </a><a name="7277" href="/2016/one-lambda-calculus-many-times/#7257" class="Bound">Γ</a><a name="7278"> </a><a name="7279" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="7280"> </a><a name="7281" href="/2016/one-lambda-calculus-many-times/#7255" class="Bound">A</a><a name="7282"> </a><a name="7283" class="Symbol">→</a><a name="7284"> </a><a name="7285" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="7287"> </a><a name="7288" href="/2016/one-lambda-calculus-many-times/#7259" class="Bound">Γ′</a><a name="7290"> </a><a name="7291" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="7292"> </a><a name="7293" href="/2016/one-lambda-calculus-many-times/#7255" class="Bound">A</a><a name="7294">
  </a><a name="7297" href="/2016/one-lambda-calculus-many-times/#7243" class="Function">struct</a><a name="7303"> </a><a name="7304" href="/2016/one-lambda-calculus-many-times/#7304" class="Bound">Γ⊆Γ′</a><a name="7308"> </a><a name="7309" class="Symbol">(</a><a name="7310" href="/2016/one-lambda-calculus-many-times/#5339" class="InductiveConstructor">ax</a><a name="7312"> </a><a name="7313" href="/2016/one-lambda-calculus-many-times/#7313" class="Bound">x</a><a name="7314" class="Symbol">)</a><a name="7315">   </a><a name="7318" class="Symbol">=</a><a name="7319"> </a><a name="7320" href="/2016/one-lambda-calculus-many-times/#5339" class="InductiveConstructor">ax</a><a name="7322"> </a><a name="7323" class="Symbol">(</a><a name="7324" href="/2016/one-lambda-calculus-many-times/#7304" class="Bound">Γ⊆Γ′</a><a name="7328"> </a><a name="7329" href="/2016/one-lambda-calculus-many-times/#7313" class="Bound">x</a><a name="7330" class="Symbol">)</a><a name="7331">
  </a><a name="7334" href="/2016/one-lambda-calculus-many-times/#7243" class="Function">struct</a><a name="7340"> </a><a name="7341" href="/2016/one-lambda-calculus-many-times/#7341" class="Bound">Γ⊆Γ′</a><a name="7345"> </a><a name="7346" class="Symbol">(</a><a name="7347" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="7349"> </a><a name="7350" href="/2016/one-lambda-calculus-many-times/#7350" class="Bound">f</a><a name="7351" class="Symbol">)</a><a name="7352">   </a><a name="7355" class="Symbol">=</a><a name="7356"> </a><a name="7357" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="7359"> </a><a name="7360" class="Symbol">(</a><a name="7361" href="/2016/one-lambda-calculus-many-times/#7243" class="Function">struct</a><a name="7367"> </a><a name="7368" class="Symbol">(</a><a name="7369" href="/2016/one-lambda-calculus-many-times/#7404" class="Function">∷-resp-⊆</a><a name="7377"> </a><a name="7378" href="/2016/one-lambda-calculus-many-times/#7341" class="Bound">Γ⊆Γ′</a><a name="7382" class="Symbol">)</a><a name="7383"> </a><a name="7384" href="/2016/one-lambda-calculus-many-times/#7350" class="Bound">f</a><a name="7385" class="Symbol">)</a><a name="7386">
    </a><a name="7391" class="Keyword">where</a><a name="7396">

      </a><a name="7404" href="/2016/one-lambda-calculus-many-times/#7404" class="Function">∷-resp-⊆</a><a name="7412"> </a><a name="7413" class="Symbol">:</a><a name="7414"> </a><a name="7428" href="/2016/one-lambda-calculus-many-times/#7420" class="Bound">Γ</a><a name="7429"> </a><a name="7430" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7431"> </a><a name="7432" href="/2016/one-lambda-calculus-many-times/#7422" class="Bound">Γ′</a><a name="7434"> </a><a name="7435" class="Symbol">→</a><a name="7436"> </a><a name="7437" href="/2016/one-lambda-calculus-many-times/#7418" class="Bound">A</a><a name="7438"> </a><a name="7439" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="7440"> </a><a name="7441" href="/2016/one-lambda-calculus-many-times/#7420" class="Bound">Γ</a><a name="7442"> </a><a name="7443" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#3056" class="Function Operator" target="_blank">⊆</a><a name="7444"> </a><a name="7445" href="/2016/one-lambda-calculus-many-times/#7418" class="Bound">A</a><a name="7446"> </a><a name="7447" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="7448"> </a><a name="7449" href="/2016/one-lambda-calculus-many-times/#7422" class="Bound">Γ′</a><a name="7451">
      </a><a name="7458" href="/2016/one-lambda-calculus-many-times/#7404" class="Function">∷-resp-⊆</a><a name="7466"> </a><a name="7467" href="/2016/one-lambda-calculus-many-times/#7467" class="Bound">Γ⊆Γ′</a><a name="7471"> </a><a name="7472" class="Symbol">(</a><a name="7473" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="7477">  </a><a name="7479" href="/2016/one-lambda-calculus-many-times/#7479" class="Bound">x</a><a name="7480" class="Symbol">)</a><a name="7481"> </a><a name="7482" class="Symbol">=</a><a name="7483"> </a><a name="7484" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="7488"> </a><a name="7489" href="/2016/one-lambda-calculus-many-times/#7479" class="Bound">x</a><a name="7490">
      </a><a name="7497" href="/2016/one-lambda-calculus-many-times/#7404" class="Function">∷-resp-⊆</a><a name="7505"> </a><a name="7506" href="/2016/one-lambda-calculus-many-times/#7506" class="Bound">Γ⊆Γ′</a><a name="7510"> </a><a name="7511" class="Symbol">(</a><a name="7512" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="7517"> </a><a name="7518" href="/2016/one-lambda-calculus-many-times/#7518" class="Bound">x</a><a name="7519" class="Symbol">)</a><a name="7520"> </a><a name="7521" class="Symbol">=</a><a name="7522"> </a><a name="7523" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="7528"> </a><a name="7529" class="Symbol">(</a><a name="7530" href="/2016/one-lambda-calculus-many-times/#7506" class="Bound">Γ⊆Γ′</a><a name="7534"> </a><a name="7535" href="/2016/one-lambda-calculus-many-times/#7518" class="Bound">x</a><a name="7536" class="Symbol">)</a><a name="7537">

  </a><a name="7541" href="/2016/one-lambda-calculus-many-times/#7243" class="Function">struct</a><a name="7547"> </a><a name="7548" href="/2016/one-lambda-calculus-many-times/#7548" class="Bound">Γ⊆Γ′</a><a name="7552"> </a><a name="7553" class="Symbol">(</a><a name="7554" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="7556"> </a><a name="7557" href="/2016/one-lambda-calculus-many-times/#7557" class="Bound">f</a><a name="7558"> </a><a name="7559" href="/2016/one-lambda-calculus-many-times/#7559" class="Bound">g</a><a name="7560" class="Symbol">)</a><a name="7561"> </a><a name="7562" class="Symbol">=</a><a name="7563"> </a><a name="7564" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="7566"> </a><a name="7567" class="Symbol">(</a><a name="7568" href="/2016/one-lambda-calculus-many-times/#7243" class="Function">struct</a><a name="7574"> </a><a name="7575" href="/2016/one-lambda-calculus-many-times/#7548" class="Bound">Γ⊆Γ′</a><a name="7579"> </a><a name="7580" href="/2016/one-lambda-calculus-many-times/#7557" class="Bound">f</a><a name="7581" class="Symbol">)</a><a name="7582"> </a><a name="7583" class="Symbol">(</a><a name="7584" href="/2016/one-lambda-calculus-many-times/#7243" class="Function">struct</a><a name="7590"> </a><a name="7591" href="/2016/one-lambda-calculus-many-times/#7548" class="Bound">Γ⊆Γ′</a><a name="7595"> </a><a name="7596" href="/2016/one-lambda-calculus-many-times/#7559" class="Bound">g</a><a name="7597" class="Symbol">)</a></pre>

Note that values of type $$A\in\Gamma$$ are constructed using <a
class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174">here</a>
and <a class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227">there</a>,
which makes them more or less just numbers, i.e. "first value",
"second value", etc...

I mentioned two uses of this structural rule: contracting two
different variables of the *same* type into one, and exchanging the
order of the types in the antecedent. There is one more canonical use:
*weakning*.
Weakening is so obvious to programmers that they don't really think of
it, but what it says is that if you can run a program in *some*
environment, then you should *certainly* be able to run that program
in that enviroment with some irrelevant stuff added to it. Formally,
we write it as:

<pre class="Agda">  <a name="8541" href="/2016/one-lambda-calculus-many-times/#8541" class="Function">weak</a><a name="8545"> </a><a name="8546" class="Symbol">:</a><a name="8547"> </a><a name="8560" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="8562"> </a><a name="8563" href="/2016/one-lambda-calculus-many-times/#8555" class="Bound">Γ</a><a name="8564"> </a><a name="8565" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="8566"> </a><a name="8567" href="/2016/one-lambda-calculus-many-times/#8553" class="Bound">B</a><a name="8568"> </a><a name="8569" class="Symbol">→</a><a name="8570"> </a><a name="8571" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="8573"> </a><a name="8574" href="/2016/one-lambda-calculus-many-times/#8551" class="Bound">A</a><a name="8575"> </a><a name="8576" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="8577"> </a><a name="8578" href="/2016/one-lambda-calculus-many-times/#8555" class="Bound">Γ</a><a name="8579"> </a><a name="8580" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="8581"> </a><a name="8582" href="/2016/one-lambda-calculus-many-times/#8553" class="Bound">B</a><a name="8583">
  </a><a name="8586" href="/2016/one-lambda-calculus-many-times/#8541" class="Function">weak</a><a name="8590"> </a><a name="8591" class="Symbol">=</a><a name="8592"> </a><a name="8593" href="/2016/one-lambda-calculus-many-times/#7243" class="Function">struct</a><a name="8599"> </a><a name="8600" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a></pre>

Passing <a class="Agda InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227">there</a>
to <a href="#6956" class="Agda Function">struct</a> simply
moves every value by one: the first value becomes the second, the
second becomes the third, etc... In the new antecedent, the first
value will be our "irrelevant stuff".


### Sequent Calculus and Natural Deduction

We've got enough to start talking about the sequent calculus now. The
sequent calculus is a different way of writing down logical systems,
and it has some pros and cons when compared to natural deduction.
It's usual presentation is as follows:

$$
    \frac{A \in \Gamma}{\Gamma \vdash A}{\small ax}
    \quad
    \frac{\Gamma \vdash A \quad A , \Gamma \vdash B}{\Gamma \vdash B}{\small cut}
    \quad
    \frac{\Gamma \vdash A \quad B , \Gamma \vdash C}{A \Rightarrow  B , \Gamma \vdash C}{\small{\Rightarrow}\!l}
    \quad
    \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!r}
$$

We can encode these rules in Agda as follows:

<pre class="Agda">  <a name="9707" class="Keyword">infix</a><a name="9712"> </a><a name="9713" class="Number">3</a><a name="9714"> SC_

  </a><a name="9722" class="Keyword">data</a><a name="9726"> </a><a name="9727" href="/2016/one-lambda-calculus-many-times/#1157" class="Module">SC_</a><a name="9730"> </a><a name="9731" class="Symbol">:</a><a name="9732"> </a><a name="9733" href="/2016/one-lambda-calculus-many-times/#3893" class="Datatype">Sequent</a><a name="9740"> </a><a name="9741" class="Symbol">→</a><a name="9742"> </a><a name="9743" class="PrimitiveType">Set</a><a name="9746"> </a><a name="9747" class="Keyword">where</a><a name="9752">
    </a><a name="9757" href="/2016/one-lambda-calculus-many-times/#9757" class="InductiveConstructor">ax</a><a name="9759">  </a><a name="9761" class="Symbol">:</a><a name="9762"> </a><a name="9777" href="/2016/one-lambda-calculus-many-times/#9766" class="Bound">A</a><a name="9778"> </a><a name="9779" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="9780"> </a><a name="9781" href="/2016/one-lambda-calculus-many-times/#9772" class="Bound">Γ</a><a name="9782"> </a><a name="9783" class="Symbol">→</a><a name="9784"> </a><a name="9785" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9787"> </a><a name="9788" href="/2016/one-lambda-calculus-many-times/#9772" class="Bound">Γ</a><a name="9789"> </a><a name="9790" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9791"> </a><a name="9792" href="/2016/one-lambda-calculus-many-times/#9766" class="Bound">A</a><a name="9793">
    </a><a name="9798" href="/2016/one-lambda-calculus-many-times/#9798" class="InductiveConstructor">cut</a><a name="9801"> </a><a name="9802" class="Symbol">:</a><a name="9803"> </a><a name="9818" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9820"> </a><a name="9821" href="/2016/one-lambda-calculus-many-times/#9813" class="Bound">Γ</a><a name="9822"> </a><a name="9823" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9824"> </a><a name="9825" href="/2016/one-lambda-calculus-many-times/#9807" class="Bound">A</a><a name="9826"> </a><a name="9827" class="Symbol">→</a><a name="9828"> </a><a name="9829" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9831"> </a><a name="9832" href="/2016/one-lambda-calculus-many-times/#9807" class="Bound">A</a><a name="9833"> </a><a name="9834" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9835"> </a><a name="9836" href="/2016/one-lambda-calculus-many-times/#9813" class="Bound">Γ</a><a name="9837"> </a><a name="9838" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9839"> </a><a name="9840" href="/2016/one-lambda-calculus-many-times/#9809" class="Bound">B</a><a name="9841"> </a><a name="9842" class="Symbol">→</a><a name="9843"> </a><a name="9844" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9846"> </a><a name="9847" href="/2016/one-lambda-calculus-many-times/#9813" class="Bound">Γ</a><a name="9848"> </a><a name="9849" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9850"> </a><a name="9851" href="/2016/one-lambda-calculus-many-times/#9809" class="Bound">B</a><a name="9852">
    </a><a name="9857" href="/2016/one-lambda-calculus-many-times/#9857" class="InductiveConstructor">⇒l</a><a name="9859">  </a><a name="9861" class="Symbol">:</a><a name="9862"> </a><a name="9877" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9879"> </a><a name="9880" href="/2016/one-lambda-calculus-many-times/#9872" class="Bound">Γ</a><a name="9881"> </a><a name="9882" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9883"> </a><a name="9884" href="/2016/one-lambda-calculus-many-times/#9866" class="Bound">A</a><a name="9885"> </a><a name="9886" class="Symbol">→</a><a name="9887"> </a><a name="9888" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9890"> </a><a name="9891" href="/2016/one-lambda-calculus-many-times/#9868" class="Bound">B</a><a name="9892"> </a><a name="9893" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9894"> </a><a name="9895" href="/2016/one-lambda-calculus-many-times/#9872" class="Bound">Γ</a><a name="9896"> </a><a name="9897" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9898"> </a><a name="9899" href="/2016/one-lambda-calculus-many-times/#9870" class="Bound">C</a><a name="9900"> </a><a name="9901" class="Symbol">→</a><a name="9902"> </a><a name="9903" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9905"> </a><a name="9906" href="/2016/one-lambda-calculus-many-times/#9866" class="Bound">A</a><a name="9907"> </a><a name="9908" href="/2016/one-lambda-calculus-many-times/#2630" class="InductiveConstructor Operator">⇒</a><a name="9909"> </a><a name="9910" href="/2016/one-lambda-calculus-many-times/#9868" class="Bound">B</a><a name="9911"> </a><a name="9912" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9913"> </a><a name="9914" href="/2016/one-lambda-calculus-many-times/#9872" class="Bound">Γ</a><a name="9915"> </a><a name="9916" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9917"> </a><a name="9918" href="/2016/one-lambda-calculus-many-times/#9870" class="Bound">C</a><a name="9919">
    </a><a name="9924" href="/2016/one-lambda-calculus-many-times/#9924" class="InductiveConstructor">⇒r</a><a name="9926">  </a><a name="9928" class="Symbol">:</a><a name="9929"> </a><a name="9944" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9946"> </a><a name="9947" href="/2016/one-lambda-calculus-many-times/#9933" class="Bound">A</a><a name="9948"> </a><a name="9949" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="9950"> </a><a name="9951" href="/2016/one-lambda-calculus-many-times/#9939" class="Bound">Γ</a><a name="9952"> </a><a name="9953" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9954"> </a><a name="9955" href="/2016/one-lambda-calculus-many-times/#9935" class="Bound">B</a><a name="9956"> </a><a name="9957" class="Symbol">→</a><a name="9958"> </a><a name="9959" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="9961"> </a><a name="9962" href="/2016/one-lambda-calculus-many-times/#9939" class="Bound">Γ</a><a name="9963"> </a><a name="9964" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="9965"> </a><a name="9966" href="/2016/one-lambda-calculus-many-times/#9933" class="Bound">A</a><a name="9967"> </a><a name="9968" href="/2016/one-lambda-calculus-many-times/#2630" class="InductiveConstructor Operator">⇒</a><a name="9969"> </a><a name="9970" href="/2016/one-lambda-calculus-many-times/#9935" class="Bound">B</a></pre>

We will define a few patterns that we'd otherwise have to write out,
over and over again. Namely, names for the first, second, and third
variable in a context:

<pre class="Agda">  <a name="10160" class="Keyword">pattern</a><a name="10167"> </a><a name="10168" href="/2016/one-lambda-calculus-many-times/#10168" class="InductiveConstructor">ax₀</a><a name="10171"> </a><a name="10172" class="Symbol">=</a><a name="10173"> </a><a name="10174" class="InductiveConstructor">ax</a><a name="10176"> </a><a name="10177" class="Symbol">(</a><a name="10178" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10182"> </a><a name="10183" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="10187" class="Symbol">)</a><a name="10188">
  </a><a name="10191" class="Keyword">pattern</a><a name="10198"> </a><a name="10199" href="/2016/one-lambda-calculus-many-times/#10199" class="InductiveConstructor">ax₁</a><a name="10202"> </a><a name="10203" class="Symbol">=</a><a name="10204"> </a><a name="10205" class="InductiveConstructor">ax</a><a name="10207"> </a><a name="10208" class="Symbol">(</a><a name="10209" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10214"> </a><a name="10215" class="Symbol">(</a><a name="10216" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10220"> </a><a name="10221" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="10225" class="Symbol">))</a><a name="10227">
  </a><a name="10230" class="Keyword">pattern</a><a name="10237"> </a><a name="10238" href="/2016/one-lambda-calculus-many-times/#10238" class="InductiveConstructor">ax₂</a><a name="10241"> </a><a name="10242" class="Symbol">=</a><a name="10243"> </a><a name="10244" class="InductiveConstructor">ax</a><a name="10246"> </a><a name="10247" class="Symbol">(</a><a name="10248" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10253"> </a><a name="10254" class="Symbol">(</a><a name="10255" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="10260"> </a><a name="10261" class="Symbol">(</a><a name="10262" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="10266"> </a><a name="10267" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="10271" class="Symbol">)))</a></pre>

It's a little bit of a puzzle, but given <a href="#8254" class="Agda
Function">weak</a> it becomes quite easy to show that the two logics
are in fact equivalent---that they derive the *same sequents*:

<pre class="Agda">  <a name="10504" class="Keyword">module</a><a name="10510"> </a><a name="10511" href="/2016/one-lambda-calculus-many-times/#10511" class="Module">ND⇔SC</a><a name="10516"> </a><a name="10517" class="Keyword">where</a><a name="10522">

    </a><a name="10528" href="/2016/one-lambda-calculus-many-times/#10528" class="Function">⟹</a><a name="10529"> </a><a name="10530" class="Symbol">:</a><a name="10531"> </a><a name="10540" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="10542"> </a><a name="10543" href="/2016/one-lambda-calculus-many-times/#10535" class="Bound">S</a><a name="10544"> </a><a name="10545" class="Symbol">→</a><a name="10546"> </a><a name="10547" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="10549"> </a><a name="10550" href="/2016/one-lambda-calculus-many-times/#10535" class="Bound">S</a><a name="10551">
    </a><a name="10556" href="/2016/one-lambda-calculus-many-times/#10528" class="Function">⟹</a><a name="10557"> </a><a name="10558" class="Symbol">(</a><a name="10559" href="/2016/one-lambda-calculus-many-times/#5339" class="InductiveConstructor">ax</a><a name="10561">  </a><a name="10563" href="/2016/one-lambda-calculus-many-times/#10563" class="Bound">x</a><a name="10564" class="Symbol">)</a><a name="10565">   </a><a name="10568" class="Symbol">=</a><a name="10569"> </a><a name="10570" href="/2016/one-lambda-calculus-many-times/#9757" class="InductiveConstructor">ax</a><a name="10572"> </a><a name="10573" href="/2016/one-lambda-calculus-many-times/#10563" class="Bound">x</a><a name="10574">
    </a><a name="10579" href="/2016/one-lambda-calculus-many-times/#10528" class="Function">⟹</a><a name="10580"> </a><a name="10581" class="Symbol">(</a><a name="10582" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="10584">  </a><a name="10586" href="/2016/one-lambda-calculus-many-times/#10586" class="Bound">f</a><a name="10587" class="Symbol">)</a><a name="10588">   </a><a name="10591" class="Symbol">=</a><a name="10592"> </a><a name="10593" href="/2016/one-lambda-calculus-many-times/#9924" class="InductiveConstructor">⇒r</a><a name="10595">  </a><a name="10597" class="Symbol">(</a><a name="10598" href="/2016/one-lambda-calculus-many-times/#10528" class="Function">⟹</a><a name="10599"> </a><a name="10600" href="/2016/one-lambda-calculus-many-times/#10586" class="Bound">f</a><a name="10601" class="Symbol">)</a><a name="10602">
    </a><a name="10607" href="/2016/one-lambda-calculus-many-times/#10528" class="Function">⟹</a><a name="10608"> </a><a name="10609" class="Symbol">(</a><a name="10610" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="10612">  </a><a name="10614" href="/2016/one-lambda-calculus-many-times/#10614" class="Bound">f</a><a name="10615"> </a><a name="10616" href="/2016/one-lambda-calculus-many-times/#10616" class="Bound">g</a><a name="10617" class="Symbol">)</a><a name="10618"> </a><a name="10619" class="Symbol">=</a><a name="10620"> </a><a name="10621" href="/2016/one-lambda-calculus-many-times/#9798" class="InductiveConstructor">cut</a><a name="10624"> </a><a name="10625" class="Symbol">(</a><a name="10626" href="/2016/one-lambda-calculus-many-times/#10528" class="Function">⟹</a><a name="10627"> </a><a name="10628" href="/2016/one-lambda-calculus-many-times/#10614" class="Bound">f</a><a name="10629" class="Symbol">)</a><a name="10630"> </a><a name="10631" class="Symbol">(</a><a name="10632" href="/2016/one-lambda-calculus-many-times/#9857" class="InductiveConstructor">⇒l</a><a name="10634"> </a><a name="10635" class="Symbol">(</a><a name="10636" href="/2016/one-lambda-calculus-many-times/#10528" class="Function">⟹</a><a name="10637"> </a><a name="10638" href="/2016/one-lambda-calculus-many-times/#10616" class="Bound">g</a><a name="10639" class="Symbol">)</a><a name="10640"> </a><a name="10641" href="/2016/one-lambda-calculus-many-times/#10168" class="InductiveConstructor">ax₀</a><a name="10644" class="Symbol">)</a><a name="10645">

    </a><a name="10651" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10652"> </a><a name="10653" class="Symbol">:</a><a name="10654"> </a><a name="10663" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="10665"> </a><a name="10666" href="/2016/one-lambda-calculus-many-times/#10658" class="Bound">S</a><a name="10667"> </a><a name="10668" class="Symbol">→</a><a name="10669"> </a><a name="10670" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="10672"> </a><a name="10673" href="/2016/one-lambda-calculus-many-times/#10658" class="Bound">S</a><a name="10674">
    </a><a name="10679" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10680"> </a><a name="10681" class="Symbol">(</a><a name="10682" href="/2016/one-lambda-calculus-many-times/#9757" class="InductiveConstructor">ax</a><a name="10684">  </a><a name="10686" href="/2016/one-lambda-calculus-many-times/#10686" class="Bound">p</a><a name="10687" class="Symbol">)</a><a name="10688">   </a><a name="10691" class="Symbol">=</a><a name="10692"> </a><a name="10693" href="/2016/one-lambda-calculus-many-times/#5339" class="InductiveConstructor">ax</a><a name="10695"> </a><a name="10696" href="/2016/one-lambda-calculus-many-times/#10686" class="Bound">p</a><a name="10697">
    </a><a name="10702" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10703"> </a><a name="10704" class="Symbol">(</a><a name="10705" href="/2016/one-lambda-calculus-many-times/#9798" class="InductiveConstructor">cut</a><a name="10708"> </a><a name="10709" href="/2016/one-lambda-calculus-many-times/#10709" class="Bound">f</a><a name="10710"> </a><a name="10711" href="/2016/one-lambda-calculus-many-times/#10711" class="Bound">g</a><a name="10712" class="Symbol">)</a><a name="10713"> </a><a name="10714" class="Symbol">=</a><a name="10715"> </a><a name="10716" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="10718"> </a><a name="10719" class="Symbol">(</a><a name="10720" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="10722"> </a><a name="10723" class="Symbol">(</a><a name="10724" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10725"> </a><a name="10726" href="/2016/one-lambda-calculus-many-times/#10711" class="Bound">g</a><a name="10727" class="Symbol">))</a><a name="10729"> </a><a name="10730" class="Symbol">(</a><a name="10731" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10732"> </a><a name="10733" href="/2016/one-lambda-calculus-many-times/#10709" class="Bound">f</a><a name="10734" class="Symbol">)</a><a name="10735">
    </a><a name="10740" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10741"> </a><a name="10742" class="Symbol">(</a><a name="10743" href="/2016/one-lambda-calculus-many-times/#9857" class="InductiveConstructor">⇒l</a><a name="10745">  </a><a name="10747" href="/2016/one-lambda-calculus-many-times/#10747" class="Bound">f</a><a name="10748"> </a><a name="10749" href="/2016/one-lambda-calculus-many-times/#10749" class="Bound">g</a><a name="10750" class="Symbol">)</a><a name="10751"> </a><a name="10752" class="Symbol">=</a><a name="10753"> </a><a name="10754" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="10756"> </a><a name="10757" class="Symbol">(</a><a name="10758" href="/2016/one-lambda-calculus-many-times/#8541" class="Function">weak</a><a name="10762"> </a><a name="10763" class="Symbol">(</a><a name="10764" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="10766"> </a><a name="10767" class="Symbol">(</a><a name="10768" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10769"> </a><a name="10770" href="/2016/one-lambda-calculus-many-times/#10749" class="Bound">g</a><a name="10771" class="Symbol">)))</a><a name="10774"> </a><a name="10775" class="Symbol">(</a><a name="10776" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="10778"> </a><a name="10779" href="/2016/one-lambda-calculus-many-times/#10168" class="InductiveConstructor">ax₀</a><a name="10782"> </a><a name="10783" class="Symbol">(</a><a name="10784" href="/2016/one-lambda-calculus-many-times/#8541" class="Function">weak</a><a name="10788"> </a><a name="10789" class="Symbol">(</a><a name="10790" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10791"> </a><a name="10792" href="/2016/one-lambda-calculus-many-times/#10747" class="Bound">f</a><a name="10793" class="Symbol">)))</a><a name="10796">
    </a><a name="10801" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10802"> </a><a name="10803" class="Symbol">(</a><a name="10804" href="/2016/one-lambda-calculus-many-times/#9924" class="InductiveConstructor">⇒r</a><a name="10806">  </a><a name="10808" href="/2016/one-lambda-calculus-many-times/#10808" class="Bound">f</a><a name="10809" class="Symbol">)</a><a name="10810">   </a><a name="10813" class="Symbol">=</a><a name="10814"> </a><a name="10815" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="10817"> </a><a name="10818" class="Symbol">(</a><a name="10819" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">⟸</a><a name="10820"> </a><a name="10821" href="/2016/one-lambda-calculus-many-times/#10808" class="Bound">f</a><a name="10822" class="Symbol">)</a></pre>

The rules for sequent calculus obviously no longer correspond *directly*
to the λ-calculus. However, we've just shown that there is in fact
*some* correspondence between them.
In the λ-calculus, computation is represented by β-reduction, which is
the iterative removal of redexes

$$(\lambda x.M)\; N\mapsto M[x := N]$$

Likewise, sequent calculus comes equipped with its own notion of
computation: cut-elimination. And the beautiful thing about cut
elimination is that it has a *very* concrete normal form. Instead of
faffing about, claiming the structure is free of β-redexes, cut
elimination---as its name implies---allows you to remove the entire
structural rule of $$cut$$. It would be interesting to show exactly
what kind of relation cut elimination has to β-reduction...

*Alas*! It may be too much effort for a single post to implement both of
these logics *and* a procedure for cut elimination. However, there
*is* a much simpler thing we can do. Agda itself has a pretty
servicable implementation of β-reduction for Agda terms, and we can
quite easily piggyback on that mechanism. In fact, most of the
articles I linked to at the beginning do exactly this.


### Interpretations in Agda

As a first step, we write down what an interpretation is---and since
we want to use the intepretation brackets in as many places as
possible, we create a type class for it, and give <a href="#12173"
class="Agda Field Operator">⟦_⟧</a> the least restrictive type
possible:

<div class="hidden">
<pre class="Agda"><a name="12342" class="Keyword">open</a><a name="12346"> </a><a name="12347" class="Keyword">import</a><a name="12353"> </a><a name="12354" href="https://agda.github.io/agda-stdlib/Level.html#1" class="Module" target="_blank">Level</a><a name="12359"> </a><a name="12360" class="Keyword">using</a><a name="12365"> </a><a name="12366" class="Symbol">(</a><a name="12367">_⊔_</a><a name="12370" class="Symbol">)</a></pre>
</div>
<pre class="Agda"><a name="12403" class="Keyword">record</a><a name="12409"> </a><a name="12410" href="/2016/one-lambda-calculus-many-times/#12410" class="Record">Interpret</a><a name="12419"> </a><a name="12428" class="Symbol">(</a><a name="12429" href="/2016/one-lambda-calculus-many-times/#12429" class="Bound">A</a><a name="12430"> </a><a name="12431" class="Symbol">:</a><a name="12432"> </a><a name="12433" class="PrimitiveType">Set</a><a name="12436"> </a><a name="12437" href="/2016/one-lambda-calculus-many-times/#12421" class="Bound">a</a><a name="12438" class="Symbol">)</a><a name="12439"> </a><a name="12440" class="Symbol">(</a><a name="12441" href="/2016/one-lambda-calculus-many-times/#12441" class="Bound">B</a><a name="12442"> </a><a name="12443" class="Symbol">:</a><a name="12444"> </a><a name="12445" class="PrimitiveType">Set</a><a name="12448"> </a><a name="12449" href="/2016/one-lambda-calculus-many-times/#12425" class="Bound">b</a><a name="12450" class="Symbol">)</a><a name="12451"> </a><a name="12452" class="Symbol">:</a><a name="12453"> </a><a name="12454" class="PrimitiveType">Set</a><a name="12457"> </a><a name="12458" class="Symbol">(</a><a name="12459" href="/2016/one-lambda-calculus-many-times/#12421" class="Bound">a</a><a name="12460"> </a><a name="12461" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#626" class="Primitive Operator" target="_blank">⊔</a><a name="12462"> </a><a name="12463" href="/2016/one-lambda-calculus-many-times/#12425" class="Bound">b</a><a name="12464" class="Symbol">)</a><a name="12465"> </a><a name="12466" class="Keyword">where</a><a name="12471">
  </a><a name="12474" class="Keyword">field</a><a name="12479">
    </a><a name="12484" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦_⟧</a><a name="12487"> </a><a name="12488" class="Symbol">:</a><a name="12489"> </a><a name="12490" href="/2016/one-lambda-calculus-many-times/#12429" class="Bound">A</a><a name="12491"> </a><a name="12492" class="Symbol">→</a><a name="12493"> </a><a name="12494" href="/2016/one-lambda-calculus-many-times/#12441" class="Bound">B</a><a name="12495">
</a><a name="12496" class="Keyword">open</a><a name="12500"> </a><a name="12501" href="/2016/one-lambda-calculus-many-times/#12410" class="Module">Interpret</a><a name="12510"> </a><a name="12511" class="Symbol">{{...}}</a></pre>

Now, in order to interpret natural deduction proofs in Agda, we'll
need an interpretation for the atomic types. Below we say as much:

<pre class="Agda"><a name="12679" class="Keyword">module</a><a name="12685"> </a><a name="12686" href="/2016/one-lambda-calculus-many-times/#12686" class="Module">Semantics</a><a name="12695"> </a><a name="12696" class="Symbol">(</a><a name="12697" href="/2016/one-lambda-calculus-many-times/#12697" class="Bound">Atom</a><a name="12701"> </a><a name="12702" class="Symbol">:</a><a name="12703"> </a><a name="12704" class="PrimitiveType">Set</a><a name="12707" class="Symbol">)</a><a name="12708"> </a><a name="12709" class="Symbol">(</a><a name="12710" href="/2016/one-lambda-calculus-many-times/#12710" class="Bound">InterpretAtom</a><a name="12723"> </a><a name="12724" class="Symbol">:</a><a name="12725"> </a><a name="12726" href="/2016/one-lambda-calculus-many-times/#12410" class="Record">Interpret</a><a name="12735"> </a><a name="12736" href="/2016/one-lambda-calculus-many-times/#12697" class="Bound">Atom</a><a name="12740"> </a><a name="12741" class="PrimitiveType">Set</a><a name="12744" class="Symbol">)</a><a name="12745"> </a><a name="12746" class="Keyword">where</a></pre>

<div class="hidden">
<pre class="Agda">  <a name="12800" class="Keyword">open</a><a name="12804"> </a><a name="12805" href="/2016/one-lambda-calculus-many-times/#1504" class="Module">Syntax</a><a name="12811"> </a><a name="12812" href="/2016/one-lambda-calculus-many-times/#12697" class="Bound">Atom</a><a name="12816">
  </a><a name="12819" class="Keyword">open</a><a name="12823"> </a><a name="12824" class="Keyword">import</a><a name="12830"> </a><a name="12831" href="https://agda.github.io/agda-stdlib/Data.Empty.html#1" class="Module" target="_blank">Data.Empty</a><a name="12841">           </a><a name="12852" class="Keyword">using</a><a name="12857"> </a><a name="12858" class="Symbol">(</a><a name="12859">⊥-elim</a><a name="12865" class="Symbol">)</a><a name="12866">
  </a><a name="12869" class="Keyword">open</a><a name="12873"> </a><a name="12874" class="Keyword">import</a><a name="12880"> </a><a name="12881" href="https://agda.github.io/agda-stdlib/Data.List.html#1" class="Module" target="_blank">Data.List</a><a name="12890">            </a><a name="12902" class="Keyword">using</a><a name="12907"> </a><a name="12908" class="Symbol">(</a><a name="12909">List</a><a name="12913" class="Symbol">;</a><a name="12914"> _∷_</a><a name="12918" class="Symbol">;</a><a name="12919"> []</a><a name="12922" class="Symbol">;</a><a name="12923"> map</a><a name="12927" class="Symbol">)</a><a name="12928">
  </a><a name="12931" class="Keyword">open</a><a name="12935"> </a><a name="12936" class="Keyword">import</a><a name="12942"> </a><a name="12943" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1" class="Module" target="_blank">Data.List.Any</a><a name="12956">        </a><a name="12964" class="Keyword">using</a><a name="12969"> </a><a name="12970" class="Symbol">(</a><a name="12971" class="Keyword">module</a><a name="12977"> Membership</a><a name="12988" class="Symbol">;</a><a name="12989"> here</a><a name="12994" class="Symbol">;</a><a name="12995"> there</a><a name="13001" class="Symbol">)</a><a name="13002">
  </a><a name="13005" class="Keyword">open</a><a name="13009"> </a><a name="13010" class="Keyword">import</a><a name="13016"> </a><a name="13017" href="https://agda.github.io/agda-stdlib/Function.html#1" class="Module" target="_blank">Function</a><a name="13025">             </a><a name="13038" class="Keyword">using</a><a name="13043"> </a><a name="13044" class="Symbol">(</a><a name="13045">_∘_</a><a name="13048" class="Symbol">)</a><a name="13049">
  </a><a name="13052" class="Keyword">open</a><a name="13056"> </a><a name="13057" class="Keyword">import</a><a name="13063"> </a><a name="13064" href="https://agda.github.io/agda-stdlib/Function.Equality.html#1" class="Module" target="_blank">Function.Equality</a><a name="13081">    </a><a name="13085" class="Keyword">using</a><a name="13090"> </a><a name="13091" class="Symbol">(</a><a name="13092">_⟨$⟩_</a><a name="13097" class="Symbol">)</a><a name="13098">
  </a><a name="13101" class="Keyword">open</a><a name="13105"> </a><a name="13106" class="Keyword">import</a><a name="13112"> </a><a name="13113" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#1" class="Module" target="_blank">Function.Equivalence</a><a name="13133"> </a><a name="13134" class="Keyword">using</a><a name="13139"> </a><a name="13140" class="Symbol">(</a><a name="13141" class="Keyword">module</a><a name="13147"> Equivalence</a><a name="13159" class="Symbol">)</a><a name="13160">
  </a><a name="13163" class="Keyword">open</a><a name="13167"> </a><a name="13168" class="Keyword">import</a><a name="13174"> </a><a name="13175" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality</a><a name="13212">
  </a><a name="13215" class="Keyword">open</a><a name="13219"> </a><a name="13220" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2298" class="Module" target="_blank">Membership</a><a name="13230"> </a><a name="13231" class="Symbol">(</a><a name="13232" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1526" class="Function" target="_blank">setoid</a><a name="13238"> </a><a name="13239" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="13243" class="Symbol">)</a><a name="13244">    </a><a name="13248" class="Keyword">using</a><a name="13253"> </a><a name="13254" class="Symbol">(</a><a name="13255">_∈_</a><a name="13258" class="Symbol">;</a><a name="13259"> _⊆_</a><a name="13263" class="Symbol">)</a><a name="13264">
  </a><a name="13267" class="Keyword">open</a><a name="13271"> </a><a name="13272" href="https://agda.github.io/agda-stdlib/Function.Equivalence.html#488" class="Module" target="_blank">Equivalence</a><a name="13283">                 </a><a name="13300" class="Keyword">using</a><a name="13305"> </a><a name="13306" class="Symbol">(</a><a name="13307">to</a><a name="13309" class="Symbol">;</a><a name="13310"> from</a><a name="13315" class="Symbol">)</a></pre>
</div>

Unsurprisingly, we interpret the implication as Agda's function type:

<pre class="Agda">  <a name="13422" class="Keyword">instance</a><a name="13430">
    </a><a name="13435" href="/2016/one-lambda-calculus-many-times/#13435" class="Function">InterpretType</a><a name="13448"> </a><a name="13449" class="Symbol">:</a><a name="13450"> </a><a name="13451" href="/2016/one-lambda-calculus-many-times/#12410" class="Record">Interpret</a><a name="13460"> </a><a name="13461" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="13465"> </a><a name="13466" class="PrimitiveType">Set</a><a name="13469">
    </a><a name="13474" href="/2016/one-lambda-calculus-many-times/#13435" class="Function">InterpretType</a><a name="13487"> </a><a name="13488" class="Symbol">=</a><a name="13489"> </a><a name="13490" class="Keyword">record</a><a name="13496"> </a><a name="13518" class="Keyword">where</a><a name="13523">
        </a><a name="13532" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟦_⟧′</a><a name="13536">  </a><a name="13538" class="Symbol">:</a><a name="13539"> </a><a name="13540" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="13544"> </a><a name="13545" class="Symbol">→</a><a name="13546"> </a><a name="13547" class="PrimitiveType">Set</a><a name="13550">
        </a><a name="13559" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟦</a><a name="13560"> </a><a name="13561" href="/2016/one-lambda-calculus-many-times/#2608" class="InductiveConstructor">El</a><a name="13563">  </a><a name="13565" href="/2016/one-lambda-calculus-many-times/#13565" class="Bound">A</a><a name="13566"> </a><a name="13567" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟧′</a><a name="13569"> </a><a name="13570" class="Symbol">=</a><a name="13571"> </a><a name="13572" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="13573"> </a><a name="13574" href="/2016/one-lambda-calculus-many-times/#13565" class="Bound">A</a><a name="13575"> </a><a name="13576" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="13577">
        </a><a name="13586" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟦</a><a name="13587"> </a><a name="13588" href="/2016/one-lambda-calculus-many-times/#13588" class="Bound">A</a><a name="13589"> </a><a name="13590" href="/2016/one-lambda-calculus-many-times/#2630" class="InductiveConstructor Operator">⇒</a><a name="13591"> </a><a name="13592" href="/2016/one-lambda-calculus-many-times/#13592" class="Bound">B</a><a name="13593"> </a><a name="13594" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟧′</a><a name="13596"> </a><a name="13597" class="Symbol">=</a><a name="13598"> </a><a name="13599" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟦</a><a name="13600"> </a><a name="13601" href="/2016/one-lambda-calculus-many-times/#13588" class="Bound">A</a><a name="13602"> </a><a name="13603" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟧′</a><a name="13605"> </a><a name="13606" class="Symbol">→</a><a name="13607"> </a><a name="13608" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟦</a><a name="13609"> </a><a name="13610" href="/2016/one-lambda-calculus-many-times/#13592" class="Bound">B</a><a name="13611"> </a><a name="13612" href="/2016/one-lambda-calculus-many-times/#13532" class="Function Operator">⟧′</a></pre>

In order to interpret sequents, we'll need an interpretation for the
antecedent. For this we'll create a type for *environments*, <a
class="Agda Datatype">Env</a>, which is indexed by a list of types, and
which stores values of the *interpretations* of those types:

<pre class="Agda">  <a name="13909" class="Keyword">infixr</a><a name="13915"> </a><a name="13916" class="Number">5</a><a name="13917"> _∷_

  </a><a name="13925" class="Keyword">data</a><a name="13929"> </a><a name="13930" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="13933"> </a><a name="13934" class="Symbol">:</a><a name="13935"> </a><a name="13936" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#669" class="Datatype" target="_blank">List</a><a name="13940"> </a><a name="13941" href="/2016/one-lambda-calculus-many-times/#2587" class="Datatype">Type</a><a name="13945"> </a><a name="13946" class="Symbol">→</a><a name="13947"> </a><a name="13948" class="PrimitiveType">Set</a><a name="13951"> </a><a name="13952" class="Keyword">where</a><a name="13957">
    </a><a name="13962" href="/2016/one-lambda-calculus-many-times/#13962" class="InductiveConstructor">[]</a><a name="13964">  </a><a name="13966" class="Symbol">:</a><a name="13967"> </a><a name="13968" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="13971"> </a><a name="13972" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#706" class="InductiveConstructor" target="_blank">[]</a><a name="13974">
    </a><a name="13979" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">_∷_</a><a name="13982"> </a><a name="13983" class="Symbol">:</a><a name="13984"> </a><a name="14014" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="14015"> </a><a name="14016" href="/2016/one-lambda-calculus-many-times/#13986" class="Bound">A</a><a name="14017"> </a><a name="14018" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="14019"> </a><a name="14020" class="Symbol">→</a><a name="14021"> </a><a name="14022" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="14025"> </a><a name="14026" href="/2016/one-lambda-calculus-many-times/#13997" class="Bound">Γ</a><a name="14027"> </a><a name="14028" class="Symbol">→</a><a name="14029"> </a><a name="14030" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="14033"> </a><a name="14034" class="Symbol">(</a><a name="14035" href="/2016/one-lambda-calculus-many-times/#13986" class="Bound">A</a><a name="14036"> </a><a name="14037" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="14038"> </a><a name="14039" href="/2016/one-lambda-calculus-many-times/#13997" class="Bound">Γ</a><a name="14040" class="Symbol">)</a></pre>

Using this, we can interpret sequents as functions from environments
to values:

<pre class="Agda">  <a name="14150" class="Keyword">instance</a><a name="14158">
    </a><a name="14163" href="/2016/one-lambda-calculus-many-times/#14163" class="Function">InterpretSequent</a><a name="14179"> </a><a name="14180" class="Symbol">:</a><a name="14181"> </a><a name="14182" href="/2016/one-lambda-calculus-many-times/#12410" class="Record">Interpret</a><a name="14191"> </a><a name="14192" href="/2016/one-lambda-calculus-many-times/#3893" class="Datatype">Sequent</a><a name="14199"> </a><a name="14200" class="PrimitiveType">Set</a><a name="14203">
    </a><a name="14208" href="/2016/one-lambda-calculus-many-times/#14163" class="Function">InterpretSequent</a><a name="14224"> </a><a name="14225" class="Symbol">=</a><a name="14226"> </a><a name="14227" class="Keyword">record</a><a name="14233"> </a><a name="14255" class="Keyword">where</a><a name="14260">
        </a><a name="14269" href="/2016/one-lambda-calculus-many-times/#14269" class="Function Operator">⟦_⟧′</a><a name="14273"> </a><a name="14274" class="Symbol">:</a><a name="14275"> </a><a name="14276" href="/2016/one-lambda-calculus-many-times/#3893" class="Datatype">Sequent</a><a name="14283"> </a><a name="14284" class="Symbol">→</a><a name="14285"> </a><a name="14286" class="PrimitiveType">Set</a><a name="14289">
        </a><a name="14298" href="/2016/one-lambda-calculus-many-times/#14269" class="Function Operator">⟦</a><a name="14299"> </a><a name="14300" href="/2016/one-lambda-calculus-many-times/#14300" class="Bound">Γ</a><a name="14301"> </a><a name="14302" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="14303"> </a><a name="14304" href="/2016/one-lambda-calculus-many-times/#14304" class="Bound">A</a><a name="14305"> </a><a name="14306" href="/2016/one-lambda-calculus-many-times/#14269" class="Function Operator">⟧′</a><a name="14308"> </a><a name="14309" class="Symbol">=</a><a name="14310"> </a><a name="14311" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="14314"> </a><a name="14315" href="/2016/one-lambda-calculus-many-times/#14300" class="Bound">Γ</a><a name="14316"> </a><a name="14317" class="Symbol">→</a><a name="14318"> </a><a name="14319" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="14320"> </a><a name="14321" href="/2016/one-lambda-calculus-many-times/#14304" class="Bound">A</a><a name="14322"> </a><a name="14323" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a></pre>

Let's get to interpreting terms! First off, variables. We can
interpret variables simply by looking them up in the environment:

<pre class="Agda">  <a name="14481" href="/2016/one-lambda-calculus-many-times/#14481" class="Function">lookup</a><a name="14487"> </a><a name="14488" class="Symbol">:</a><a name="14489"> </a><a name="14500" href="/2016/one-lambda-calculus-many-times/#14493" class="Bound">A</a><a name="14501"> </a><a name="14502" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#2920" class="Function Operator" target="_blank">∈</a><a name="14503"> </a><a name="14504" href="/2016/one-lambda-calculus-many-times/#14495" class="Bound">Γ</a><a name="14505"> </a><a name="14506" class="Symbol">→</a><a name="14507"> </a><a name="14508" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="14511"> </a><a name="14512" href="/2016/one-lambda-calculus-many-times/#14495" class="Bound">Γ</a><a name="14513"> </a><a name="14514" class="Symbol">→</a><a name="14515"> </a><a name="14516" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="14517"> </a><a name="14518" href="/2016/one-lambda-calculus-many-times/#14493" class="Bound">A</a><a name="14519"> </a><a name="14520" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="14521">
  </a><a name="14524" href="/2016/one-lambda-calculus-many-times/#14481" class="Function">lookup</a><a name="14530"> </a><a name="14531" class="Symbol">(</a><a name="14532" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="14536">  </a><a name="14538" href="/2016/one-lambda-calculus-many-times/#14538" class="Bound">p</a><a name="14539" class="Symbol">)</a><a name="14540"> </a><a name="14541" class="Symbol">(</a><a name="14542" href="/2016/one-lambda-calculus-many-times/#14542" class="Bound">x</a><a name="14543"> </a><a name="14544" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="14545"> </a><a name="14546" class="Symbol">_)</a><a name="14548"> </a><a name="14549" class="Keyword">rewrite</a><a name="14556"> </a><a name="14557" href="/2016/one-lambda-calculus-many-times/#14538" class="Bound">p</a><a name="14558"> </a><a name="14559" class="Symbol">=</a><a name="14560"> </a><a name="14561" href="/2016/one-lambda-calculus-many-times/#14542" class="Bound">x</a><a name="14562">
  </a><a name="14565" href="/2016/one-lambda-calculus-many-times/#14481" class="Function">lookup</a><a name="14571"> </a><a name="14572" class="Symbol">(</a><a name="14573" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1227" class="InductiveConstructor" target="_blank">there</a><a name="14578"> </a><a name="14579" href="/2016/one-lambda-calculus-many-times/#14579" class="Bound">p</a><a name="14580" class="Symbol">)</a><a name="14581"> </a><a name="14582" class="Symbol">(_</a><a name="14584"> </a><a name="14585" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="14586"> </a><a name="14587" href="/2016/one-lambda-calculus-many-times/#14587" class="Bound">e</a><a name="14588" class="Symbol">)</a><a name="14589"> </a><a name="14590" class="Symbol">=</a><a name="14591"> </a><a name="14592" href="/2016/one-lambda-calculus-many-times/#14481" class="Function">lookup</a><a name="14598"> </a><a name="14599" href="/2016/one-lambda-calculus-many-times/#14579" class="Bound">p</a><a name="14600"> </a><a name="14601" href="/2016/one-lambda-calculus-many-times/#14587" class="Bound">e</a></pre>


(If you're wondering what we're rewriting by: the <a class="Agda
InductiveConstructor" target="_blank"
href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174">here</a>
constructor carries a small proof that the element at the top of the
list is *really* the element you were looking for.)

The translation for natural deduction proofs is, of course, completely
routine---we translate variables withs lookups, introductions by
abstractions and eliminations by applications:

<pre class="Agda">  <a name="15115" class="Keyword">instance</a><a name="15123">
    </a><a name="15128" href="/2016/one-lambda-calculus-many-times/#15128" class="Function">InterpretND</a><a name="15139"> </a><a name="15140" class="Symbol">:</a><a name="15141"> </a><a name="15150" href="/2016/one-lambda-calculus-many-times/#12410" class="Record">Interpret</a><a name="15159"> </a><a name="15160" class="Symbol">(</a><a name="15161" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="15163"> </a><a name="15164" href="/2016/one-lambda-calculus-many-times/#15145" class="Bound">S</a><a name="15165" class="Symbol">)</a><a name="15166"> </a><a name="15167" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="15168"> </a><a name="15169" href="/2016/one-lambda-calculus-many-times/#15145" class="Bound">S</a><a name="15170"> </a><a name="15171" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="15172">
    </a><a name="15177" href="/2016/one-lambda-calculus-many-times/#15128" class="Function">InterpretND</a><a name="15188"> </a><a name="15189" class="Symbol">=</a><a name="15190"> </a><a name="15191" class="Keyword">record</a><a name="15197"> </a><a name="15219" class="Keyword">where</a><a name="15224">
        </a><a name="15233" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟦_⟧′</a><a name="15237"> </a><a name="15238" class="Symbol">:</a><a name="15239"> </a><a name="15248" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="15250"> </a><a name="15251" href="/2016/one-lambda-calculus-many-times/#15243" class="Bound">S</a><a name="15252"> </a><a name="15253" class="Symbol">→</a><a name="15254"> </a><a name="15255" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="15256"> </a><a name="15257" href="/2016/one-lambda-calculus-many-times/#15243" class="Bound">S</a><a name="15258"> </a><a name="15259" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="15260">
        </a><a name="15269" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟦</a><a name="15270"> </a><a name="15271" href="/2016/one-lambda-calculus-many-times/#5339" class="InductiveConstructor">ax</a><a name="15273"> </a><a name="15274" href="/2016/one-lambda-calculus-many-times/#15274" class="Bound">p</a><a name="15275">   </a><a name="15278" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟧′</a><a name="15280"> </a><a name="15281" href="/2016/one-lambda-calculus-many-times/#15281" class="Bound">e</a><a name="15282"> </a><a name="15283" class="Symbol">=</a><a name="15284"> </a><a name="15285" href="/2016/one-lambda-calculus-many-times/#14481" class="Function">lookup</a><a name="15291"> </a><a name="15292" href="/2016/one-lambda-calculus-many-times/#15274" class="Bound">p</a><a name="15293"> </a><a name="15294" href="/2016/one-lambda-calculus-many-times/#15281" class="Bound">e</a><a name="15295">
        </a><a name="15304" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟦</a><a name="15305"> </a><a name="15306" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="15308"> </a><a name="15309" href="/2016/one-lambda-calculus-many-times/#15309" class="Bound">f</a><a name="15310">   </a><a name="15313" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟧′</a><a name="15315"> </a><a name="15316" href="/2016/one-lambda-calculus-many-times/#15316" class="Bound">e</a><a name="15317"> </a><a name="15318" class="Symbol">=</a><a name="15319"> </a><a name="15320" class="Symbol">λ</a><a name="15321"> </a><a name="15322" href="/2016/one-lambda-calculus-many-times/#15322" class="Bound">x</a><a name="15323"> </a><a name="15324" class="Symbol">→</a><a name="15325"> </a><a name="15326" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟦</a><a name="15327"> </a><a name="15328" href="/2016/one-lambda-calculus-many-times/#15309" class="Bound">f</a><a name="15329"> </a><a name="15330" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟧′</a><a name="15332"> </a><a name="15333" class="Symbol">(</a><a name="15334" href="/2016/one-lambda-calculus-many-times/#15322" class="Bound">x</a><a name="15335"> </a><a name="15336" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="15337"> </a><a name="15338" href="/2016/one-lambda-calculus-many-times/#15316" class="Bound">e</a><a name="15339" class="Symbol">)</a><a name="15340">
        </a><a name="15349" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟦</a><a name="15350"> </a><a name="15351" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="15353"> </a><a name="15354" href="/2016/one-lambda-calculus-many-times/#15354" class="Bound">f</a><a name="15355"> </a><a name="15356" href="/2016/one-lambda-calculus-many-times/#15356" class="Bound">g</a><a name="15357"> </a><a name="15358" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟧′</a><a name="15360"> </a><a name="15361" href="/2016/one-lambda-calculus-many-times/#15361" class="Bound">e</a><a name="15362"> </a><a name="15363" class="Symbol">=</a><a name="15364"> </a><a name="15365" class="Symbol">(</a><a name="15366" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟦</a><a name="15367"> </a><a name="15368" href="/2016/one-lambda-calculus-many-times/#15354" class="Bound">f</a><a name="15369"> </a><a name="15370" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟧′</a><a name="15372"> </a><a name="15373" href="/2016/one-lambda-calculus-many-times/#15361" class="Bound">e</a><a name="15374" class="Symbol">)</a><a name="15375"> </a><a name="15376" class="Symbol">(</a><a name="15377" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟦</a><a name="15378"> </a><a name="15379" href="/2016/one-lambda-calculus-many-times/#15356" class="Bound">g</a><a name="15380"> </a><a name="15381" href="/2016/one-lambda-calculus-many-times/#15233" class="Function Operator">⟧′</a><a name="15383"> </a><a name="15384" href="/2016/one-lambda-calculus-many-times/#15361" class="Bound">e</a><a name="15385" class="Symbol">)</a></pre>

Hooray! And even better,  as a corollary, we immediately obtain a
translation from sequent calculus into Agda:

<pre class="Agda">  <a name="15526" class="Keyword">instance</a><a name="15534">
    </a><a name="15539" href="/2016/one-lambda-calculus-many-times/#15539" class="Function">InterpretSC</a><a name="15550"> </a><a name="15551" class="Symbol">:</a><a name="15552"> </a><a name="15561" href="/2016/one-lambda-calculus-many-times/#12410" class="Record">Interpret</a><a name="15570"> </a><a name="15571" class="Symbol">(</a><a name="15572" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="15574"> </a><a name="15575" href="/2016/one-lambda-calculus-many-times/#15556" class="Bound">S</a><a name="15576" class="Symbol">)</a><a name="15577"> </a><a name="15578" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="15579"> </a><a name="15580" href="/2016/one-lambda-calculus-many-times/#15556" class="Bound">S</a><a name="15581"> </a><a name="15582" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="15583">
    </a><a name="15588" href="/2016/one-lambda-calculus-many-times/#15539" class="Function">InterpretSC</a><a name="15599"> </a><a name="15600" class="Symbol">=</a><a name="15601"> </a><a name="15602" class="Keyword">record</a><a name="15608"> </a></pre>

Which means that we've now implemented the following functions:

$$
    \begin{array}{ccc}
    ND & \rightarrow & Agda \\
                            \\
    \updownarrow            \\
                            \\
    SC                      \\
    \end{array}
$$



If you are looking for more reading on this topic, I can recommend the
highly readible *[Lambda terms for natural deduction, sequent calculus
and cut elimination][barendregt]* by Henk Barendregt and Silvia Ghilezan.

Next time, I'll talk about Gentzen's LJ, which has explicit structural
rules, and variations which use other, non-list structures as the
antecedent.

---

[agdatutorial]: http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
[noshortcuts]: https://gergo.erdi.hu/blog/2013-05-01-simply_typed_lambda_calculus_in_agda,_without_shortcuts/
[byexample]: http://mazzo.li/posts/Lambda.html
[barendregt]: http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=44279#

[^imports]: This is a good time to note that I'm not showing any of
    the import statements. If you wish to see them, they're there in
    the HTML source. However, it may be much easier to click the
    symbol that confuses you---that should take you directly to its
    definition in the standard library.


<div class="hidden">
### BONUS!
### The Limit of Intensional Type Theory

Boop.

<pre class="Agda">  <a name="17020" href="/2016/one-lambda-calculus-many-times/#17020" class="Function">ax₀′</a><a name="17024"> </a><a name="17025" class="Symbol">:</a><a name="17026"> </a><a name="17037" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="17040"> </a><a name="17041" class="Symbol">(</a><a name="17042" href="/2016/one-lambda-calculus-many-times/#17030" class="Bound">A</a><a name="17043"> </a><a name="17044" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="17045"> </a><a name="17046" href="/2016/one-lambda-calculus-many-times/#17032" class="Bound">Γ</a><a name="17047" class="Symbol">)</a><a name="17048"> </a><a name="17049" class="Symbol">→</a><a name="17050"> </a><a name="17051" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="17052"> </a><a name="17053" href="/2016/one-lambda-calculus-many-times/#17030" class="Bound">A</a><a name="17054"> </a><a name="17055" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="17056">
  </a><a name="17059" href="/2016/one-lambda-calculus-many-times/#17020" class="Function">ax₀′</a><a name="17063"> </a><a name="17064" class="Symbol">=</a><a name="17065"> </a><a name="17066" href="/2016/one-lambda-calculus-many-times/#14481" class="Function">lookup</a><a name="17072"> </a><a name="17073" class="Symbol">(</a><a name="17074" href="https://agda.github.io/agda-stdlib/Data.List.Any.html#1174" class="InductiveConstructor" target="_blank">here</a><a name="17078"> </a><a name="17079" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="17083" class="Symbol">)</a><a name="17084">

  </a><a name="17088" href="/2016/one-lambda-calculus-many-times/#17088" class="Function">⇒i′</a><a name="17091"> </a><a name="17092" class="Symbol">:</a><a name="17093"> </a><a name="17114" class="Symbol">(</a><a name="17115" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="17118"> </a><a name="17119" class="Symbol">(</a><a name="17120" href="/2016/one-lambda-calculus-many-times/#17097" class="Bound">A</a><a name="17121"> </a><a name="17122" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="17123"> </a><a name="17124" href="/2016/one-lambda-calculus-many-times/#17099" class="Bound">Γ</a><a name="17125" class="Symbol">)</a><a name="17126"> </a><a name="17127" class="Symbol">→</a><a name="17128"> </a><a name="17129" href="/2016/one-lambda-calculus-many-times/#17103" class="Bound">B</a><a name="17130" class="Symbol">)</a><a name="17131"> </a><a name="17132" class="Symbol">→</a><a name="17133"> </a><a name="17134" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="17137"> </a><a name="17138" href="/2016/one-lambda-calculus-many-times/#17099" class="Bound">Γ</a><a name="17139"> </a><a name="17140" class="Symbol">→</a><a name="17141"> </a><a name="17142" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="17143"> </a><a name="17144" href="/2016/one-lambda-calculus-many-times/#17097" class="Bound">A</a><a name="17145"> </a><a name="17146" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="17147"> </a><a name="17148" class="Symbol">→</a><a name="17149"> </a><a name="17150" href="/2016/one-lambda-calculus-many-times/#17103" class="Bound">B</a><a name="17151">
  </a><a name="17154" href="/2016/one-lambda-calculus-many-times/#17088" class="Function">⇒i′</a><a name="17157"> </a><a name="17158" href="/2016/one-lambda-calculus-many-times/#17158" class="Bound">f</a><a name="17159"> </a><a name="17160" href="/2016/one-lambda-calculus-many-times/#17160" class="Bound">e</a><a name="17161"> </a><a name="17162" href="/2016/one-lambda-calculus-many-times/#17162" class="Bound">x</a><a name="17163"> </a><a name="17164" class="Symbol">=</a><a name="17165"> </a><a name="17166" href="/2016/one-lambda-calculus-many-times/#17158" class="Bound">f</a><a name="17167"> </a><a name="17168" class="Symbol">(</a><a name="17169" href="/2016/one-lambda-calculus-many-times/#17162" class="Bound">x</a><a name="17170"> </a><a name="17171" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="17172"> </a><a name="17173" href="/2016/one-lambda-calculus-many-times/#17160" class="Bound">e</a><a name="17174" class="Symbol">)</a><a name="17175">

  </a><a name="17179" href="/2016/one-lambda-calculus-many-times/#17179" class="Function">weak′</a><a name="17184"> </a><a name="17185" class="Symbol">:</a><a name="17186"> </a><a name="17207" class="Symbol">(</a><a name="17208" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="17211"> </a><a name="17212" href="/2016/one-lambda-calculus-many-times/#17192" class="Bound">Γ</a><a name="17213"> </a><a name="17214" class="Symbol">→</a><a name="17215"> </a><a name="17216" href="/2016/one-lambda-calculus-many-times/#17196" class="Bound">B</a><a name="17217" class="Symbol">)</a><a name="17218"> </a><a name="17219" class="Symbol">→</a><a name="17220"> </a><a name="17221" href="/2016/one-lambda-calculus-many-times/#13930" class="Datatype">Env</a><a name="17224"> </a><a name="17225" class="Symbol">(</a><a name="17226" href="/2016/one-lambda-calculus-many-times/#17190" class="Bound">A</a><a name="17227"> </a><a name="17228" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="17229"> </a><a name="17230" href="/2016/one-lambda-calculus-many-times/#17192" class="Bound">Γ</a><a name="17231" class="Symbol">)</a><a name="17232"> </a><a name="17233" class="Symbol">→</a><a name="17234"> </a><a name="17235" href="/2016/one-lambda-calculus-many-times/#17196" class="Bound">B</a><a name="17236">
  </a><a name="17239" href="/2016/one-lambda-calculus-many-times/#17179" class="Function">weak′</a><a name="17244"> </a><a name="17245" href="/2016/one-lambda-calculus-many-times/#17245" class="Bound">f</a><a name="17246"> </a><a name="17247" class="Symbol">(</a><a name="17248" href="/2016/one-lambda-calculus-many-times/#17248" class="Bound">x</a><a name="17249"> </a><a name="17250" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="17251"> </a><a name="17252" href="/2016/one-lambda-calculus-many-times/#17252" class="Bound">e</a><a name="17253" class="Symbol">)</a><a name="17254"> </a><a name="17255" class="Symbol">=</a><a name="17256"> </a><a name="17257" href="/2016/one-lambda-calculus-many-times/#17245" class="Bound">f</a><a name="17258"> </a><a name="17259" href="/2016/one-lambda-calculus-many-times/#17252" class="Bound">e</a></pre>

Boop.

<pre class="Agda">  <a name="17295" class="Keyword">instance</a><a name="17303">
    </a><a name="17308" href="/2016/one-lambda-calculus-many-times/#17308" class="Function">InterpretSC′</a><a name="17320"> </a><a name="17321" class="Symbol">:</a><a name="17322"> </a><a name="17331" href="/2016/one-lambda-calculus-many-times/#12410" class="Record">Interpret</a><a name="17340"> </a><a name="17341" class="Symbol">(</a><a name="17342" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="17344"> </a><a name="17345" href="/2016/one-lambda-calculus-many-times/#17326" class="Bound">S</a><a name="17346" class="Symbol">)</a><a name="17347"> </a><a name="17348" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="17349"> </a><a name="17350" href="/2016/one-lambda-calculus-many-times/#17326" class="Bound">S</a><a name="17351"> </a><a name="17352" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="17353">
    </a><a name="17358" href="/2016/one-lambda-calculus-many-times/#17308" class="Function">InterpretSC′</a><a name="17370"> </a><a name="17371" class="Symbol">=</a><a name="17372"> </a><a name="17373" class="Keyword">record</a><a name="17379"> </a><a name="17401" class="Keyword">where</a><a name="17406">
        </a><a name="17415" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦_⟧′</a><a name="17419"> </a><a name="17420" class="Symbol">:</a><a name="17421"> </a><a name="17430" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="17432"> </a><a name="17433" href="/2016/one-lambda-calculus-many-times/#17425" class="Bound">S</a><a name="17434"> </a><a name="17435" class="Symbol">→</a><a name="17436"> </a><a name="17437" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="17438"> </a><a name="17439" href="/2016/one-lambda-calculus-many-times/#17425" class="Bound">S</a><a name="17440"> </a><a name="17441" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="17442">
        </a><a name="17451" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17452"> </a><a name="17453" href="/2016/one-lambda-calculus-many-times/#9757" class="InductiveConstructor">ax</a><a name="17455">  </a><a name="17457" href="/2016/one-lambda-calculus-many-times/#17457" class="Bound">p</a><a name="17458">   </a><a name="17461" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17463"> </a><a name="17464" href="/2016/one-lambda-calculus-many-times/#17464" class="Bound">e</a><a name="17465"> </a><a name="17466" class="Symbol">=</a><a name="17467"> </a><a name="17468" href="/2016/one-lambda-calculus-many-times/#14481" class="Function">lookup</a><a name="17474"> </a><a name="17475" href="/2016/one-lambda-calculus-many-times/#17457" class="Bound">p</a><a name="17476"> </a><a name="17477" href="/2016/one-lambda-calculus-many-times/#17464" class="Bound">e</a><a name="17478">
        </a><a name="17487" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17488"> </a><a name="17489" href="/2016/one-lambda-calculus-many-times/#9798" class="InductiveConstructor">cut</a><a name="17492"> </a><a name="17493" href="/2016/one-lambda-calculus-many-times/#17493" class="Bound">f</a><a name="17494"> </a><a name="17495" href="/2016/one-lambda-calculus-many-times/#17495" class="Bound">g</a><a name="17496"> </a><a name="17497" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17499"> </a><a name="17500" href="/2016/one-lambda-calculus-many-times/#17500" class="Bound">e</a><a name="17501"> </a><a name="17502" class="Symbol">=</a><a name="17503"> </a><a name="17504" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17505"> </a><a name="17506" href="/2016/one-lambda-calculus-many-times/#17495" class="Bound">g</a><a name="17507"> </a><a name="17508" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17510"> </a><a name="17511" class="Symbol">(</a><a name="17512" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17513"> </a><a name="17514" href="/2016/one-lambda-calculus-many-times/#17493" class="Bound">f</a><a name="17515"> </a><a name="17516" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17518"> </a><a name="17519" href="/2016/one-lambda-calculus-many-times/#17500" class="Bound">e</a><a name="17520"> </a><a name="17521" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="17522"> </a><a name="17523" href="/2016/one-lambda-calculus-many-times/#17500" class="Bound">e</a><a name="17524" class="Symbol">)</a><a name="17525">
        </a><a name="17534" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17535"> </a><a name="17536" href="/2016/one-lambda-calculus-many-times/#9857" class="InductiveConstructor">⇒l</a><a name="17538">  </a><a name="17540" href="/2016/one-lambda-calculus-many-times/#17540" class="Bound">f</a><a name="17541"> </a><a name="17542" href="/2016/one-lambda-calculus-many-times/#17542" class="Bound">g</a><a name="17543"> </a><a name="17544" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17546"> </a><a name="17547" href="/2016/one-lambda-calculus-many-times/#17547" class="Bound">e</a><a name="17548"> </a><a name="17549" class="Symbol">=</a><a name="17550"> </a><a name="17551" class="Symbol">(</a><a name="17552" href="/2016/one-lambda-calculus-many-times/#17179" class="Function">weak′</a><a name="17557"> </a><a name="17558" class="Symbol">(</a><a name="17559" href="/2016/one-lambda-calculus-many-times/#17088" class="Function">⇒i′</a><a name="17562"> </a><a name="17563" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17564"> </a><a name="17565" href="/2016/one-lambda-calculus-many-times/#17542" class="Bound">g</a><a name="17566"> </a><a name="17567" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17569" class="Symbol">))</a><a name="17571"> </a><a name="17572" href="/2016/one-lambda-calculus-many-times/#17547" class="Bound">e</a><a name="17573"> </a><a name="17574" class="Symbol">((</a><a name="17576" href="/2016/one-lambda-calculus-many-times/#17020" class="Function">ax₀′</a><a name="17580"> </a><a name="17581" href="/2016/one-lambda-calculus-many-times/#17547" class="Bound">e</a><a name="17582" class="Symbol">)</a><a name="17583"> </a><a name="17584" class="Symbol">(</a><a name="17585" href="/2016/one-lambda-calculus-many-times/#17179" class="Function">weak′</a><a name="17590"> </a><a name="17591" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17592"> </a><a name="17593" href="/2016/one-lambda-calculus-many-times/#17540" class="Bound">f</a><a name="17594"> </a><a name="17595" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17597"> </a><a name="17598" href="/2016/one-lambda-calculus-many-times/#17547" class="Bound">e</a><a name="17599" class="Symbol">))</a><a name="17601">
        </a><a name="17610" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17611"> </a><a name="17612" href="/2016/one-lambda-calculus-many-times/#9924" class="InductiveConstructor">⇒r</a><a name="17614">  </a><a name="17616" href="/2016/one-lambda-calculus-many-times/#17616" class="Bound">f</a><a name="17617">   </a><a name="17620" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17622"> </a><a name="17623" href="/2016/one-lambda-calculus-many-times/#17623" class="Bound">e</a><a name="17624"> </a><a name="17625" class="Symbol">=</a><a name="17626"> </a><a name="17627" class="Symbol">λ</a><a name="17628"> </a><a name="17629" href="/2016/one-lambda-calculus-many-times/#17629" class="Bound">x</a><a name="17630"> </a><a name="17631" class="Symbol">→</a><a name="17632"> </a><a name="17633" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟦</a><a name="17634"> </a><a name="17635" href="/2016/one-lambda-calculus-many-times/#17616" class="Bound">f</a><a name="17636"> </a><a name="17637" href="/2016/one-lambda-calculus-many-times/#17415" class="Function Operator">⟧′</a><a name="17639"> </a><a name="17640" class="Symbol">(</a><a name="17641" href="/2016/one-lambda-calculus-many-times/#17629" class="Bound">x</a><a name="17642"> </a><a name="17643" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="17644"> </a><a name="17645" href="/2016/one-lambda-calculus-many-times/#17623" class="Bound">e</a><a name="17646" class="Symbol">)</a></pre>

Boop.

<pre class="Agda">  <a name="17682" class="Keyword">module</a><a name="17688"> </a><a name="17689" href="/2016/one-lambda-calculus-many-times/#17689" class="Module">⟦ND⟧⇔⟦SC⟧</a><a name="17698"> </a><a name="17699" class="Keyword">where</a><a name="17704">

    </a><a name="17710" href="/2016/one-lambda-calculus-many-times/#17710" class="Function">⟹</a><a name="17711"> </a><a name="17712" class="Symbol">:</a><a name="17713"> </a><a name="17720" class="Symbol">(</a><a name="17721" href="/2016/one-lambda-calculus-many-times/#17721" class="Bound">f</a><a name="17722"> </a><a name="17723" class="Symbol">:</a><a name="17724"> </a><a name="17725" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="17727"> </a><a name="17728" href="/2016/one-lambda-calculus-many-times/#17717" class="Bound">S</a><a name="17729" class="Symbol">)</a><a name="17730"> </a><a name="17731" class="Symbol">→</a><a name="17732"> </a><a name="17733" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="17734"> </a><a name="17735" href="/2016/one-lambda-calculus-many-times/#17721" class="Bound">f</a><a name="17736"> </a><a name="17737" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="17738"> </a><a name="17739" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="17740"> </a><a name="17741" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="17742"> </a><a name="17743" href="/2016/one-lambda-calculus-many-times/#10528" class="Function">ND⇔SC.⟹</a><a name="17750"> </a><a name="17751" href="/2016/one-lambda-calculus-many-times/#17721" class="Bound">f</a><a name="17752"> </a><a name="17753" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="17754">
    </a><a name="17759" href="/2016/one-lambda-calculus-many-times/#17710" class="Function">⟹</a><a name="17760"> </a><a name="17761" class="Symbol">(</a><a name="17762" href="/2016/one-lambda-calculus-many-times/#5339" class="InductiveConstructor">ax</a><a name="17764"> </a><a name="17765" class="Symbol">_)</a><a name="17767">   </a><a name="17770" class="Symbol">=</a><a name="17771"> </a><a name="17772" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="17776">
    </a><a name="17781" href="/2016/one-lambda-calculus-many-times/#17710" class="Function">⟹</a><a name="17782"> </a><a name="17783" class="Symbol">(</a><a name="17784" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="17786"> </a><a name="17787" href="/2016/one-lambda-calculus-many-times/#17787" class="Bound">f</a><a name="17788" class="Symbol">)</a><a name="17789">   </a><a name="17792" class="Symbol">=</a><a name="17793"> </a><a name="17794" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1036" class="Function" target="_blank">cong</a><a name="17798">  </a><a name="17800" class="Symbol">(λ</a><a name="17802"> </a><a name="17803" href="/2016/one-lambda-calculus-many-times/#17803" class="Bound">f</a><a name="17804"> </a><a name="17805" href="/2016/one-lambda-calculus-many-times/#17805" class="Bound">e</a><a name="17806"> </a><a name="17807" href="/2016/one-lambda-calculus-many-times/#17807" class="Bound">x</a><a name="17808"> </a><a name="17809" class="Symbol">→</a><a name="17810"> </a><a name="17811" href="/2016/one-lambda-calculus-many-times/#17803" class="Bound">f</a><a name="17812"> </a><a name="17813" class="Symbol">(</a><a name="17814" href="/2016/one-lambda-calculus-many-times/#17807" class="Bound">x</a><a name="17815"> </a><a name="17816" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="17817"> </a><a name="17818" href="/2016/one-lambda-calculus-many-times/#17805" class="Bound">e</a><a name="17819" class="Symbol">))</a><a name="17821"> </a><a name="17822" class="Symbol">(</a><a name="17823" href="/2016/one-lambda-calculus-many-times/#17710" class="Function">⟹</a><a name="17824"> </a><a name="17825" href="/2016/one-lambda-calculus-many-times/#17787" class="Bound">f</a><a name="17826" class="Symbol">)</a><a name="17827">
    </a><a name="17832" href="/2016/one-lambda-calculus-many-times/#17710" class="Function">⟹</a><a name="17833"> </a><a name="17834" class="Symbol">(</a><a name="17835" href="/2016/one-lambda-calculus-many-times/#5426" class="InductiveConstructor">⇒e</a><a name="17837"> </a><a name="17838" href="/2016/one-lambda-calculus-many-times/#17838" class="Bound">f</a><a name="17839"> </a><a name="17840" href="/2016/one-lambda-calculus-many-times/#17840" class="Bound">g</a><a name="17841" class="Symbol">)</a><a name="17842"> </a><a name="17843" class="Symbol">=</a><a name="17844"> </a><a name="17845" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1274" class="Function" target="_blank">cong₂</a><a name="17850"> </a><a name="17851" class="Symbol">(λ</a><a name="17853"> </a><a name="17854" href="/2016/one-lambda-calculus-many-times/#17854" class="Bound">f</a><a name="17855"> </a><a name="17856" href="/2016/one-lambda-calculus-many-times/#17856" class="Bound">g</a><a name="17857"> </a><a name="17858" href="/2016/one-lambda-calculus-many-times/#17858" class="Bound">e</a><a name="17859"> </a><a name="17860" class="Symbol">→</a><a name="17861"> </a><a name="17862" href="/2016/one-lambda-calculus-many-times/#17854" class="Bound">f</a><a name="17863"> </a><a name="17864" href="/2016/one-lambda-calculus-many-times/#17858" class="Bound">e</a><a name="17865"> </a><a name="17866" class="Symbol">(</a><a name="17867" href="/2016/one-lambda-calculus-many-times/#17856" class="Bound">g</a><a name="17868"> </a><a name="17869" href="/2016/one-lambda-calculus-many-times/#17858" class="Bound">e</a><a name="17870" class="Symbol">))</a><a name="17872"> </a><a name="17873" class="Symbol">(</a><a name="17874" href="/2016/one-lambda-calculus-many-times/#17710" class="Function">⟹</a><a name="17875"> </a><a name="17876" href="/2016/one-lambda-calculus-many-times/#17838" class="Bound">f</a><a name="17877" class="Symbol">)</a><a name="17878"> </a><a name="17879" class="Symbol">(</a><a name="17880" href="/2016/one-lambda-calculus-many-times/#17710" class="Function">⟹</a><a name="17881"> </a><a name="17882" href="/2016/one-lambda-calculus-many-times/#17840" class="Bound">g</a><a name="17883" class="Symbol">)</a></pre>

Boop.

<pre class="Agda">    <a name="17921" class="Keyword">open</a><a name="17925"> </a><a name="17926" class="Keyword">import</a><a name="17932"> </a><a name="17933" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.TrustMe.html#1" class="Module" target="_blank">Relation.Binary.PropositionalEquality.TrustMe</a><a name="17978"> </a><a name="17979" class="Keyword">renaming</a><a name="17987"> </a><a name="17988" class="Symbol">(</a><a name="17989">trustMe </a><a name="17997" class="Symbol">to</a><a name="17999"> ???</a><a name="18003" class="Symbol">)</a></pre>

<pre class="Agda">    <a name="18034" href="/2016/one-lambda-calculus-many-times/#18034" class="Function">⟸</a><a name="18035"> </a><a name="18036" class="Symbol">:</a><a name="18037"> </a><a name="18044" class="Symbol">(</a><a name="18045" href="/2016/one-lambda-calculus-many-times/#18045" class="Bound">f</a><a name="18046"> </a><a name="18047" class="Symbol">:</a><a name="18048"> </a><a name="18049" href="/2016/one-lambda-calculus-many-times/#9727" class="Datatype Operator">SC</a><a name="18051"> </a><a name="18052" href="/2016/one-lambda-calculus-many-times/#18041" class="Bound">S</a><a name="18053" class="Symbol">)</a><a name="18054"> </a><a name="18055" class="Symbol">→</a><a name="18056"> </a><a name="18057" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18058"> </a><a name="18059" href="/2016/one-lambda-calculus-many-times/#18045" class="Bound">f</a><a name="18060"> </a><a name="18061" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="18062"> </a><a name="18063" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="18064"> </a><a name="18065" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18066"> </a><a name="18067" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">ND⇔SC.⟸</a><a name="18074"> </a><a name="18075" href="/2016/one-lambda-calculus-many-times/#18045" class="Bound">f</a><a name="18076"> </a><a name="18077" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="18078">
    </a><a name="18083" href="/2016/one-lambda-calculus-many-times/#18034" class="Function">⟸</a><a name="18084"> </a><a name="18085" class="Symbol">(</a><a name="18086" href="/2016/one-lambda-calculus-many-times/#9757" class="InductiveConstructor">ax</a><a name="18088">  </a><a name="18090" class="Symbol">_)</a><a name="18092">   </a><a name="18095" class="Symbol">=</a><a name="18096"> </a><a name="18097" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4547" class="InductiveConstructor" target="_blank">refl</a><a name="18101">
    </a><a name="18106" href="/2016/one-lambda-calculus-many-times/#18034" class="Function">⟸</a><a name="18107"> </a><a name="18108" class="Symbol">(</a><a name="18109" href="/2016/one-lambda-calculus-many-times/#9798" class="InductiveConstructor">cut</a><a name="18112"> </a><a name="18113" href="/2016/one-lambda-calculus-many-times/#18113" class="Bound">f</a><a name="18114"> </a><a name="18115" href="/2016/one-lambda-calculus-many-times/#18115" class="Bound">g</a><a name="18116" class="Symbol">)</a><a name="18117"> </a><a name="18118" class="Symbol">=</a><a name="18119"> </a><a name="18120" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1274" class="Function" target="_blank">cong₂</a><a name="18125"> </a><a name="18126" class="Symbol">(λ</a><a name="18128"> </a><a name="18129" href="/2016/one-lambda-calculus-many-times/#18129" class="Bound">f</a><a name="18130"> </a><a name="18131" href="/2016/one-lambda-calculus-many-times/#18131" class="Bound">g</a><a name="18132"> </a><a name="18133" href="/2016/one-lambda-calculus-many-times/#18133" class="Bound">e</a><a name="18134"> </a><a name="18135" class="Symbol">→</a><a name="18136"> </a><a name="18137" href="/2016/one-lambda-calculus-many-times/#18131" class="Bound">g</a><a name="18138"> </a><a name="18139" class="Symbol">(</a><a name="18140" href="/2016/one-lambda-calculus-many-times/#18129" class="Bound">f</a><a name="18141"> </a><a name="18142" href="/2016/one-lambda-calculus-many-times/#18133" class="Bound">e</a><a name="18143"> </a><a name="18144" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="18145"> </a><a name="18146" href="/2016/one-lambda-calculus-many-times/#18133" class="Bound">e</a><a name="18147" class="Symbol">))</a><a name="18149"> </a><a name="18150" class="Symbol">(</a><a name="18151" href="/2016/one-lambda-calculus-many-times/#18034" class="Function">⟸</a><a name="18152"> </a><a name="18153" href="/2016/one-lambda-calculus-many-times/#18113" class="Bound">f</a><a name="18154" class="Symbol">)</a><a name="18155"> </a><a name="18156" class="Symbol">(</a><a name="18157" href="/2016/one-lambda-calculus-many-times/#18034" class="Function">⟸</a><a name="18158"> </a><a name="18159" href="/2016/one-lambda-calculus-many-times/#18115" class="Bound">g</a><a name="18160" class="Symbol">)</a><a name="18161">
    </a><a name="18166" href="/2016/one-lambda-calculus-many-times/#18034" class="Function">⟸</a><a name="18167"> </a><a name="18168" class="Symbol">(</a><a name="18169" href="/2016/one-lambda-calculus-many-times/#9857" class="InductiveConstructor">⇒l</a><a name="18171">  </a><a name="18173" href="/2016/one-lambda-calculus-many-times/#18173" class="Bound">f</a><a name="18174"> </a><a name="18175" href="/2016/one-lambda-calculus-many-times/#18175" class="Bound">g</a><a name="18176" class="Symbol">)</a><a name="18177"> </a><a name="18178" class="Symbol">=</a><a name="18179"> </a><a name="18180" href="/2016/one-lambda-calculus-many-times/#18203" class="Function">lem</a><a name="18183">
      </a><a name="18190" class="Keyword">where</a><a name="18195">

      </a><a name="18203" href="/2016/one-lambda-calculus-many-times/#18203" class="Function">lem</a><a name="18206"> </a><a name="18207" class="Symbol">:</a><a name="18208"> </a><a name="18209" class="Symbol">(λ</a><a name="18211"> </a><a name="18212" href="/2016/one-lambda-calculus-many-times/#18212" class="Bound">e</a><a name="18213"> </a><a name="18214" class="Symbol">→</a><a name="18215"> </a><a name="18216" class="Symbol">(</a><a name="18217"> </a><a name="18218" href="/2016/one-lambda-calculus-many-times/#17179" class="Function">weak′</a><a name="18223"> </a><a name="18224" class="Symbol">(</a><a name="18225" href="/2016/one-lambda-calculus-many-times/#17088" class="Function">⇒i′</a><a name="18228"> </a><a name="18229" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18230"> </a><a name="18231" href="/2016/one-lambda-calculus-many-times/#18175" class="Bound">g</a><a name="18232"> </a><a name="18233" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="18234"> </a><a name="18235" class="Symbol">))</a><a name="18237"> </a><a name="18238" href="/2016/one-lambda-calculus-many-times/#18212" class="Bound">e</a><a name="18239">
                       </a><a name="18263" class="Symbol">(</a><a name="18264" href="/2016/one-lambda-calculus-many-times/#17020" class="Function">ax₀′</a><a name="18268"> </a><a name="18269" href="/2016/one-lambda-calculus-many-times/#18212" class="Bound">e</a><a name="18270"> </a><a name="18271" class="Symbol">(</a><a name="18272" href="/2016/one-lambda-calculus-many-times/#17179" class="Function">weak′</a><a name="18277"> </a><a name="18278" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18279"> </a><a name="18280" href="/2016/one-lambda-calculus-many-times/#18173" class="Bound">f</a><a name="18281"> </a><a name="18282" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="18283"> </a><a name="18284" href="/2016/one-lambda-calculus-many-times/#18212" class="Bound">e</a><a name="18285" class="Symbol">)))</a><a name="18288">

          </a><a name="18300" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="18301"> </a><a name="18302" class="Symbol">(λ</a><a name="18304"> </a><a name="18305" href="/2016/one-lambda-calculus-many-times/#18305" class="Bound">e</a><a name="18306"> </a><a name="18307" class="Symbol">→</a><a name="18308"> </a><a name="18309" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18310"> </a><a name="18311" href="/2016/one-lambda-calculus-many-times/#8541" class="Function">weak</a><a name="18315"> </a><a name="18316" class="Symbol">(</a><a name="18317" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="18319"> </a><a name="18320" class="Symbol">(</a><a name="18321" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">ND⇔SC.⟸</a><a name="18328"> </a><a name="18329" href="/2016/one-lambda-calculus-many-times/#18175" class="Bound">g</a><a name="18330" class="Symbol">))</a><a name="18332"> </a><a name="18333" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="18334"> </a><a name="18335" href="/2016/one-lambda-calculus-many-times/#18305" class="Bound">e</a><a name="18336">
                       </a><a name="18360" class="Symbol">(</a><a name="18361" href="/2016/one-lambda-calculus-many-times/#17020" class="Function">ax₀′</a><a name="18365"> </a><a name="18366" href="/2016/one-lambda-calculus-many-times/#18305" class="Bound">e</a><a name="18367"> </a><a name="18368" class="Symbol">(</a><a name="18369" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18370"> </a><a name="18371" href="/2016/one-lambda-calculus-many-times/#8541" class="Function">weak</a><a name="18375"> </a><a name="18376" class="Symbol">(</a><a name="18377" href="/2016/one-lambda-calculus-many-times/#10651" class="Function">ND⇔SC.⟸</a><a name="18384"> </a><a name="18385" href="/2016/one-lambda-calculus-many-times/#18173" class="Bound">f</a><a name="18386" class="Symbol">)</a><a name="18387"> </a><a name="18388" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="18389"> </a><a name="18390" href="/2016/one-lambda-calculus-many-times/#18305" class="Bound">e</a><a name="18391" class="Symbol">)))</a><a name="18394">
      </a><a name="18401" href="/2016/one-lambda-calculus-many-times/#18203" class="Function">lem</a><a name="18404"> </a><a name="18405" class="Symbol">=</a><a name="18406"> </a><a name="18407" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.TrustMe.html#551" class="Function" target="_blank">???</a><a name="18410">

    </a><a name="18416" href="/2016/one-lambda-calculus-many-times/#18034" class="Function">⟸</a><a name="18417"> </a><a name="18418" class="Symbol">(</a><a name="18419" href="/2016/one-lambda-calculus-many-times/#9924" class="InductiveConstructor">⇒r</a><a name="18421">  </a><a name="18423" href="/2016/one-lambda-calculus-many-times/#18423" class="Bound">f</a><a name="18424" class="Symbol">)</a><a name="18425">   </a><a name="18428" class="Symbol">=</a><a name="18429"> </a><a name="18430" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1036" class="Function" target="_blank">cong</a><a name="18434">  </a><a name="18436" class="Symbol">(λ</a><a name="18438"> </a><a name="18439" href="/2016/one-lambda-calculus-many-times/#18439" class="Bound">f</a><a name="18440"> </a><a name="18441" href="/2016/one-lambda-calculus-many-times/#18441" class="Bound">e</a><a name="18442"> </a><a name="18443" href="/2016/one-lambda-calculus-many-times/#18443" class="Bound">x</a><a name="18444"> </a><a name="18445" class="Symbol">→</a><a name="18446"> </a><a name="18447" href="/2016/one-lambda-calculus-many-times/#18439" class="Bound">f</a><a name="18448"> </a><a name="18449" class="Symbol">(</a><a name="18450" href="/2016/one-lambda-calculus-many-times/#18443" class="Bound">x</a><a name="18451"> </a><a name="18452" href="/2016/one-lambda-calculus-many-times/#13979" class="InductiveConstructor Operator">∷</a><a name="18453"> </a><a name="18454" href="/2016/one-lambda-calculus-many-times/#18441" class="Bound">e</a><a name="18455" class="Symbol">))</a><a name="18457"> </a><a name="18458" class="Symbol">(</a><a name="18459" href="/2016/one-lambda-calculus-many-times/#18034" class="Function">⟸</a><a name="18460"> </a><a name="18461" href="/2016/one-lambda-calculus-many-times/#18423" class="Bound">f</a><a name="18462" class="Symbol">)</a></pre>

Boop.

<pre class="Agda">    <a name="18500" class="Keyword">postulate</a><a name="18509">
      </a><a name="18516" href="/2016/one-lambda-calculus-many-times/#18516" class="Postulate">i⇒≡i⇒′</a><a name="18522">
        </a><a name="18531" class="Symbol">:</a><a name="18532"> </a><a name="18543" class="Symbol">(</a><a name="18544" href="/2016/one-lambda-calculus-many-times/#18544" class="Bound">f</a><a name="18545"> </a><a name="18546" class="Symbol">:</a><a name="18547"> </a><a name="18548" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="18550"> </a><a name="18551" href="/2016/one-lambda-calculus-many-times/#18536" class="Bound">A</a><a name="18552"> </a><a name="18553" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#721" class="InductiveConstructor Operator" target="_blank">∷</a><a name="18554"> </a><a name="18555" href="/2016/one-lambda-calculus-many-times/#18540" class="Bound">Γ</a><a name="18556"> </a><a name="18557" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="18558"> </a><a name="18559" href="/2016/one-lambda-calculus-many-times/#18538" class="Bound">B</a><a name="18560" class="Symbol">)</a><a name="18561">
          </a><a name="18572" class="Symbol">→</a><a name="18573"> </a><a name="18574" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18575"> </a><a name="18576" href="/2016/one-lambda-calculus-many-times/#5377" class="InductiveConstructor">⇒i</a><a name="18578"> </a><a name="18579" href="/2016/one-lambda-calculus-many-times/#18544" class="Bound">f</a><a name="18580"> </a><a name="18581" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="18582"> </a><a name="18583" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#4497" class="Datatype Operator" target="_blank">≡</a><a name="18584"> </a><a name="18585" href="/2016/one-lambda-calculus-many-times/#17088" class="Function">⇒i′</a><a name="18588"> </a><a name="18593" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18594"> </a><a name="18595" href="/2016/one-lambda-calculus-many-times/#18544" class="Bound">f</a><a name="18596"> </a><a name="18597" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a><a name="18598">

      </a><a name="18606" href="/2016/one-lambda-calculus-many-times/#18606" class="Postulate">weak≡weak′</a><a name="18616">
        </a><a name="18625" class="Symbol">:</a><a name="18626"> </a><a name="18637" class="Symbol">(</a><a name="18638" href="/2016/one-lambda-calculus-many-times/#18638" class="Bound">f</a><a name="18639"> </a><a name="18640" class="Symbol">:</a><a name="18641"> </a><a name="18642" href="/2016/one-lambda-calculus-many-times/#5309" class="Datatype Operator">ND</a><a name="18644"> </a><a name="18645" href="/2016/one-lambda-calculus-many-times/#18634" class="Bound">Γ</a><a name="18646"> </a><a name="18647" href="/2016/one-lambda-calculus-many-times/#3917" class="InductiveConstructor Operator">⊢</a><a name="18648"> </a><a name="18649" href="/2016/one-lambda-calculus-many-times/#18632" class="Bound">B</a><a name="18650" class="Symbol">)</a><a name="18651">
          </a><a name="18662" class="Symbol">→</a><a name="18663"> </a><a name="18664" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18665"> </a><a name="18666" href="/2016/one-lambda-calculus-many-times/#8541" class="Function">weak</a><a name="18670"> </a><a name="18691" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟦</a><a name="18692"> </a><a name="18693" href="/2016/one-lambda-calculus-many-times/#18638" class="Bound">f</a><a name="18694"> </a><a name="18695" href="/2016/one-lambda-calculus-many-times/#12484" class="Field Operator">⟧</a></pre>
</div>
